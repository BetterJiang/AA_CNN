Journal of Artiﬁcial Intelligence Research 19 (2003) 399-468

Submitted 1/02; published 10/03

Eﬃcient Solution Algorithms for Factored MDPs

Carlos Guestrin
Computer Science Dept., Stanford University
Daphne Koller
Computer Science Dept., Stanford University
Ronald Parr
Computer Science Dept., Duke University
Shobha Venkataraman
Computer Science Dept., Carnegie Mellon University

guestrin@cs.stanford.edu

koller@cs.stanford.edu

parr@cs.duke.edu

shobha@cs.cmu.edu

Abstract

This paper addresses the problem of planning under uncertainty in large Markov Decision
Processes (MDPs). Factored MDPs represent a complex state space using state variables and
the transition model using a dynamic Bayesian network. This representation often allows an
exponential reduction in the representation size of structured MDPs, but the complexity of exact
solution algorithms for such MDPs can grow exponentially in the representation size. In this paper,
we present two approximate solution algorithms that exploit structure in factored MDPs. Both
use an approximate value function represented as a linear combination of basis functions, where
each basis function involves only a small subset of the domain variables. A key contribution of this
paper is that it shows how the basic operations of both algorithms can be performed eﬃciently
in closed form, by exploiting both additive and context-speciﬁc structure in a factored MDP. A
central element of our algorithms is a novel linear program decomposition technique, analogous to
variable elimination in Bayesian networks, which reduces an exponentially large LP to a provably
equivalent, polynomial-sized one. One algorithm uses approximate linear programming, and the
second approximate dynamic programming. Our dynamic programming algorithm is novel in that
it uses an approximation based on max-norm, a technique that more directly minimizes the terms
that appear in error bounds for approximate MDP algorithms. We provide experimental results
on problems with over 1040 states, demonstrating a promising indication of the scalability of our
approach, and compare our algorithm to an existing state-of-the-art approach, showing, in some
problems, exponential gains in computation time.

1. Introduction

Over the last few years, Markov Decision Processes (MDPs) have been used as the basic
semantics for optimal planning for decision theoretic agents in stochastic environments. In
the MDP framework, the system is modeled via a set of states which evolve stochastically.
The main problem with this representation is that, in virtually any real-life domain, the
state space is quite large. However, many large MDPs have signiﬁcant internal structure,
and can be modeled compactly if the structure is exploited in the representation.

Factored MDPs (Boutilier, Dearden, & Goldszmidt, 2000) are one approach to repre-
senting large, structured MDPs compactly. In this framework, a state is implicitly described
by an assignment to some set of state variables. A dynamic Bayesian network (DBN) (Dean
& Kanazawa, 1989) can then allow a compact representation of the transition model, by
exploiting the fact that the transition of a variable often depends only on a small number

c(cid:176)2003 AI Access Foundation and Morgan Kaufmann Publishers. All rights reserved.

Guestrin, Koller, Parr & Venkataraman

of other variables. Furthermore, the momentary rewards can often also be decomposed as
a sum of rewards related to individual variables or small clusters of variables.

There are two main types of structure that can simultaneously be exploited in factored
MDPs: additive and context-speciﬁc structure. Additive structure captures the fact that
typical large-scale systems can often be decomposed into a combination of locally inter-
acting components. For example, consider the management of a large factory with many
production cells. Of course, in the long run, if a cell positioned early in the production line
generates faulty parts, then the whole factory may be aﬀected. However, the quality of the
parts a cell generates depends directly only on the state of this cell and the quality of the
parts it receives from neighboring cells. Such additive structure can also be present in the
reward function. For example, the cost of running the factory depends, among other things,
on the sum of the costs of maintaining each local cell.

Context-speciﬁc structure encodes a diﬀerent type of locality of inﬂuence: Although a
part of a large system may, in general, be inﬂuenced by the state of every other part of this
system, at any given point in time only a small number of parts may inﬂuence it directly.
In our factory example, a cell responsible for anodization may receive parts directly from
any other cell in the factory. However, a work order for a cylindrical part may restrict this
dependency only to cells that have a lathe. Thus, in the context of producing cylindrical
parts, the quality of the anodized parts depends directly only on the state of cells with a
lathe.

Even when a large MDP can be represented compactly, for example, by using a factored
representation, solving it exactly may still be intractable: Typical exact MDP solution al-
gorithms require the manipulation of a value function, whose representation is linear in the
number of states, which is exponential in the number of state variables. One approach is
to approximate the solution using an approximate value function with a compact represen-
tation. A common choice is the use of linear value functions as an approximation — value
functions that are a linear combination of potentially non-linear basis functions (Bellman,
Kalaba, & Kotkin, 1963; Sutton, 1988; Tsitsiklis & Van Roy, 1996b). Our work builds on
the ideas of Koller and Parr (1999, 2000), by using factored (linear) value functions, where
each basis function is restricted to some small subset of the domain variables.

This paper presents two new algorithms for computing linear value function approxi-
mations for factored MDPs: one that uses approximate dynamic programming and another
that uses approximate linear programming. Both algorithms are based on the use of fac-
tored linear value functions, a highly expressive function approximation method. This
representation allows the algorithms to take advantage of both additive and context-speciﬁc
structure, in order to produce high-quality approximate solutions very eﬃciently. The ca-
pability to exploit both types of structure distinguishes these algorithms diﬀer from earlier
approaches (Boutilier et al., 2000), which only exploit context-speciﬁc structure. We provide
a more detailed discussion of the diﬀerences in Section 10.

We show that, for a factored MDP and factored value functions, various critical oper-
ations for our planning algorithms can be implemented in closed form without necessarily
enumerating the entire state space. In particular, both our new algorithms build upon a
novel linear programming decomposition technique. This technique reduces structured LPs
with exponentially many constraints to equivalent, polynomially-sized ones. This decompo-
sition follows a procedure analogous to variable elimination that applies both to additively

400

Efficient Solution Algorithms for Factored MDPs

structured value functions (Bertele & Brioschi, 1972) and to value functions that also ex-
ploit context-speciﬁc structure (Zhang & Poole, 1999). Using these basic operations, our
planning algorithms can be implemented eﬃciently, even though the size of the state space
grows exponentially in the number of variables.

Our ﬁrst method is based on the approximate linear programming algorithm (Schweitzer
& Seidmann, 1985). This algorithm generates a linear, approximate value function by
solving a single linear program. Unfortunately, the number of constraints in the LP proposed
by Schweitzer and Seidmann grows exponentially in the number of variables. Using our LP
decomposition technique, we exploit structure in factored MDPs to represent exactly the
same optimization problem with exponentially fewer constraints.

In terms of approximate dynamic programming, this paper makes a twofold contribution.
First, we provide a new approach for approximately solving MDPs using a linear value
function. Previous approaches to linear function approximation typically have utilized a
least squares (L2-norm) approximation to the value function. Least squares approximations
are incompatible with most convergence analyses for MDPs, which are based on max-norm.
We provide the ﬁrst MDP solution algorithms — both value iteration and policy iteration —
that use a linear max-norm projection to approximate the value function, thereby directly
optimizing the quantity that appears in our provided error bounds. Second, we show how
to exploit the structure of the problem to apply this technique to factored MDPs, by again
leveraging on our LP decomposition technique.

Although approximate dynamic programming currently possesses stronger theoretical
guarantees, our experimental results suggest that approximate linear programming is a
good alternative. Whereas the former tends to generate better policies for the same set of
basis functions, due to the simplicity and computational advantages of approximate linear
programming, we can add more basis functions, obtaining a better policy and still requiring
less computation than the approximate dynamic programming approach.

Finally, we present experimental results comparing our approach to the work of Boutilier
et al. (2000), illustrating some of the tradeoﬀs between the two methods. In particular, for
problems with signiﬁcant context-speciﬁc structure in the value function, their approach
can be faster due to their eﬃcient handling of their value function representation. However,
there are cases with signiﬁcant context-speciﬁc structure in the problem, rather than in
the value function, in which their algorithm requires an exponentially large value function
representation. In such classes of problems, we demonstrate that by using a value func-
tion that exploits both additive and context-speciﬁc structure, our algorithm can obtain a
polynomial-time near-optimal approximation of the true value function.

This paper starts with a presentation of factored MDPs and approximate solution al-
gorithms for MDPs. In Section 4, we describe the basic operations used in our algorithms,
including our LP decomposition technique. In Section 5, we present the ﬁrst of our two
algorithms: the approximate linear programming algorithm for factored MDPs. The second
algorithm, approximate policy iteration with max-norm projection, is presented in Section 6.
Section 7 describes an approach for eﬃciently computing bounds on policy quality based on
the Bellman error. Section 8 shows how to extend our methods to deal with context-speciﬁc
structure. Our paper concludes with an empirical evaluation in Section 9 and a discussion
of related work in Section 10.

401

Guestrin, Koller, Parr & Venkataraman

This paper is a greatly expanded version of work that was published before in Guestrin

et al. (2001a), and some of the work presented in Guestrin et al. (2001b, 2002).

2. Factored Markov Decision Processes

A Markov decision process (MDP) is a mathematical framework for sequential decision
problems in stochastic domains. It thus provides an underlying semantics for the task of
planning under uncertainty. We begin with a concise overview of the MDP framework, and
then describe the representation of factored MDPs.

2.1 Markov Decision Processes
We brieﬂy review the MDP framework, referring the reader to the books by Bertsekas and
Tsitsiklis (1996) or Puterman (1994) for a more in-depth review. A Markov Decision Process
(MDP) is deﬁned as a 4-tuple (X, A, R, P ) where: X is a ﬁnite set of |X| = N states; A is
a ﬁnite set of actions; R is a reward function R : X × A (cid:55)→ R, such that R(x, a) represents
the reward obtained by the agent in state x after taking action a; and P is a Markovian
transition model where P (x(cid:48) | x, a) represents the probability of going from state x to state
x(cid:48) with action a. We assume that the rewards are bounded, that is, there exists Rmax such
that Rmax ≥ |R(x, a)| ,∀x, a.

Example 2.1 Consider the problem of optimizing the behavior of a system administrator
(SysAdmin) maintaining a network of m computers.
In this network, each machine is
connected to some subset of the other machines. Various possible network topologies can be
deﬁned in this manner (see Figure 1 for some examples). In one simple network, we might
connect the machines in a ring, with machine i connected to machines i + 1 and i − 1. (In
this example, we assume addition and subtraction are performed modulo m.)

Each machine is associated with a binary random variable Xi, representing whether it
is working or has failed. At every time step, the SysAdmin receives a certain amount of
money (reward) for each working machine. The job of the SysAdmin is to decide which
machine to reboot; thus, there are m+1 possible actions at each time step: reboot one of the
m machines or do nothing (only one machine can be rebooted per time step). If a machine
is rebooted, it will be working with high probability at the next time step. Every machine
has a small probability of failing at each time step. However, if a neighboring machine fails,
this probability increases dramatically. These failure probabilities deﬁne the transition model
P (x(cid:48) | x, a), where x is a particular assignment describing which machines are working or
have failed in the current time step, a is the SysAdmin’s choice of machine to reboot and x(cid:48)
is the resulting state in the next time step.

We assume that the MDP has an inﬁnite horizon and that future rewards are discounted
exponentially with a discount factor γ ∈ [0, 1). A stationary policy π for an MDP is a
mapping π : X (cid:55)→ A, where π(x) is the action the agent takes at state x. In the computer
network problem, for each possible conﬁguration of working and failing machines, the policy
would tell the SysAdmin which machine to reboot. Each policy is associated with a value
function Vπ ∈ RN , where Vπ(x) is the discounted cumulative value that the agent gets if
it starts at state x and follows policy π. More precisely, the value Vπ of a state x under

402

Efficient Solution Algorithms for Factored MDPs

Figure 1: Network topologies tested; the status of a machine is inﬂuence by the status of

its parent in the network.

policy π is given by:

(cid:34) ∞(cid:88)

t=0

(cid:179)

γtR

Vπ(x) = Eπ

(cid:180)(cid:175)(cid:175)(cid:175)(cid:175)(cid:175) X(0) = x
(cid:35)

X(t), π(X(t))

,

where X(t) is a random variable representing the state of the system after t steps. In our
running example, the value function represents how much money the SysAdmin expects to
collect if she starts acting according to π when the network is at state x. The value function
for a ﬁxed policy is the ﬁxed point of a set of linear equations that deﬁne the value of a
state in terms of the value of its possible successor states. More formally, we deﬁne:
Deﬁnition 2.2 The DP operator, Tπ, for a stationary policy π is:

TπV(x) = R(x, π(x)) + γ

P (x(cid:48) | x, π(x))V(x(cid:48)).

(cid:88)

x(cid:48)

(cid:88)

x(cid:48)

The value function of policy π, Vπ, is the ﬁxed point of the Tπ operator: Vπ = TπVπ.

The optimal value function V∗ describes the optimal value the agent can achieve for
each starting state. V∗ is also deﬁned by a set of non-linear equations. In this case, the
value of a state must be the maximal expected value achievable by any policy starting at
that state. More precisely, we deﬁne:
Deﬁnition 2.3 The Bellman operator, T ∗, is:

T ∗V(x) = max

[R(x, a) + γ

a

P (x(cid:48) | x, a)V(x(cid:48))].

The optimal value function V∗ is the ﬁxed point of T ∗: V∗ = T ∗V∗.

For any value function V, we can deﬁne the policy obtained by acting greedily relative
to V. In other words, at each state, the agent takes the action that maximizes the one-step

403

ServerBidirectionalRingRing and StarServerStarServer3 LegsRing of RingsGuestrin, Koller, Parr & Venkataraman

utility, assuming that V represents our long-term utility achieved at the next state. More
precisely, we deﬁne:

Greedy(V)(x) = arg max

[R(x, a) + γ

a

(cid:88)

x(cid:48)

P (x(cid:48) | x, a)V(x(cid:48))].

(1)

The greedy policy relative to the optimal value function V∗ is the optimal policy π∗ =
Greedy(V∗).

2.2 Factored MDPs
Factored MDPs are a representation language that allows us to exploit problem structure
to represent exponentially large MDPs very compactly. The idea of representing a large
MDP using a factored model was ﬁrst proposed by Boutilier et al. (1995).
In a factored MDP, the set of states is described via a set of random variables X =
{X1, . . . , Xn}, where each Xi takes on values in some ﬁnite domain Dom(Xi). A state x
deﬁnes a value xi ∈ Dom(Xi) for each variable Xi. In general, we use upper case letters
(e.g., X) to denote random variables, and lower case (e.g., x) to denote their values. We
use boldface to denote vectors of variables (e.g., X) or their values (x). For an instantiation
y ∈ Dom(Y) and a subset of these variables Z ⊂ Y, we use y[Z] to denote the value of the
variables Z in the instantiation y.

In a factored MDP, we deﬁne a state transition model τ using a dynamic Bayesian
network (DBN) (Dean & Kanazawa, 1989). Let Xi denote the variable Xi at the current
time and X(cid:48)
i, the same variable at the next step. The transition graph of a DBN is a
two-layer directed acyclic graph Gτ whose nodes are {X1, . . . , Xn, X(cid:48)
n}. We denote
the parents of X(cid:48)
i in the graph by Parentsτ (X(cid:48)
i). For simplicity of exposition, we assume
i) ⊆ X; thus, all arcs in the DBN are between variables in consecutive
that Parentsτ (X(cid:48)
time slices. (This assumption is used for expository purposes only; intra-time slice arcs
are handled by a small modiﬁcation presented in Section 4.1.) Each node X(cid:48)
i is associated
with a conditional probability distribution (CPD) Pτ (X(cid:48)
i)). The transition
probability Pτ (x(cid:48) | x) is then deﬁned to be:
Pτ (x(cid:48) | x) =

i | Parentsτ (X(cid:48)

1, . . . , X(cid:48)

Pτ (x(cid:48)

i | ui) ,

(cid:89)

i

where ui is the value in x of the variables in Parentsτ (X(cid:48)
i).
Example 2.4 Consider an instance of the SysAdmin problem with four computers, labelled
M1, . . . , M4, in an unidirectional ring topology as shown in Figure 2(a). Our ﬁrst task in
modeling this problem as a factored MDP is to deﬁne the state space X. Each machine
is associated with a binary random variable Xi, representing whether it is working or has
failed. Thus, our state space is represented by four random variables: {X1, X2, X3, X4}.
The next task is to deﬁne the transition model, represented as a DBN. The parents of the
next time step variables X(cid:48)
i depend on the network topology. Speciﬁcally, the probability that
machine i will fail at the next time step depends on whether it is working at the current
time step and on the status of its direct neighbors (parents in the topology) in the network
at the current time step. As shown in Figure 2(b), the parents of X(cid:48)
i in this example are Xi
and Xi−1. The CPD of X(cid:48)
i = false with high probability;

i is such that if Xi = false, then X(cid:48)

404

Efficient Solution Algorithms for Factored MDPs

P (X(cid:48)

i = t | Xi, Xi−1, A):

Xi−1 = f ∧
Xi−1 = f ∧
Xi−1 = t ∧
Xi−1 = t ∧

Xi = t

Xi = f

Xi = f

(a)

(b)

Xi = t

Action is reboot:

machine i

other machine

0.0238

0.475

0.0475

0.95

1

1

1

1

(c)

Figure 2: Factored MDP example:

from a network topology (a) we obtain the factored

MDP representation (b) with the CPDs described in (c).

that is, failures tend to persist. If Xi = true, then X(cid:48)
the unidirectional ring topology X(cid:48)
of its neighbors can independently cause machine i to fail.

i is a noisy or of its other parents (in
i has only one other parent Xi−1); that is, a failure in any

We have described how to represent factored the Markovian transition dynamics arising
from an MDP as a DBN, but we have not directly addressed the representation of actions.
Generally, we can deﬁne the transition dynamics of an MDP by deﬁning a separate DBN
model τa = (cid:104)Ga, Pa(cid:105) for each action a.

Example 2.5 In our system administrator example, we have an action ai for rebooting
each one of the machines, and a default action d for doing nothing. The transition model
described above corresponds to the “do nothing” action. The transition model for ai is
diﬀerent from d only in the transition model for the variable X(cid:48)
i = true
with probability one, regardless of the status of the neighboring machines. Figure 2(c) shows
i = W orking | Xi, Xi−1, A), with one entry for each assignment to
the actual CPD for P (X(cid:48)
the state variables Xi and Xi−1, and to the action A.

i, which is now X(cid:48)

To fully specify an MDP, we also need to provide a compact representation of the reward
function. We assume that the reward function is factored additively into a set of localized
reward functions, each of which only depends on a small set of variables. In our example, we
might have a reward function associated with each machine i, which depends on Xi. That
is, the SysAdmin is paid on a per-machine basis: at every time step, she receives money for
machine i only if it is working. We can formalize this concept of localized functions:
Deﬁnition 2.6 A function f has a scope Scope[f] = C ⊆ X if f : Dom(C) (cid:55)→ R.
If f has scope Y and Y ⊂ Z, we use f(z) as shorthand for f(y) where y is the part of the
instantiation z that corresponds to variables in Y.

405

M4M1M3M2R3R3X4X4R2R2R1R1X1X1X3X3X2X2X’3X’3X’4’X’4’X’2X’2X’1X’1h3h3h4h4h2h2h1h1R4R4Guestrin, Koller, Parr & Venkataraman

We can now characterize the concept of local rewards. Let Ra

r be a set of
i ⊂ {X1, . . . , Xn}.
functions, where the scope of each Ra
i ) ∈ R. In
The reward for taking action a at state x is deﬁned to be Ra(x) =
i=1 Ra
our example, we have a reward function Ri associated with each machine i, which depends
only Xi, and does not depend on the action choice. These local rewards are represented
by the diamonds in Figure 2(b), in the usual notation for inﬂuence diagrams (Howard &
Matheson, 1984).

i is restricted to variable cluster Ua

1, . . . , Ra

(cid:80)r

i (Ua

3. Approximate Solution Algorithms

There are several algorithms to compute the optimal policy in an MDP. The three most
commonly used are value iteration, policy iteration, and linear programming. A key compo-
nent in all three algorithms is the computation of value functions, as deﬁned in Section 2.1.
Recall that a value function deﬁnes a value for each state x in the state space. With an
explicit representation of the value function as a vector of values for the diﬀerent states,
the solution algorithms all can be implemented as a series of simple algebraic steps. Thus,
in this case, all three can be implemented very eﬃciently.

Unfortunately, in the case of factored MDPs, the state space is exponential in the number
of variables in the domain. In the SysAdmin problem, for example, the state x of the system
is an assignment describing which machines are working or have failed; that is, a state x
is an assignment to each random variable Xi. Thus, the number of states is exponential in
the number m of machines in the network (|X| = N = 2m). Hence, even representing an
explicit value function in problems with more than about ten machines is infeasible. One
might be tempted to believe that factored transition dynamics and rewards would result in
a factored value function, which can thereby be represented compactly. Unfortunately, even
in trivial factored MDPs, there is no guarantee that structure in the model is preserved in
the value function (Koller & Parr, 1999).

In this section, we discuss the use of an approximate value function, that admits a
compact representation. We also describe approximate versions of these exact algorithms,
that use approximate value functions. Our description in this section is somewhat abstract,
and does not specify how the basic operations required by the algorithms can be performed
explicitly. In later sections, we elaborate on these issues, and describe the algorithms in
detail. For brevity, we choose to focus on policy iteration and linear programming; our
techniques easily extend to value iteration.

3.1 Linear Value Functions
A very popular choice for approximating value functions is by using linear regression, as ﬁrst
proposed by Bellman et al. (1963). Here, we deﬁne our space of allowable value functions
V ∈ H ⊆ RN via a set of basis functions:
Deﬁnition 3.1 A linear value function over a set of basis functions H = {h1, . . . , hk}
is a function V that can be written as V(x) =
j=1 wj hj(x) for some coeﬃcients w =
(w1, . . . , wk)(cid:48).
We can now deﬁne H to be the linear subspace of RN spanned by the basis functions H.
It is useful to deﬁne an N × k matrix H whose columns are the k basis functions viewed as

(cid:80)k

406

Efficient Solution Algorithms for Factored MDPs

vectors. In a more compact notation, our approximate value function is then represented
by Hw.

The expressive power of this linear representation is equivalent, for example, to that
of a single layer neural network with features corresponding to the basis functions deﬁning
H. Once the features are deﬁned, we must optimize the coeﬃcients w in order to obtain a
good approximation for the true value function. We can view this approach as separating
the problem of deﬁning a reasonable space of features and the induced space H, from the
problem of searching within the space. The former problem is typically the purview of
domain experts, while the latter is the focus of analysis and algorithmic design. Clearly,
feature selection is an important issue for essentially all areas of learning and approximation.
We oﬀer some simple methods for selecting good features for MDPs in Section 11, but it is
not our goal to address this large and important topic in this paper.

Once we have a chosen a linear value function representation and a set of basis functions,
the problem becomes one of ﬁnding values for the weights w such that Hw will yield
a good approximation of the true value function.
In this paper, we consider two such
approaches: approximate dynamic programming using policy iteration and approximate
linear programming. In this section, we present these two approaches. In Section 4, we
show how we can exploit problem structure to transform these approaches into practical
algorithms that can deal with exponentially large state spaces.

3.2 Policy Iteration

3.2.1 The Exact Algorithm
The exact policy iteration algorithm iterates over policies, producing an improved policy at
each iteration. Starting with some initial policy π(0), each iteration consists of two phases.
Value determination computes, for a policy π(t), the value function Vπ(t), by ﬁnding the
ﬁxed point of the equation Tπ(t)Vπ(t) = Vπ(t), that is, the unique solution to the set of linear
equations:

(cid:88)

x(cid:48)

Vπ(t)(x) = R(x, π(t)(x)) + γ

P (x(cid:48) | x, π(t)(x))Vπ(t)(x(cid:48)),∀x.

The policy improvement step deﬁnes the next policy as
π(t+1) = Greedy(Vπ(t)).

It can be shown that this process converges to the optimal policy (Bertsekas & Tsitsiklis,
1996). Furthermore, in practice, the convergence to the optimal policy is often very quick.

3.2.2 Approximate Policy Iteration
The steps in the policy iteration algorithm require a manipulation of both value functions
and policies, both of which often cannot be represented explicitly in large MDPs. To deﬁne
a version of the policy iteration algorithm that uses approximate value functions, we use
the following basic idea: We restrict the algorithm to using only value functions within the
provided H; whenever the algorithm takes a step that results in a value function V that is
outside this space, we project the result back into the space by ﬁnding the value function
within the space which is closest to V. More precisely:

407

Guestrin, Koller, Parr & Venkataraman

Deﬁnition 3.2 A projection operator Π is a mapping Π : RN → H. Π is said to be a
projection w.r.t. a norm (cid:107)·(cid:107) if ΠV = Hw∗ such that w∗ ∈ arg minw (cid:107)Hw − V(cid:107).
That is, ΠV is the linear combination of the basis functions, that is closest to V with respect
to the chosen norm.

Our approximate policy iteration algorithm performs the policy improvement step ex-
actly. In the value determination step, the value function — the value of acting according to
the current policy π(t) — is approximated through a linear combination of basis functions.
We now consider the problem of value determination for a policy π(t). At this point,
it is useful to introduce some notation: Although the rewards are a function of the state
and action choice, once the policy is ﬁxed, the rewards become a function of the state
only, which we denote as Rπ(t), where Rπ(t)(x) = R(x, π(t)(x)). Similarly, for the transition
model: Pπ(t)(x(cid:48) | x) = P (x(cid:48) | x, π(t)(x)). We can now rewrite the value determination step
in terms of matrices and vectors. If we view Vπ(t) and Rπ(t) as N-vectors, and Pπ(t) as an
N × N matrix, we have the equations:

Vπ(t) = Rπ(t) + γPπ(t)Vπ(t).

This is a system of linear equations with one equation for each state, which can only be
solved exactly for relatively small N. Our goal is to provide an approximate solution, within
H. More precisely, we want to ﬁnd:

(cid:107)Hw − (Rπ(t) + γPπ(t)Hw)(cid:107) ;

(cid:176)(cid:176)(cid:176)(H − γPπ(t)H) w(t) − Rπ(t)

(cid:176)(cid:176)(cid:176) .

w(t) = arg min
w
= arg min
w

Thus, our approximate policy iteration alternates between two steps:
(cid:107)Hw − (Rπ(t) + γPπ(t)Hw)(cid:107) ;

w(t) = arg min
w

π(t+1) = Greedy(Hw(t)).

(2)

(3)

3.2.3 Max-norm Projection
An approach along the lines described above has been used in various papers, with several
recent theoretical and algorithmic results (Schweitzer & Seidmann, 1985; Tsitsiklis & Van
Roy, 1996b; Van Roy, 1998; Koller & Parr, 1999, 2000). However, these approaches suﬀer
from a problem that we might call “norm incompatibility.” When computing the projection,
they utilize the standard Euclidean projection operator with respect to the L2 norm or a
weighted L2 norm.1 On the other hand, most of the convergence and error analyses for MDP
algorithms utilize max-norm (L∞). This incompatibility has made it diﬃcult to provide
error guarantees.
We can tie the projection operator more closely to the error bounds through the use
of a projection operator in L∞ norm. The problem of minimizing the L∞ norm has been
studied in the optimization literature as the problem of ﬁnding the Chebyshev solution2 to
1. Weighted L2 norm projections are stable and have meaningful error bounds when the weights correspond
to the stationary distribution of a ﬁxed policy under evaluation (value determination) (Van Roy, 1998),
but they are not stable when combined with T ∗. Averagers (Gordon, 1995) are stable and non-expansive
in L∞, but require that the mixture weights be determined a priori. Thus, they do not, in general,
minimize L∞ error.
2. The Chebyshev norm is also referred to as max, supremum and L∞ norms and the minimax solution.

408

Efficient Solution Algorithms for Factored MDPs

an overdetermined linear system of equations (Cheney, 1982). The problem is deﬁned as
ﬁnding w∗ such that:

w∗ ∈ arg min

(cid:107)Cw − b(cid:107)∞ .

w

(4)

We use an algorithm due to Stiefel (1960), that solves this problem by linear program-

ming:

Variables: w1, . . . , wk, φ ;
Minimize:

Subject to: φ ≥(cid:80)k
φ ≥ bi −(cid:80)k

j=1 cijwj − bi
j=1 cijwj,

φ ;

and
i = 1...N.

(cid:175)(cid:175)(cid:175)(cid:80)k

(5)

(cid:175)(cid:175)(cid:175) for each i, or

The constraints in this linear program imply that φ ≥
equivalently, that φ ≥ (cid:107)Cw − b(cid:107)∞. The objective of the LP is to minimize φ. Thus, at the
solution (w∗, φ∗) of this linear program, w∗ is the solution of Equation (4) and φ is the L∞
projection error.
We can use the L∞ projection in the context of the approximate policy iteration in the
obvious way. When implementing the projection operation of Equation (2), we can use
the L∞ projection (as in Equation (4)), where C = (H − γPπ(t)H) and b = Rπ(t). This
minimization can be solved using the linear program of (5).

j=1 cijwj − bi

A key point is that this LP only has k + 1 variables. However, there are 2N constraints,
which makes it impractical for large state spaces. In the SysAdmin problem, for example,
the number of constraints in this LP is exponential in the number of machines in the network
(a total of 2· 2m constraints for m machines). In Section 4, we show that, in factored MDPs
with linear value functions, all the 2N constraints can be represented eﬃciently, leading to
a tractable algorithm.

3.2.4 Error Analysis
We motivated our use of the max-norm projection within the approximate policy iteration
algorithm via its compatibility with standard error analysis techniques for MDP algorithms.
We now provide a careful analysis of the impact of the L∞ error introduced by the projec-
tion step. The analysis provides motivation for the use of a projection step that directly
minimizes this quantity. We acknowledge, however, that the main impact of this analysis
is motivational. In practice, we cannot provide a priori guarantees that an L∞ projection
will outperform other methods.

Our goal is to analyze approximate policy iteration in terms of the amount of error
If the error is zero, then we are
introduced at each step by the projection operation.
performing exact value determination, and no error should accrue. If the error is small, we
should get an approximation that is accurate. This result follows from the analysis below.
More precisely, we deﬁne the projection error as the error resulting from the approximate
value determination step:

(cid:176)(cid:176)(cid:176)Hw(t) −

(cid:179)

β(t) =

Rπ(t) + γPπ(t)Hw(t)

(cid:180)(cid:176)(cid:176)(cid:176)∞ .

Note that, by using our max-norm projection, we are ﬁnding the set of weights w(t) that
exactly minimizes the one-step projection error β(t). That is, we are choosing the best

409

Guestrin, Koller, Parr & Venkataraman

possible weights with respect to this error measure. Furthermore, this is exactly the error
measure that is going to appear in the bounds of our theorem. Thus, we can now make the
bounds for each step as tight as possible.

We ﬁrst show that the projection error accrued in each step is bounded:

Lemma 3.3 The value determination error is bounded: There exists a constant βP ≤ Rmax
such that βP ≥ β(t) for all iterations t of the algorithm.
Proof: See Appendix A.1.

Due to the contraction property of the Bellman operator, the overall accumulated error

is a decaying average of the projection error incurred throughout all iterations:

Deﬁnition 3.4 The discounted value determination error at iteration t is deﬁned as: β
β(t) + γβ

(t−1); β

(0) = 0.

(t) =

Lemma 3.3 implies that the accumulated error remains bounded in approximate policy
iteration: β
. We can now bound the loss incurred when acting according
to the policy generated by our approximate policy iteration algorithm, as opposed to the
optimal policy:

(t) ≤ βP (1−γt)

1−γ

Theorem 3.5 In the approximate policy iteration algorithm, let π(t) be the policy generated
at iteration t. Furthermore, let Vπ(t) be the actual value of acting according to this policy.
The loss incurred by using policy π(t) as opposed to the optimal policy π∗ with value V∗ is
bounded by:

(cid:107)V∗ − Vπ(t)(cid:107)∞ ≤ γt (cid:107)V∗ − Vπ(0)(cid:107)∞ +

(t)

2γβ
(1 − γ)2 .

(6)

Proof: See Appendix A.2.

In words, Equation (6) shows that the diﬀerence between our approximation at iteration
t and the optimal value function is bounded by the sum of two terms. The ﬁrst term is
present in standard policy iteration and goes to zero exponentially fast. The second is the
discounted accumulated projection error and, as Lemma 3.3 shows, is bounded. This second
term can be minimized by choosing w(t) as the one that minimizes:

(cid:176)(cid:176)(cid:176)Hw(t) −

(cid:179)

(cid:180)(cid:176)(cid:176)(cid:176)∞ ,

Rπ(t) + γPπ(t)Hw(t)

which is exactly the computation performed by the max-norm projection. Therefore, this
theorem motivates the use of max-norm projections to minimize the error term that appears
in our bound.

The bounds we have provided so far may seem fairly trivial, as we have not provided
a strong a priori bound on β(t). Fortunately, several factors make these bounds interest-
ing despite the lack of a priori guarantees. If approximate policy iteration converges, as

occurred in all of our experiments, we can obtain a much tighter bound: If (cid:98)π is the policy

after convergence, then:

where β(cid:98)π is the one-step max-norm projection error associated with estimating the value
of (cid:98)π. Since the max-norm projection operation provides β(cid:98)π, we can easily obtain an a

(1 − γ) ,

(cid:176)(cid:176)V∗ − V(cid:98)π

(cid:176)(cid:176)∞ ≤ 2γβ(cid:98)π

410

Efficient Solution Algorithms for Factored MDPs

posteriori bound as part of the policy iteration procedure. More details are provided in
Section 7.

One could rewrite the bound in Theorem 3.5 in terms of the worst case projection er-
ror βP , or the worst projection error in a cycle of policies, if approximate policy iteration
gets stuck in a cycle. These formulations would be closer to the analysis of Bertsekas and
Tsitsiklis (1996, Proposition 6.2, p.276). However, consider the case where most policies
(or most policies in the ﬁnal cycle) have a low projection error, but there are a few policies
that cannot be approximated well using the projection operation, so that they have a large
one-step projection error. A worst-case bound would be very loose, because it would be
dictated by the error of the most diﬃcult policy to approximate. On the other hand, using
our discounted accumulated error formulation, errors introduced by policies that are hard
to approximate decay very rapidly. Thus, the error bound represents an “average” case
analysis: a decaying average of the projection errors for policies encountered at the succes-
sive iterations of the algorithm. As in the convergent case, this bound can be computed
easily as part of the policy iteration procedure when max-norm projection is used.

The practical beneﬁt of a posteriori bounds is that they can give meaningful feedback on
the impact of the choice of the value function approximation architecture. While we are not
explicitly addressing the diﬃcult and general problem of feature selection in this paper, our
error bounds motivate algorithms that aim to minimize the error given an approximation
architecture and provide feedback that could be useful in future eﬀorts to automatically
discover or improve approximation architectures.

3.3 Approximate Linear Programming

3.3.1 The Exact Algorithm
Linear programming provides an alternative method for solving MDPs. It formulates the
problem of ﬁnding a value function as a linear program (LP). Here the LP variables are
V1, . . . , VN , where Vi represents V(xi): the value of starting at the ith state of the system.
The LP is given by:

(cid:80)

V1, . . . , VN ;

Variables:
Minimize:
Subject to: Vi ≥ [R(xi, a) + γ

xi α(xi) Vi ;

(cid:80)

j P (xj | xi, a)Vj] ∀xi ∈ X, a ∈ A,

(7)

where the state relevance weights α are positive. Note that, in this exact case, the solution
obtained is the same for any positive weight vector. It is interesting to note that steps of
the simplex algorithm correspond to policy changes at single states, while steps of policy
iteration can involve policy changes at multiple states. In practice, policy iteration tends
to be faster than the linear programming approach (Puterman, 1994).

3.3.2 Approximate Linear Program
The approximate formulation for the LP approach, ﬁrst proposed by Schweitzer and Sei-
dmann (1985), restricts the space of allowable value functions to the linear space spanned
by our basis functions. In this approximate formulation, the variables are w1, . . . , wk: the
weights for our basis functions. The LP is given by:

411

Guestrin, Koller, Parr & Venkataraman

Variables: w1, . . . , wk ;
Minimize:
Subject to:

(cid:80)
(cid:80)
x α(x)
i wi hi(x) ≥ [R(x, a) + γ

(cid:80)

i wi hi(x) ;

(cid:80)
i wi hi(x(cid:48))] ∀x ∈ X,∀a ∈ A.
(8)
In other words, this formulation takes the LP in (7) and substitutes the explicit state
value function by a linear value function representation
i wi hi(x), or, in our more compact
notation, V is replaced by Hw. This linear program is guaranteed to be feasible if a constant
function — a function with the same constant value for all states — is included in the set
of basis functions.

(cid:80)
x(cid:48) P (x(cid:48) | x, a)
(cid:80)

In this approximate linear programming formulation, the choice of state relevance weights,
α, becomes important. Intuitively, not all constraints in this LP are binding; that is, the
constraints are tighter for some states than for others. For each state x, the relevance
weight α(x) indicates the relative importance of a tight constraint. Therefore, unlike the
exact case, the solution obtained may diﬀer for diﬀerent choices of the positive weight vector
α. Furthermore, there is, in general, no guarantee as to the quality of the greedy policy
generated from the approximation Hw. However, the recent work of de Farias and Van
Roy (2001a) provides some analysis of the error relative to that of the best possible approx-
imation in the subspace, and some guidance as to selecting α so as to improve the quality
of the approximation. In particular, their analysis shows that this LP provides the best
approximation Hw∗ of the optimal value function V∗ in a weighted L1 sense subject to the
constraint that Hw∗ ≥ T ∗Hw∗, where the weights in the L1 norm are the state relevance
weights α.

The transformation from an exact to an approximate problem formulation has the ef-
fect of reducing the number of free variables in the LP to k (one for each basis function
coeﬃcient), but the number of constraints remains N × |A|. In our SysAdmin problem, for
example, the number of constraints in the LP in (8) is (m + 1)· 2m, where m is the number
of machines in the network. Thus, the process of generating the constraints and solving the
LP still seems unmanageable for more than a few machines. In the next section, we discuss
how we can use the structure of a factored MDP to provide for a compact representation
and an eﬃcient solution to this LP.

4. Factored Value Functions

The linear value function approach, and the algorithms described in Section 3, apply to any
choice of basis functions. In the context of factored MDPs, Koller and Parr (1999) suggest
a particular type of basis function, that is particularly compatible with the structure of a
factored MDP. They suggest that, although the value function is typically not structured,
there are many cases where it might be “close” to structured. That is, it might be well-
approximated using a linear combination of functions each of which refers only to a small
number of variables. More precisely, we deﬁne:

Deﬁnition 4.1 A factored (linear) value function is a linear function over the basis set
h1, . . . , hk, where the scope of each hi is restricted to some subset of variables Ci.

Value functions of this type have a long history in the area of multi-attribute utility the-
ory (Keeney & Raiﬀa, 1976). In our example, we might have a basis function hi for each

412

Efficient Solution Algorithms for Factored MDPs

machine, indicating whether it is working or not. Each basis function has scope restricted
to Xi. These are represented as diamonds in the next time step in Figure 2(b).

Factored value functions provide the key to performing eﬃcient computations over the
exponential-sized state spaces we have in factored MDPs. The main insight is that re-
stricted scope functions (including our basis functions) allow for certain basic operations to
be implemented very eﬃciently. In the remainder of this section, we show how structure in
factored MDPs can be exploited to perform two crucial operations very eﬃciently: one-step
lookahead (backprojection), and the representation of exponentially many constraints in
the LPs. Then, we use these basic building blocks to formulate very eﬃcient approxima-
tion algorithms for factored MDPs, each presented in its own self-contained section: the
approximate linear programming for factored MDPs in Section 5, and approximate policy
iteration with max-norm projection in Section 6.

4.1 One-step Lookahead
A key step in all of our algorithms is the computation of the one-step lookahead value of
some action a. This is necessary, for example, when computing the greedy policy as in
Equation (1). Let’s consider the computation of a Q function, Qa(x), which represents the
expected value the agent obtains after taking action a at the current time step and receiving
a long-term value V thereafter. This Q function can be computed by:

Qa(x) = R(x, a) + γ

P (x(cid:48) | x, a)V(x).

(9)

(cid:88)

x(cid:48)

That is, Qa(x) is given by the current reward plus the discounted expected future value.
Using this notation, we can express the greedy policy as: Greedy(V)(x) = maxa Qa(x).
functions: V(x) =

Recall that we are estimating the long-term value of our policy using a set of basis

i wi hi(x). Thus, we can rewrite Equation (9) as:

(cid:80)

Qa(x) = R(x, a) + γ

P (x(cid:48) | x, a)

wi hi(x).

(cid:88)

x(cid:48)

(cid:88)

i

(10)

(cid:80)

(cid:80)

x(cid:48) P (x(cid:48) |
The size of the state space is exponential, so that computing the expectation
i wi hi(x) seems infeasible. Fortunately, as discussed by Koller and Parr (1999),
x, a)
this expectation operation, or backprojection, can be performed eﬃciently if the transition
model and the value function are both factored appropriately. The linearity of the value
function permits a linear decomposition, where each summand in the expectation can be
viewed as an independent value function and updated in a manner similar to the value
iteration procedure used by Boutilier et al. (2000). We now recap the construction brieﬂy,
by ﬁrst deﬁning:

Ga(x) =

P (x(cid:48) | x, a)

wi

P (x(cid:48) | x, a)hi(x(cid:48)).

Thus, we can compute the expectation of each basis function separately:

(cid:88)

x(cid:48)

(cid:88)

i

(cid:88)

x(cid:48)

(cid:88)

i

wi hi(x(cid:48)) =
(cid:88)

i (x) =
ga

x(cid:48)

P (x(cid:48) | x, a)hi(x(cid:48)),

413

Guestrin, Koller, Parr & Venkataraman

i (x). The
and then weight them by wi to obtain the total expectation Ga(x) =
is called the backprojection of the basis function hi through the
intermediate function ga
i
i = Pahi. Note that, in factored MDPs, the
transition model Pa, which we denote by ga
transition model Pa is factored (represented as a DBN) and the basis functions hi have
scope restricted to a small set of variables. These two important properties allow us to
compute the backprojections very eﬃciently.

i wi ga

(cid:80)

We now show how some restricted scope function h (such as our basis functions)
can be backprojected through some transition model Pτ represented as a DBN τ. Here
h has scope restricted to Y; our goal is to compute g = Pτ h. We deﬁne the back-
projected scope of Y through τ as the set of parents of Y(cid:48) in the transition graph Gτ ;
Γτ (Y(cid:48)) = ∪Y (cid:48)
i) ∈
{X1, . . . , Xn, X(cid:48)
n}, then the only change in our algorithm is in the deﬁnition of back-
projected scope of Y through τ. The deﬁnition now includes not only direct parents of Y (cid:48),
but also all variables in {X1, . . . , Xn} that are ancestors of Y (cid:48):

i ). If intra-time slice arcs are included, so that Parentsτ (X(cid:48)

i ∈Y(cid:48)Parentsτ (Y (cid:48)

1, . . . , X(cid:48)

Γτ (Y(cid:48)) = {Xj | there exist a directed path from Xj to any X(cid:48)

i ∈ Y(cid:48)}.

Thus, the backprojected scope may become larger, but the functions are still factored.
We can now show that, if h has scope restricted to Y, then its backprojection g has
scope restricted to the parents of Y(cid:48), i.e., Γτ (Y(cid:48)). Furthermore, each backprojection can
be computed by only enumerating settings of variables in Γτ (Y(cid:48)), rather than settings of
all variables X:

g(x) = (Pτ h)(x);

(cid:88)
(cid:88)
(cid:88)
(cid:88)

y(cid:48)

x(cid:48)

x(cid:48)

=

=

=

=

y(cid:48)

= g(z);

Pτ (x(cid:48) | x)h(x(cid:48));
Pτ (x(cid:48) | x)h(y(cid:48));
Pτ (y(cid:48) | x)h(y(cid:48))

Pτ (y(cid:48) | z)h(y(cid:48));

(cid:88)

(cid:80)

Pτ (u(cid:48) | x);

u(cid:48)∈(x(cid:48)−y(cid:48))

u(cid:48)∈(x(cid:48)−y(cid:48)) Pτ (u(cid:48) | x) = 1 as it is the
where z is the value of Γτ (Y(cid:48)) in x and the term
sum of a probability distribution over a complete domain. Therefore, we see that (Pτ h) is a
function whose scope is restricted to Γτ (Y(cid:48)). Note that the cost of the computation depends
linearly on |Dom(Γτ (Y(cid:48)))|, which depends on Y (the scope of h) and on the complexity of
the process dynamics. This backprojection procedure is summarized in Figure 3.

Returning to our example, consider a basis function hi that is an indicator of variable Xi:
it takes value 1 if the ith machine is working and 0 otherwise. Each hi has scope restricted to
i) = {Xi−1, Xi}.
X(cid:48)
i, thus, its backprojection gi has scope restricted to Parentsτ (X(cid:48)

i): Γτ (X(cid:48)

4.2 Representing Exponentially Many Constraints
As seen in Section 3, both our approximation algorithms require the solution of linear pro-
grams: the LP in (5) for approximate policy iteration, and the LP in (8) for the approximate

414

Efficient Solution Algorithms for Factored MDPs

Backproja(h) — where basis function h has scope C.

Deﬁne the scope of the backprojection: Γa(C(cid:48)) = ∪X(cid:48)
For each assignment y ∈ Γa(C(cid:48)):

(cid:80)

(cid:81)

ga(y) =

c(cid:48)∈C(cid:48)

i∈C(cid:48) Pa(c(cid:48)[X(cid:48)

i|X(cid:48)

i] | y)h(c(cid:48)).

i∈C(cid:48)Parentsa(X(cid:48)
i).

Return ga.

Figure 3: Backprojection of basis function h.

linear programming algorithm. These LPs have some common characteristics: they have
a small number of free variables (for k basis functions there are k + 1 free variables in ap-
proximate policy iteration and k in approximate linear programming), but the number of
constraints is still exponential in the number of state variables. However, in factored MDPs,
these LP constraints have another very useful property: the functionals in the constraints
have restricted scope. This key observation allows us to represent these constraints very
compactly.

First, observe that the constraints in the linear programs are all of the form:

φ ≥

wi ci(x) − b(x),∀x,

(11)

i

where only φ and w1, . . . , wk are free variables in the LP and x ranges over all states. This
general form represents both the type of constraint in the max-norm projection LP in (5)
and the approximate linear programming formulation in (8).3

The ﬁrst insight in our construction is that we can replace the entire set of constraints

in Equation (11) by one equivalent non-linear constraint:

(cid:88)

(cid:88)

i

φ ≥ max

x

wi ci(x) − b(x).

(12)

The second insight is that this new non-linear constraint can be implemented by a set of
linear constraints using a construction that follows the structure of variable elimination in
cost networks. This insight allows us to exploit structure in factored MDPs to represent
this constraint compactly.

We tackle the problem of representing the constraint in Equation (12) in two steps:
ﬁrst, computing the maximum assignment for a ﬁxed set of weights; then, representing the
non-linear constraint by small set of linear constraints, using a construction we call the
factored LP.

4.2.1 Maximizing Over the State Space
The key computation in our algorithms is to represent a non-linear constraint of the form
in Equation (12) eﬃciently by a small set of linear constraints. Before presenting this con-
struction, let’s ﬁrst consider a simpler problem: Given some ﬁxed weights wi, we would
i wi ci(x) − b(x), that is, the state x, such
like to compute the maximization: φ∗ = maxx
i wi ci(x), can be formulated using an analogous
construction to the one we present in this section by changing the sign of ci(x) and b(x). The approximate
linear programming constraints of (8) can also be formulated in this form, as we show in Section 5.

(cid:80)
3. The complementary constraints in (5), φ ≥ b(x) −(cid:80)

415

Guestrin, Koller, Parr & Venkataraman

(cid:80)

that the diﬀerence between
i wi ci(x) and b(x) is maximal. However, we cannot explic-
itly enumerate the exponential number of states and compute the diﬀerence. Fortunately,
structure in factored MDPs allows us to compute this maximum eﬃciently.
In the case of factored MDPs, our state space is a set of vectors x which are assign-
ments to the state variables X = {X1, . . . , Xn}. We can view both Cw and b as functions
(cid:80)
of these state variables, and hence also their diﬀerence. Thus, we can deﬁne a function
i wi ci(x) − b(x). Note that we have executed a
F w(X1, . . . , Xn) such that F w(x) =
representation shift; we are viewing F w as a function of the variables X, which is pa-
rameterized by w. Recall that the size of the state space is exponential in the number
of variables. Hence, our goal in this section is to compute maxx F w(x) without explicitly
considering each of the exponentially many states. The solution is to use the fact that F w
has a factored representation. More precisely, Cw has the form
i wi ci(Zi), where Zi is
a subset of X. For example, we might have c1(X1, X2) which takes value 1 in states where
X1 = true and X2 = false and 0 otherwise. Similarly, the vector b in our case is also a sum
of restricted scope functions. Thus, we can express F w as a sum
j may
(cid:80)
or may not depend on w. In the future, we sometimes drop the superscript w when it is
clear from context.
i wi ci(x)−
b(x) = maxx F w(x), that is, to ﬁnd the state x over which F w is maximized. Recall that
F w =
j=1 fj(Zj). We can maximize such a function, F w, without enumerating every state
using non-serial dynamic programming (Bertele & Brioschi, 1972). The idea is virtually
identical to variable elimination in a Bayesian network. We review this construction here,
as it is a central component in our solution LP.

Using our more compact notation, our goal here is simply to compute maxx

(cid:80)
(cid:80)

j f w

j (Zj), where f w

(cid:80)m

Our goal is to compute

max
x1,...,xn

fj(x[Zj]).

(cid:88)

j

The main idea is that, rather than summing all functions and then doing the maximization,
we maximize over variables one at a time. When maximizing over xl, only summands
involving xl participate in the maximization.

Example 4.2 Assume

F = f1(x1, x2) + f2(x1, x3) + f3(x2, x4) + f4(x3, x4).

We therefore wish to compute:

max

x1,x2,x3,x4

f1(x1, x2) + f2(x1, x3) + f3(x2, x4) + f4(x3, x4).

We can ﬁrst compute the maximum over x4; the functions f1 and f2 are irrelevant, so we
can push them out. We get

max
x1,x2,x3

f1(x1, x2) + f2(x1, x3) + max
x4

[f3(x2, x4) + f4(x3, x4)].

The result of the internal maximization depends on the values of x2, x3; thus, we can intro-
duce a new function e1(X2, X3) whose value at the point x2, x3 is the value of the internal
max expression. Our problem now reduces to computing

max
x1,x2,x3

f1(x1, x2) + f2(x1, x3) + e1(x2, x3),

416

Efficient Solution Algorithms for Factored MDPs

VariableElimination (F, O)

//F = {f1, . . . , fm} is the set of functions to be maximized;
//O stores the elimination order.

For i = 1 to number of variables:

//Select the next variable to be eliminated.
Let l = O(i) ;
//Select the relevant functions.
Let e1, . . . , eL be the functions in F whose scope contains Xl.
//Maximize over current variable Xl.
Deﬁne a new function e = maxxl
∪L
j=1Scope[ej] − {Xl}.
//Update set of functions.
Update the set of functions F = F ∪ {e} \ {e1, . . . , eL}.

(cid:80)L

j=1 ej

; note that Scope[e] =

(cid:80)

//Now, all functions have empty scope and their sum is the maximum value of f1 + ··· + fm.
Return the maximum value

ei∈F ei.

Figure 4: Variable elimination procedure for computing the maximum value f1 + ··· + fm,

where each fi is a restricted scope function.

having one fewer variable. Next, we eliminate another variable, say X3, with the resulting
expression reducing to:

max
x1,x2

f1(x1, x2) + e2(x1, x2),

where

e2(x1, x2) = max
x3

[f2(x1, x3) + e1(x2, x3)].

Finally, we deﬁne

e3 = max
x1,x2

f1(x1, x2) + e2(x1, x2).

The result at this point is a number, which is the desired maximum over x1, . . . , x4. While
the naive approach of enumerating all states requires 63 arithmetic operations if all variables
are binary, using variable elimination we only need to perform 23 operations.

The general variable elimination algorithm is described in Figure 4. The inputs to
the algorithm are the functions to be maximized F = {f1, . . . , fm} and an elimination
ordering O on the variables, where O(i) returns the ith variable to be eliminated. As in
the example above, for each variable Xl to be eliminated, we select the relevant functions
e1, . . . , eL, those whose scope contains Xl. These functions are removed from the set F and
j=1 ej. At this point, the scope of the functions in
we introduce a new function e = maxxl
F no longer depends on Xl, that is, Xl has been ‘eliminated’. This procedure is repeated
until all variables have been eliminated. The remaining functions in F thus have empty
scope. The desired maximum is therefore given by the sum of these remaining functions.

(cid:80)L

The computational cost of this algorithm is linear in the number of new “function
values” introduced in the elimination process. More precisely, consider the computation of
a new function e whose scope is Z. To compute this function, we need to compute |Dom[Z]|
diﬀerent values. The cost of the algorithm is linear in the overall number of these values,
introduced throughout the execution. As shown by Dechter (1999), this cost is exponential

417

Guestrin, Koller, Parr & Venkataraman

in the induced width of the cost network, the undirected graph deﬁned over the variables
X1, . . . , Xn, with an edge between Xl and Xm if they appear together in one of the original
functions fj. The complexity of this algorithm is, of course, dependent on the variable
elimination order and the problem structure. Computing the optimal elimination order
is an NP-hard problem (Arnborg, Corneil, & Proskurowski, 1987) and elimination orders
yielding low induced tree width do not exist for some problems. These issues have been
confronted successfully for a large variety of practical problems in the Bayesian network
community, which has beneﬁted from a large variety of good heuristics which have been
developed for the variable elimination ordering problem (Bertele & Brioschi, 1972; Kjaerulﬀ,
1990; Reed, 1992; Becker & Geiger, 2001).

(cid:80)

4.2.2 Factored LP
In this section, we present the centerpiece of our planning algorithms: a new, general
approach for compactly representing exponentially large sets of LP constraints in problems
with factored structure — those where the functions in the constraints can be decomposed
as the sum of restricted scope functions. Consider our original problem of representing
the non-linear constraint in Equation (12) compactly. Recall that we wish to represent
the non-linear constraint φ ≥ maxx
i wi ci(x) − b(x), or equivalently, φ ≥ maxx F w(x),
without generating one constraint for each state as in Equation (11). The new, key insight
is that this non-linear constraint can be implemented using a construction that follows the
structure of variable elimination in cost networks.
Consider any function e used within F (including the original fi’s), and let Z be its scope.
For any assignment z to Z, we introduce variable ue
z, whose value represents ez, into the
linear program. For the initial functions f w
i (z). As
is linear in w, this constraint is linear in the LP variables. Now, consider a new function
f w
i
e introduced into F by eliminating a variable Xl. Let e1, . . . , eL be the functions extracted
from F, and let Z be the scope of the resulting e. We introduce a set of constraints:

i , we include the constraint that ufi

z = f w

z ≥ L(cid:88)

ue

j=1

uej
(z,xl)[Zj ]

∀xl.

(13)

Let en be the last function generated in the elimination, and recall that its scope is empty.
Hence, we have only a single variable uen. We introduce the additional constraint φ ≥ uen.
The complete algorithm, presented in Figure 5, is divided into three parts: First, we
generate equality constraints for functions that depend on the weights wi (basis functions).
In the second part, we add the equality constraints for functions that do not depend on the
weights (target functions). These equality constraints let us abstract away the diﬀerences
between these two types of functions and manage them in a uniﬁed fashion in the third
part of the algorithm. This third part follows a procedure similar to variable elimination
described in Figure 4. However, unlike standard variable elimination where we would in-
j=1 ej, in our factored LP procedure we
troduce a new function e, such that e = maxxl
z. To enforce the deﬁnition of e as the maximum over Xl of
introduce new LP variables ue

(cid:80)L

j=1 ej, we introduce the new LP constraints in Equation (13).

(cid:80)L

Example 4.3 To understand this construction, consider our simple example above, and
assume we want to express the fact that φ ≥ maxx F w(x). We ﬁrst introduce a set of

418

Efficient Solution Algorithms for Factored MDPs

FactoredLP (C, b,O)

// C = {c1, . . . , ck} is the set of basis functions.
// b = {b1, . . . , bm} is the set of target functions.
//O stores the elimination order.

//Return a (polynomial) set of constraints Ω equivalent to φ ≥(cid:80)

(cid:80)

j bj(x),∀x .

i wici(x) +

//Data structure for the constraints in factored LP.
Let Ω = {} .
//Data structure for the intermediate functions generated in variable elimination.
Let F = {} .
//Generate equality constraint to abstract away basis functions.
For each ci ∈ C:

Let Z = Scope[ci].
For each assignment z ∈ Z, create a new LP variable ufi
constraint to Ω:

z = wici(z).
ufi

z and add a

Store new function fi to use in variable elimination step: F = F ∪ {fi}.

//Generate equality constraint to abstract away target functions.

For each bj ∈ b:

Let Z = Scope[bj].
For each assignment z ∈ Z, create a new LP variable ufj
constraint to Ω:

z and add a

ufj
z = bj(z).

(cid:80)
Store new function fj to use in variable elimination step: F = F ∪{fj}.
//Now, F contains all of the functions involved in the LP, our constraints become: φ ≥
ei∈F ei(x),∀x , which we represent compactly using a variable elimination procedure.

For i = 1 to number of variables:

//Select the next variable to be eliminated.
Let l = O(i) ;
//Select the relevant functions.
Let e1, . . . , eL be the functions in F whose scope contains Xl, and let
Zj = Scope[ej].
//Introduce linear constraints for the maximum over current variable Xl.
j=1Zj − {Xl} to represent
Deﬁne a new function e with scope Z = ∪L
maxxl
Add constraints to Ω to enforce maximum: for each assignment z ∈ Z:

(cid:80)L

j=1 ej.

z ≥ L(cid:88)

ue

j=1

uej
(z,xl)[Zj ]

∀xl.

//Update set of functions.

Update the set of functions F = F ∪ {e} \ {e1, . . . , eL}.

//Now, all variables have been eliminated and all functions have empty scope.
Add last constraint to Ω:

Return Ω.

constraints φ ≥(cid:80)

i wici(x) +

Figure 5: Factored LP algorithm for the compact representation of the exponential set of

(cid:88)

ei∈F

φ ≥

ei.

(cid:80)
j bj(x),∀x.

419

Guestrin, Koller, Parr & Venkataraman

variables uf1
x1,x2 for every instantiation of values x1, x2 to the variables X1, X2. Thus, if
X1 and X2 are both binary, we have four such variables. We then introduce a constraint
deﬁning the value of uf1
t,t = 0
and uf1
t,f = w1. We have similar variables and constraints for each fj and each value z in
Zj. Note that each of the constraints is a simple equality constraint involving numerical
constants and perhaps the weight variables w.

x1,x2 appropriately. For example, for our f1 above, we have uf1

Next, we introduce variables for each of the intermediate expressions generated by vari-
able elimination. For example, when eliminating X4, we introduce a set of LP variables
x2,x3; for each of them, we have a set of constraints
ue1
x2,x4 + uf4

x2,x3 ≥ uf3
ue1

x3,x4

one for each value x4 of X4. We have a similar set of constraint for ue2
x1,x3 and ue1
uf2

x2,x3. Note that each constraint is a simple linear inequality.

x1,x2 in terms of

We can now prove that our factored LP construction represents the same constraint as

non-linear constraint in Equation (12):
Theorem 4.4 The constraints generated by the factored LP construction are equivalent to
the non-linear constraint in Equation (12). That is, an assignment to (φ, w) satisﬁes the
factored LP constraints if and only if it satisﬁes the constraint in Equation (12).
Proof: See Appendix A.3.
is Cw − b in the original
(cid:80)
set of constraints. Hence our new set of constraints is equivalent to the original set: φ ≥
i wi ci(x) − b(x) in Equation (12), which in turn is equivalent to the exponential
maxx
i wi ci(x) − b(x),∀x in Equation (11). Thus, we can represent this
exponential set of constraints by a new set of constraints and LP variables. The size of
this new set, as in variable elimination, is exponential only in the induced width of the cost
network, rather than in the total number of variables.

set of constraints φ ≥(cid:80)

Returning to our original formulation, we have that

(cid:80)

j f w
j

In this section, we presented a new, general approach for compactly representing expo-
nentially-large sets of LP constraints in problems with factored structure. In the remainder
of this paper, we exploit this construction to design eﬃcient planning algorithms for factored
MDPs.

4.2.3 Factored Max-norm Projection
We can now use our procedure for representing the exponential number of constraints in
Equation (11) compactly to compute eﬃcient max-norm projections, as in Equation (4):

w∗ ∈ arg min

(cid:107)Cw − b(cid:107)∞ .

w

of constraints in this LP: φ ≥ (cid:80)k

j=1 cijwj − bi,∀i and φ ≥ bi −(cid:80)k

The max-norm projection is computed by the linear program in (5). There are two sets
j=1 cijwj,∀i. Each of
these sets is an instance of the constraints in Equation (11), which we have just addressed
in the previous section. Thus, if each of the k basis functions in C is a restricted scope
function and the target function b is the sum of restricted scope functions, then we can
use our factored LP technique to represent the constraints in the max-norm projection LP
compactly. The correctness of our algorithm is a corollary of Theorem 4.4:

420

Efficient Solution Algorithms for Factored MDPs

Corollary 4.5 The solution (φ∗, w∗) of a linear program that minimizes φ subject to the
constraints in FactoredLP(C, −b,O) and FactoredLP(−C, b,O), for any elimination
order O satisﬁes:

w∗ ∈ arg min

w

(cid:107)Cw − b(cid:107)∞ ,

and

φ∗ = min

w

(cid:107)Cw − b(cid:107)∞ .

The original max-norm projection LP had k + 1 variables and two constraints for each
state x; thus, the number of constraints is exponential in the number of state variables.
On the other hand, our new factored max-norm projection LP has more variables, but
exponentially fewer constraints. The number of variables and constraints in the new factored
LP is exponential only in the number of state variables in the largest factor in the cost
network, rather than exponential in the total number of state variables. As we show in
Section 9, this exponential gain allows us to compute max-norm projections eﬃciently when
solving very large factored MDPs.

5. Approximate Linear Programming

We begin with the simplest of our approximate MDP solution algorithms, based on the
approximate linear programming formulation in Section 3.3. Using the basic operations
described in Section 4, we can formulate an algorithm that is both simple and eﬃcient.

(cid:80)

5.1 The Algorithm
As discussed in Section 3.3, approximate linear program formulation is based on the linear
programming approach to solving MDPs presented in Section 3.3. However, in this ap-
proximate version, we restrict the space of value functions to the linear space deﬁned by
our basis functions. More precisely, in this approximate LP formulation, the variables are
w1, . . . , wk — the weights for our basis functions. The LP is given by:

(cid:80)
(cid:80)
x α(x)
i wi hi(x) ≥ [R(x, a) + γ

i wi hi(x) ;

Variables: w1, . . . , wk ;
Minimize:
Subject to:

(cid:80)
x(cid:48) P (x(cid:48) | x, a)
(cid:80)

(cid:80)
i wi hi(x(cid:48))] ∀x ∈ X,∀a ∈ A.
(14)
In other words, this formulation takes the LP in (7) and substitutes the explicit state value
function with a linear value function representation
i wi hi(x). This transformation from
an exact to an approximate problem formulation has the eﬀect of reducing the number
of free variables in the LP to k (one for each basis function coeﬃcient), but the number
of constraints remains |X| × |A|. In our SysAdmin problem, for example, the number of
constraints in the LP in (14) is (m + 1) · 2m, where m is the number of machines in the
network. However, using our algorithm for representing exponentially large constraint sets
compactly we are able to compute the solution to this approximate linear programming
algorithm in closed form with an exponentially smaller LP, as in Section 4.2.

First, consider the objective function

i wi hi(x) of the LP (14). Naively
representing this objective function requires a summation over a exponentially large state
space. However, we can rewrite the objective and obtain a compact representation. We
ﬁrst reorder the terms:

x α(x)

(cid:80)

(cid:80)

421

Guestrin, Koller, Parr & Venkataraman

FactoredALP (P , R, γ, H, O, α)

//P is the factored transition model.
//R is the set of factored reward functions.
//γ is the discount factor.
//H is the set of basis functions H = {h1, . . . , hk}.
//O stores the elimination order.
//α are the state relevance weights.
//Return the basis function weights w computed by approximate linear programming.

//Cache the backprojections of the basis functions.

For each basis function hi ∈ H; for each action a:

Let ga

i = Backproja(hi).

//Compute factored state relevance weights.
For each basis function hi, compute the factored state relevance weights

αi as in Equation (15) .
//Generate approximate linear programming constraints
Let Ω = {}.
For each action a:

Let Ω = Ω ∪ FactoredLP({γga

1 − h1, . . . , γga

(cid:80)

(cid:80)

k − hk}, Ra,O).
x(cid:48) P (x(cid:48)

(cid:80)

//So far, our constraints guarantee that φ ≥ R(x, a) + γ

i wi hi(x(cid:48)) −
i wi hi(x); to satisfy the approximate linear programming solution in (14) we must add

| x, a)

a ﬁnal constraint.
Let Ω = Ω ∪ {φ = 0}.
//We can now obtain the solution weights by solving an LP.
Let w be the solution of the linear program: minimize

the constraints Ω.

(cid:80)

Return w.

i αiwi, subject to

Figure 6: Factored approximate linear programming algorithm.

422

Efficient Solution Algorithms for Factored MDPs

(cid:88)

x

α(x)

(cid:88)

i

wi hi(x) =

(cid:88)

(cid:88)

wi

i

x

α(x) hi(x).

(cid:80)

Now, consider the state relevance weights α(x) as a distribution over states, so that α(x) > 0
and

x α(x) = 1. As in backprojections, we can now write:

αi =

α(x) hi(x) =

α(ci) hi(ci);

(15)

(cid:88)

x

(cid:88)

ci∈Ci

(cid:80)

where α(ci) represents the marginal of the state relevance weights α over the domain
Dom[Ci] of the basis function hi. For example, if we use uniform state relevance weights as
in our experiments — α(x) = 1|X| — then the marginals become α(ci) = 1|Ci|. Thus, we can
rewrite the objective function as
i wi αi, where each basis weight αi is computed as shown
in Equation (15). If the state relevance weights are represented by marginals, then the cost
of computing each αi depends exponentially on the size of the scope of Ci only, rather than
exponentially on the number of state variables. On the other hand, if the state relevance
weights are represented by arbitrary distributions, we need to obtain the marginals over the
Ci’s, which may not be an eﬃcient computation. Thus, greatest eﬃciency is achieved by
using a compact representation, such as a Bayesian network, for the state relevance weights.
Second, note that the right side of the constraints in the LP (14) correspond to the Qa

functions:

Qa(x) = Ra(x) + γ

Using the eﬃcient backprojection operation in factored MDPs described in Section 4.1 we
can rewrite the Qa functions as:

(cid:88)

i

wi hi(x(cid:48)).

(cid:88)

x(cid:48)

P (x(cid:48) | x, a)
(cid:88)

i

Qa(x) = Ra(x) + γ

wi ga

i (x);

where ga
discussed, if hi has scope restricted to Ci, then ga
i

i is the backprojection of basis function hi through the transition model Pa. As we
is a restricted scope function of Γa(C(cid:48)
i).
i and the basis relevance weights αi. The

We can precompute the backprojections ga

approximate linear programming LP of (14) can be written as:

Variables: w1, . . . , wk ;
Minimize:
Subject to:

(cid:80)
(cid:80)
i αi wi ;
i wi hi(x) ≥ [Ra(x) + γ

(cid:80)

i wi ga

i (x)] ∀x ∈ X,∀a ∈ A.

(16)

Finally, we can rewrite this LP to use constraints of the same form as the one in Equa-

tion (12):

(cid:80)

Variables: w1, . . . , wk ;
Minimize:
Subject to: 0 ≥ maxx {Ra(x) +

i αi wi ;

(cid:80)

i wi [γga

i (x) − hi(x)]} ∀a ∈ A.

(17)

We can now use our factored LP construction in Section 4.2 to represent these non-linear
constraints compactly. Basically, there is one set of factored LP constraints for each action
a. Speciﬁcally, we can write the non-linear constraint in the same form as those in Equa-
tion (12) by expressing the functions C as: ci(x) = hi(x)−γga
i (x). Each ci(x) is a restricted

423

Guestrin, Koller, Parr & Venkataraman

i), which means that ci(x) has scope restricted to Ci ∪ Γa(C(cid:48)

i (x) has scope restricted
scope function; that is, if hi(x) has scope restricted to Ci, then ga
to Γa(C(cid:48)
i). Next, the target
function b becomes the reward function Ra(x) which, by assumption, is factored. Finally,
in the constraint in Equation (12), φ is a free variable. On the other hand, in the LP in (17)
the maximum in the right hand side must be less than zero. This ﬁnal condition can be
achieved by adding a constraint φ = 0. Thus, our algorithm generates a set of factored
LP constraints, one for each action. The total number of constraints and variables in this
new LP is linear in the number of actions |A| and only exponential in the induced width
of each cost network, rather than in the total number of variables. The complete factored
approximate linear programming algorithm is outlined in Figure 6.

5.2 An Example

We now present a complete example of the operations required by the approximate LP algo-
rithm to solve the factored MDP shown in Figure 2(a). Our presentation follows four steps:
problem representation, basis function selection, backprojections and LP construction.

First, we must fully specify the factored MDP model for the
Problem Representation:
problem. The structure of the DBN is shown in Figure 2(b). This structure is maintained
for all action choices. Next, we must deﬁne the transition probabilities for each action.
There are 5 actions in this problem: do nothing, or reboot one of the 4 machines in the
network. The CPDs for these actions are shown in Figure 2(c). Finally, we must deﬁne the
reward function. We decompose the global reward as the sum of 4 local reward functions,
one for each machine, such that there is a reward if the machine is working. Speciﬁcally,
Ri(Xi = true) = 1 and Ri(Xi = false) = 0, breaking symmetry by setting R4(X4 = true) =
2. We use a discount factor of γ = 0.9.

In this simple example, we use ﬁve simple basis functions.
Basis Function Selection:
First, we include the constant function h0 = 1. Next, we add indicators for each machine
which take value 1 if the machine is working: hi(Xi = true) = 1 and hi(Xi = false) = 0.

The ﬁrst algorithmic step is computing the backprojection of the
Backprojections:
basis functions, as deﬁned in Section 4.1. The backprojection of the constant basis is
simple:

0 =
ga

Pa(x(cid:48) | x)h0 ;
Pa(x(cid:48) | x) 1 ;

(cid:88)
(cid:88)

x(cid:48)

=

x(cid:48)
= 1 .

Next, we must backproject our indicator basis functions hi:

(cid:88)
Pa(x(cid:48) | x)hi(x(cid:48)
(cid:88)
Pa(x(cid:48)

(cid:89)

x(cid:48)

x(cid:48)
1,x(cid:48)

2,x(cid:48)

3,x(cid:48)

4

i =
ga

=

i) ;
j | xj−1, xj)hi(x(cid:48)

i) ;

j

424

Efficient Solution Algorithms for Factored MDPs

(cid:88)
(cid:88)

x(cid:48)

i

x(cid:48)

i

=

=

= Pa(X(cid:48)
= Pa(X(cid:48)

x(cid:48)[X(cid:48)−{X(cid:48)
i}]

Pa(x(cid:48)

i | xi−1, xi)hi(x(cid:48)
i)
i | xi−1, xi)hi(x(cid:48)

i) ;

Pa(x(cid:48)
i = true | xi−1, xi) 1 + Pa(X(cid:48)
i = true | xi−1, xi) .

(cid:88)

(cid:89)

j(cid:54)=i

Pa(x(cid:48)

j | xj−1, xj) ;

i = false | xi−1, xi) 0 ;

is a restricted scope function of {Xi−1, Xi}. We can now use the CPDs in Fig-

Thus, ga
i
ure 2(c) to specify ga
i :

greboot = i
i

(Xi−1, Xi) =

greboot (cid:54)= i

i

(Xi−1, Xi) =

Xi−1 = true
Xi−1 = false

Xi−1 = true
Xi−1 = false

1
1

0.9
0.5

1
1

0.09
0.05

Xi = true Xi = false

Xi = true Xi = false

To illustrate the factored LPs constructed by our algorithms, we
LP Construction:
deﬁne the constraints for the approximate linear programming approach presented above.
i − hi, as shown in Equation (17). In our example,
First, we deﬁne the functions ca
0 = γ − 1 = −0.1 for the constant basis, and for the indicator bases:
these functions are ca

i = γga

;

.

;

.

creboot = i
i

(Xi−1, Xi) =

Xi−1 = true
Xi−1 = false

creboot (cid:54)= i

i

(Xi−1, Xi) =

Xi = true Xi = false

−0.1
−0.1

0.9
0.9

Xi = true Xi = false
−0.19
−0.55

0.081
0.045

Xi−1 = true
Xi−1 = false

(cid:88)

(cid:88)

x

i

j

Using this deﬁnition of ca

i , the approximate linear programming constraints are given by:
(18)

0 ≥ max

, ∀a .

Ri +

wjca
j

We present the LP construction for one of the 5 actions: reboot = 1. Analogous constructions
can be made for the other actions.

In the ﬁrst set of constraints, we abstract away the diﬀerence between rewards and basis
functions by introducing LP variables u and equality constraints. We begin with the reward
functions:

x1 = 1 , uR1
uR1
x3 = 1 , uR3
uR3

¯x1 = 0 ;
¯x3 = 0 ;

x2 = 1 , uR2
uR2
x4 = 2 , uR4
uR4

¯x2 = 0 ;
¯x4 = 0 .

We now represent the equality constraints for the ca
j functions for the reboot = 1 action. Note
that the appropriate basis function weight from Equation (18) appears in these constraints:

425

Guestrin, Koller, Parr & Venkataraman

uc0 = −0.1 w0 ;
x1,x4 = −0.1 w1 ,
x1,¯x4 = −0.1 w1 ,
uc1
uc1
uc1
¯x1,x4 = 0.9 w1 ,
¯x1,¯x4 = 0.9 w1 ;
uc1
x1,x2 = −0.19 w2 , uc2
¯x1,x2 = −0.55 w2 , uc2
x1,¯x2 = 0.081 w2 , uc2
¯x1,¯x2 = 0.045 w2 ;
uc2
¯x2,x3 = −0.55 w3 , uc3
x2,x3 = −0.19 w3 , uc3
x2,¯x3 = 0.081 w3 , uc3
¯x2,¯x3 = 0.045 w3 ;
uc3
¯x3,x4 = −0.55 w4 , uc4
x3,x4 = −0.19 w4 , uc4
x3,¯x4 = 0.081 w4 , uc4
¯x3,¯x4 = 0.045 w4 .
uc4

Using these new LP variables, our LP constraint from Equation (18) for the reboot = 1 action
becomes:

0 ≥

max

X1,X2,X3,X4

uRi
Xi

+ uc0 +

ucj
Xj−1,Xj

.

i=1

j=1

We are now ready for the variable elimination process. We illustrate the elimination of
variable X4:

0 ≥ max

X1,X2,X3

uRi
Xi

+ uc0 +

ucj
Xj−1,Xj

+ max
X4

uR4
X4

+ uc1

X1,X4

+ uc4

X3,X4

.

(cid:105)

3(cid:88)

i=1

4(cid:88)

3(cid:88)

j=2

(cid:104)

4(cid:88)

(cid:104)

(cid:105)

We can represent the term maxX4
one for each assignment of X1 and X3, using the new LP variables ue1
maximum:

+ uc4

+ uc1

uR4
X4

X1,X4

X3,X4

by a set of linear constraints,
to represent this

X1,X3

x1,x3 ≥ uR4
ue1
x1,x3 ≥ uR4
ue1
¯x1,x3 ≥ uR4
ue1
¯x1,x3 ≥ uR4
ue1
x1,¯x3 ≥ uR4
ue1
x1,¯x3 ≥ uR4
ue1
¯x1,¯x3 ≥ uR4
ue1
¯x1,¯x3 ≥ uR4
ue1

x4 + uc1
¯x4 + uc1
x4 + uc1
¯x4 + uc1
x4 + uc1
¯x4 + uc1
x4 + uc1
¯x4 + uc1

x1,x4 + uc4
x1,¯x4 + uc4
¯x1,x4 + uc4
¯x1,¯x4 + uc4
x1,x4 + uc4
x1,¯x4 + uc4
¯x1,x4 + uc4
¯x1,¯x4 + uc4

x3,x4 ;
x3,¯x4 ;
x3,x4 ;
x3,¯x4 ;
¯x3,x4 ;
¯x3,¯x4 ;
¯x3,x4 ;
¯x3,¯x4 .

We have now eliminated variable X4 and our global non-linear constraint becomes:

3(cid:88)

3(cid:88)

0 ≥ max

X1,X2,X3

uRi
Xi

+ uc0 +

ucj
Xj−1,Xj

+ ue1

X1,X3

.

i=1

j=2

Next, we eliminate variable X3. The new LP constraints and variables have the form:

ue2
X1,X2

+ uc3

X2,X3

+ ue1

X1,X3

, ∀ X1, X2, X3 ;

thus, removing X3 from the global non-linear constraint:

X3

≥ uR3
2(cid:88)

0 ≥ max

X1,X2

uRi
Xi

+ uc0 + uc2

X1,X2

+ ue2

X1,X2

.

i=1

426

Efficient Solution Algorithms for Factored MDPs

Figure 7: Number of constraints in the LP generated by the explicit state representation
versus the factored LP construction for the solution of the ring problem with
basis functions over single variables and approximate linear programming as the
solution algorithm.

We can now eliminate X2, generating the linear constraints:

ue3
X1

≥ uR2

X2

+ uc2

X1,X2

+ ue2

X1,X2

, ∀ X1, X2 .

Now, our global non-linear constraint involves only X1:
+ uc0 + ue3
X1

0 ≥ max

uR1
X1

X1

.

As X1 is the last variable to be eliminated, the scope of the new LP variable is empty and
the linear constraints are given by:

ue4 ≥ uR1

X1

+ ue3
X1

, ∀ X1 .

All of the state variables have now been eliminated, turning our global non-linear constraint
into a simple linear constraint:

0 ≥ uc0 + ue4 ,

which completes the LP description for the approximate linear programming solution to
the problem in Figure 2.

In this small example with only four state variables, our factored LP technique generates
a total of 89 equality constraints, 115 inequality constraints and 149 LP variables, while
the explicit state representation in Equation (8) generates only 80 inequality constraints
and 5 LP variables. However, as the problem size increases, the number of constraints and
LP variables in our factored LP approach grow as O(n2), while the explicit state approach
grows exponentially, at O(n2n). This scaling eﬀect is illustrated in Figure 7.

6. Approximate Policy Iteration with Max-norm Projection

The factored approximate linear programming approach described in the previous section
is both elegant and easy to implement. However, we cannot, in general, provide strong

427

0500001000001500002000002500000246810121416Number of machines in ringNumber of LP constraintsExplicit LPFactored LP# factored constraints = 12n  + 5n - 82# explicit constraints = (n+1) 2 nGuestrin, Koller, Parr & Venkataraman

guarantees about the error it achieves. An alternative is to use the approximate policy
iteration described in Section 3.2, which does oﬀer certain bounds on the error. However,
as we shall see, this algorithm is signiﬁcantly more complicated, and requires that we place
additional restrictions on the factored MDP.

In particular, approximate policy iteration requires a representation of the policy at each
iteration. In order to obtain a compact policy representation, we must make an additional
assumption: each action only aﬀects a small number of state variables. We ﬁrst state this
assumption formally. Then, we show how to obtain a compact representation of the greedy
policy with respect to a factored value function, under this assumption. Finally, we describe
our factored approximate policy iteration algorithm using max-norm projections.

6.1 Default Action Model
In Section 2.2, we presented the factored MDP model, where each action is associated with
its own factored transition model represented as a DBN and with its own factored reward
function. However, diﬀerent actions often have very similar transition dynamics, only dif-
fering in their eﬀect on some small set of variables. In particular, in many cases a variable
has a default evolution model, which only changes if an action aﬀects it directly (Boutilier
et al., 2000).

This type of structure turns out to be useful for compactly representing policies, a prop-
erty which is important in our approximate policy iteration algorithm. Thus, in this section
of the paper, we restrict attention to factored MDPs that are deﬁned using a default transi-
tion model τd = (cid:104)Gd, Pd(cid:105) (Koller & Parr, 2000). For each action a, we deﬁne Eﬀects[a] ⊆ X(cid:48)
to be the variables in the next state whose local probability model is diﬀerent from τd, i.e.,
those variables X(cid:48)
Example 6.1 In our system administrator example, we have an action ai for rebooting
each one of the machines, and a default action d for doing nothing. The transition model
described above corresponds to the “do nothing” action, which is also the default transition
model. The transition model for ai is diﬀerent from d only in the transition model for the
variable X(cid:48)
i = true with probability one, regardless of the status of the
neighboring machines. Thus, in this example, Eﬀects[ai] = X(cid:48)
i.

i, which is now X(cid:48)

i such that Pa(X(cid:48)

i)).

i | Parentsa(X(cid:48)

i)) (cid:54)= Pd(X(cid:48)

i | Parentsd(X(cid:48)

(cid:80)r
(cid:80)r

As in the transition dynamics, we can also deﬁne the notion of default reward model. In
i=1 Ri(Ui) associated with the default action
this case, there is a set of reward functions
d. In addition, each action a can have a reward function Ra(Ua). Here, the extra reward of
i ⊂ {X1, . . . , Xn}. Thus, the total reward
action a has scope restricted to Rewards[a] = Ua
associated with action a is given by Ra +
i=1 Ri. Note that Ra can also be factored as a
linear combination of smaller terms for an even more compact representation.

We can now build on this additional assumption to deﬁne the complete algorithm.
Recall that the approximate policy iteration algorithm iterates through two steps: policy
improvement and approximate value determination. We now discuss each of these steps.

6.2 Computing Greedy Policies
The policy improvement step computes the greedy policy relative to a value function V (t−1):

π(t) = Greedy(V (t−1)).

428

Efficient Solution Algorithms for Factored MDPs

Recall that our value function estimates have the linear form Hw. As we described in
Section 4.1, the greedy policy for this type of value function is given by:

Greedy(Hw)(x) = arg max

a

Qa(x),

(cid:80)

where each Qa can be represented by: Qa(x) = R(x, a) +

i wi ga

i (x).

If we attempt to represent this policy naively, we are again faced with the problem
of exponentially large state spaces. Fortunately, as shown by Koller and Parr (2000), the
greedy policy relative to a factored value function has the form of a decision list. More
precisely, the policy can be written in the form (cid:104)t1, a1(cid:105),(cid:104)t2, a2(cid:105), . . . ,(cid:104)tL, aL(cid:105), where each ti
is an assignment of values to some small subset Ti of variables, and each ai is an action.
The greedy action to take in state x is the action aj corresponding to the ﬁrst event tj in
the list with which x is consistent. For completeness, we now review the construction of
this decision-list policy.

The critical assumption that allows us to represent the policy as a compact decision list
is the default action assumption described in Section 6.1. Under this assumption, the Qa
functions can be written as:

r(cid:88)

(cid:88)

Qa(x) = Ra(x) +

Ri(x) +

wi ga

i (x),

i=1

i

(cid:80)r

(cid:80)

where Ra has scope restricted to Ua. The Q function for the default action d is just:
Qd(x) =

i=1 Ri(x) +

i wi gd

i (x).

is equal to gd

i for most i. Intuitively, a component ga

We now have a set of linear Q-functions which implicitly describes a policy π.

It is
not immediately obvious that these Q functions result in a compactly expressible policy.
An important insight is that most of the components in the weighted combination are
identical, so that ga
i corresponding
i
to the backprojection of basis function hi(Ci) is only diﬀerent if the action a inﬂuences
one of the variables in Ci. More formally, assume that Eﬀects[a] ∩ Ci = ∅. In this case,
all of the variables in Ci have the same transition model in τa and τd. Thus, we have
that ga
i (x); in other words, the ith component of the Qa function is irrelevant
when deciding whether action a is better than the default action d. We can deﬁne which
components are actually relevant: let Ia be the set of indices i such that Eﬀects[a]∩ Ci (cid:54)= ∅.
These are the indices of those basis functions whose backprojection diﬀers in Pa and Pd.
In our example DBN of Figure 2, actions and basis functions involve single variables, so
Iai = i.

i (x) = gd

Let us now consider the impact of taking action a over the default action d. We can

deﬁne the impact — the diﬀerence in value — as:
(cid:88)
δa(x) = Qa(x) − Qd(x);
wi

= Ra(x) +

i∈Ia

(cid:104)

(cid:105)

i (x)

.

This analysis shows that δa(x) is a function whose scope is restricted to

i (x) − gd
ga
(cid:164)

i)

.

Ta = Ua ∪(cid:163)∪i∈IaΓa(C(cid:48)

429

(19)

(20)

Guestrin, Koller, Parr & Venkataraman

DecisionListPolicy (Qa)

//Qa is the set of Q-functions, one for each action;
//Return the decision list policy ∆.

//Initialize decision list.
Let ∆ = {}.
//Compute the bonus functions.
For each action a, other than the default action d:

Compute the bonus for taking action a,

δa(x) = Qa(x) − Qd(x);

as in Equation (19). Note that δa has scope restricted to Ta, as in
Equation (20).
For each assignment t ∈ Ta:

//Add states with positive bonuses to the (unsorted) decision list.

If δa(t) > 0, add branch to decision list:

∆ = ∆ ∪ {(cid:104)t, a, δa(t)(cid:105)}.

//Add the default action to the (unsorted) decision list.
Let ∆ = ∆ ∪ {(cid:104)∅, d, 0(cid:105)}.
//Sort decision list to obtain ﬁnal policy.
Sort the decision list ∆ in decreasing order on the δ element of (cid:104)t, a, δ(cid:105).
Return ∆.

Figure 8: Method for computing the decision list policy ∆ from the factored representation

of the Qa functions.

In our example DBN, Ta2 = {X1, X2}.

Intuitively, we now have a situation where we have a “baseline” value function Qd(x)
which deﬁnes a value for each state x. Each action a changes that baseline by adding or
subtracting an amount from each state. The point is that this amount depends only on Ta,
so that it is the same for all states in which the variables in Ta take the same values.
We can now deﬁne the greedy policy relative to our Q functions. For each action a, deﬁne
a set of conditionals (cid:104)t, a, δ(cid:105), where each t is some assignment of values to the variables Ta,
and δ is δa(t). Now, sort the conditionals for all of the actions by order of decreasing δ:

(cid:104)t1, a1, δ1(cid:105),(cid:104)t2, a2, δ2(cid:105), . . . ,(cid:104)tL, aL, δL(cid:105).

Consider our optimal action in a state x. We would like to get the largest possible “bonus”
over the default value. If x is consistent with t1, we should clearly take action a1, as it
gives us bonus δ1.
If not, then we should try to get δ2; thus, we should check if x is
consistent with t2, and if so, take a2. Using this procedure, we can compute the decision-
list policy associated with our linear estimate of the value function. The complete algorithm
for computing the decision list policy is summarized in Figure 8.
a |Dom(Ta)|; Ta, in turn, depends
on the set of basis function clusters that intersect with the eﬀects of a. Thus, the size
of the policy depends in a natural way on the interaction between the structure of our

Note that the number of conditionals in the list is

(cid:80)

430

Efficient Solution Algorithms for Factored MDPs

process description and the structure of our basis functions. In problems where the actions
modify a large number of variables, the policy representation could become unwieldy. The
approximate linear programming approach in Section 5 is more appropriate in such cases,
as it does not require an explicit representation of the policy.

6.3 Value Determination
In the approximate value determination step our algorithm computes:
(cid:107)Hw − (Rπ(t) + γPπ(t)Hw)(cid:107)∞ .

w(t) = arg min
w

By rearranging the expression, we get:

w(t) = arg min
w

(cid:107)(H − γPπ(t)H) w − Rπ(t)(cid:107)∞ .

This equation is an instance of the optimization in Equation (4). If Pπ(t) is factored, we can
conclude that C = (H − γPπ(t)H) is also a matrix whose columns correspond to restricted-
scope functions. More speciﬁcally:

ci(x) = hi(x) − γgπ(t)

i

(x),

i

where gπ(t)
is the backprojection of the basis function hi through the transition model Pπ(t),
as described in Section 4.1. The target b = Rπ(t) corresponds to the reward function, which
for the moment is assumed to be factored. Thus, we can again apply our factored LP in
Section 4.2.3 to estimate the value of the policy π(t).

Unfortunately, the transition model Pπ(t) is not factored, as a decision list representa-
tion for the policy π(t) will, in general, induce a transition model Pπ(t) which cannot be
represented by a compact DBN. Nonetheless, we can still generate a compact LP by ex-
ploiting the decision list structure of the policy. The basic idea is to introduce cost networks
corresponding to each branch in the decision list, ensuring, additionally, that only states
consistent with this branch are considered in the cost network maximization. Speciﬁcally,
we have a factored LP construction for each branch (cid:104)ti, ai(cid:105). The ith cost network only
considers a subset of the states that is consistent with the ith branch of the decision list.
Let Si be the set of states x such that ti is the ﬁrst event in the decision list for which x
is consistent. That is, for each state x ∈ Si, x is consistent with ti, but it is not consistent
with any tj with j < i.

imply that φ ≥ (cid:80)
i wi ci(x) − b(x) for each state x.
(cid:80)r

Recall that, as in Equation (11), our LP construction deﬁnes a set of constraints that
Instead, we have a separate set of
constraints for the states in each subset Si. For each state in Si, we know that action ai is
taken. Hence, we can apply our construction above using Pai — a transition model which is
factored by assumption — in place of the non-factored Pπ(t). Similarly, the reward function
becomes Rai(x) +

i=1 Ri(x) for this subset of states.

The only issue is to guarantee that the cost network constraints derived from this tran-
sition model are applied only to states in Si. Speciﬁcally, we must guarantee that they are
applied only to states consistent with ti, but not to states that are consistent with some
tj for j < i. To guarantee the ﬁrst condition, we simply instantiate the variables in Ti to
take the values speciﬁed in ti. That is, our cost network now considers only the variables in

431

Guestrin, Koller, Parr & Venkataraman

FactoredAPI (P , R, γ, H, O, ε, tmax)

//P is the factored transition model.
//R is the set of factored reward functions.
//γ is the discount factor.
//H is the set of basis functions H = {h1, . . . , hk}.
//O stores the elimination order.
//ε Bellman error precision.
//tmax maximum number of iterations.
//Return the basis function weights w computed by approximate policy iteration.

//Initialize weights
Let w(0) = 0.
//Cache the backprojections of the basis functions.
For each basis function hi ∈ H; for each action a:

Let ga

i = Backproja(hi).

//Main approximate policy iteration loop.
Let t = 0.
Repeat

//Policy improvement part of the loop.

(cid:80)

//Compute decision list policy for iteration t weights.
i w(t)
Let ∆(t) = DecisionListPolicy(Ra + γ

i ga

i ).

//Value determination part of the loop.

//Initialize constraints for max-norm projection LP.
Let Ω+ = {} and Ω− = {}.
//Initialize indicators.
Let I = {}.
//For every branch of the decision list policy, generate the relevant set of constraints, and

update the indicators to constraint the state space for future branches.

1 , . . . , hk − γgaj

For each branch (cid:104)tj, aj(cid:105) in the decision list policy ∆(t):
//Instantiate the variables in Tj to the assignment given in tj.
Instantiate the set of functions {h1 − γgaj
partial state assignment tj and store in C.

k } with the
Instantiate the target functions Raj with the partial state assign-
ment tj and store in b.
Instantiate the indicator functions I with the partial state as-
signment tj and store in I(cid:48).
//Generate the factored LP constraints for the current decision list branch.
Let Ω+ = Ω+ ∪ FactoredLP(C,−b + I(cid:48),O).
Let Ω− = Ω− ∪ FactoredLP(−C, b + I(cid:48),O).
//Update the indicator functions.
Let Ij(x) = −∞1(x = tj) and update the indicators I = I ∪ Ij.

//We can now obtain the new set of weights by solving an LP, which corresponds to the

max-norm projection.
Let w(t+1) be the solution of the linear program: minimize φ, subject
to the constraints {Ω+, Ω−}.
Let t = t + 1.

Until BellmanErr(Hw(t)) ≤ ε or t ≥ tmax or w(t−1) = w(t).
Return w(t).

Figure 9: Factored approximate policy iteration with max-norm projection algorithm.

432

Efficient Solution Algorithms for Factored MDPs

{X1, . . . , Xn}−Ti, and computes the maximum only over the states consistent with Ti = ti.
To guarantee the second condition, we ensure that we do not impose any constraints on
states associated with previous decisions. This is achieved by adding indicators Ij for each
previous decision tj, with weight −∞. More speciﬁcally, Ij is a function that takes value
−∞ for states consistent with tj and zero for other all assignments of Tj. The constraints
for the ith branch will be of the form:

(cid:88)

(cid:88)

φ ≥ R(x, ai) +

wl (γgl(x, ai) − h(x)) +

−∞1(x = tj),

∀x ∼ [ti],

(21)

l

j<i

where x ∼ [ti] deﬁnes the assignments of X consistent with ti. The introduction of these
indicators causes the constraints associated with ti to be trivially satisﬁed by states in Sj
for j < i. Note that each of these indicators is a restricted-scope function of Tj and can
be handled in the same fashion as all other terms in the factored LP. Thus, for a decision
list of size L, our factored LP contains constraints from 2L cost networks. The complete
approximate policy iteration with max-norm projection algorithm is outlined in Figure 9.

6.4 Comparisons
It is instructive to compare our max-norm policy iteration algorithm to the L2-projection
policy iteration algorithm of Koller and Parr (2000) in terms of computational costs per
iteration and implementation complexity. Computing the L2 projection requires (among
other things) a series of dot product operations between basis functions and backprojected
basis functions (cid:104)hi•gπ
j (cid:105). These expressions are easy to compute if Pπ refers to the transition
model of a particular action a. However, if the policy π is represented as a decision list, as is
the result of the policy improvement step, then this step becomes much more complicated.
In particular, for every branch of the decision list, for every pair of basis functions i and j,
and for each assignment to the variables in Scope[hi] ∪ Scope[ga
j ], it requires the solution of
a counting problem which is (cid:93)P -complete in general. Although Koller and Parr show that
this computation can be performed using a Bayesian network (BN) inference, the algorithm
still requires a BN inference for each one of those assignments at each branch of the decision
list. This makes the algorithm very diﬃcult to implement eﬃciently in practice.

The max-norm projection, on the other hand, relies on solving a linear program at every
iteration. The size of the linear program depends on the cost networks generated. As we
discuss, two cost networks are needed for each point in the decision list. The complexity
of each of these cost networks is approximately the same as only one of the BN inferences
in the counting problem for the L2 projection. Overall, for each branch in the decision
list, we have a total of two of these “inferences,” as opposed to one for each assignment of
Scope[hi] ∪ Scope[ga
j ] for every pair of basis functions i and j. Thus, the max-norm policy
iteration algorithm is substantially less complex computationally than the approach based
on L2-projection. Furthermore, the use of linear programming allows us to rely on existing
LP packages (such as CPLEX), which are very highly optimized.

It is also interesting to compare the approximate policy iteration algorithm to the ap-
proximate linear programming algorithm we presented in Section 5. In the approximate
linear programming algorithm, we never need to compute the decision list policy. The
policy is always represented implicitly by the Qa functions. Thus, this algorithm does not

433

Guestrin, Koller, Parr & Venkataraman

require explicit computation or manipulation of the greedy policy. This diﬀerence has two
important consequences: one computational and the other in terms of generality.

First, not having to compute or consider the decision lists makes approximate linear
programming faster and easier to implement. In this algorithm, we generate a single LP
with one cost network for each action and never need to compute a decision list policy. On
the other hand, in each iteration, approximate policy iteration needs to generate two LPs
for every branch of the decision list of size L, which is usually signiﬁcantly longer than |A|,
with a total of 2L cost networks. In terms of representation, we do not require the policies
to be compact; thus, we do not need to make the default action assumption. Therefore, the
approximate linear programming algorithm can deal with a more general class of problems,
where each action can have its own independent DBN transition model. On the other hand,
as described in Section 3.2, approximate policy iteration has stronger guarantees in terms
of error bounds. These diﬀerences will be highlighted further in our experimental results
presented in Section 9.

7. Computing Bounds on Policy Quality

are the resulting basis function weights. In practice, the agent will deﬁne its behavior by

We have presented two algorithms for computing approximate solutions to factored MDPs.

In Section 3, we showed some a priori bounds for the quality of the policy. Another
possible procedure is to compute an a posteriori bound. That is, given our resulting weights

All these algorithms generate linear value functions which can be denoted by H(cid:98)w, where (cid:98)w
acting according to the greedy policy (cid:98)π = Greedy(H(cid:98)w). One issue that remains is how this
policy (cid:98)π compares to the true optimal policy π∗; that is, how the actual value V(cid:98)π of policy
(cid:98)π compares to V∗.
(cid:98)w, we compute a bound on the loss of acting according to the greedy policy (cid:98)π rather than
the optimal policy. This can be achieved by using the Bellman error analysis of Williams
and Baird (1993).
policy (cid:98)π = Greedy(V), their analysis provides the bound:
The Bellman error is deﬁned as BellmanErr(V) = (cid:107)T ∗V − V(cid:107)∞. Given the greedy
(cid:176)(cid:176)∞ ≤ 2γBellmanErr(V)

(cid:176)(cid:176)V∗ − V(cid:98)π

(22)

1 − γ

.

Thus, we can use the Bellman error BellmanErr(H(cid:98)w) to evaluate the quality of our resulting

greedy policy.

Note that computing the Bellman error involves a maximization over the state space.
Thus, the complexity of this computation grows exponentially with the number of state
variables. Koller and Parr (2000) suggested that structure in the factored MDP can be
exploited to compute the Bellman error eﬃciently. Here, we show how this error bound can
be computed by a set of cost networks using a similar construction to the one in our max-

norm projection algorithms. This technique can be used for any (cid:98)π that can be represented
For some set of weights (cid:98)w, the Bellman error is given by:

as a decision list and does not depend on the algorithm used to determine the policy. Thus,
we can apply this technique to solutions determined approximate linear programming if the
action descriptions permit a decision list representation of the policy.

434

Efficient Solution Algorithms for Factored MDPs

FactoredBellmanErr (P , R, γ, H, O, (cid:98)w)

//P is the factored transition model.
//R is the set of factored reward functions.
//γ is the discount factor.
//H is the set of basis functions H = {h1, . . . , hk}.
//O stores the elimination order.

//(cid:98)w are the weights for the linear value function.
//Return the Bellman error for the value function H(cid:98)w.
//Compute decision list policy for value function H(cid:98)w.
Let (cid:98)∆ = DecisionListPolicy(Ra + γ
i (cid:98)wiga

For each basis function hi ∈ H; for each action a:

//Cache the backprojections of the basis functions.

i = Backproja(hi).

(cid:80)

Let ga

i ).

//Initialize indicators.
Let I = {}.
//Initialize Bellman error.
Let ε = 0.
//For every branch of the decision list policy, generate the relevant cost networks, solve it with
variable elimination, and update the indicators to constraint the state space for future branches.

For each branch (cid:104)tj, aj(cid:105) in the decision list policy (cid:98)∆:

Instantiate the set of functions {(cid:98)w1(h1−γgaj

partial state assignment tj and store in C.

k )} with the
Instantiate the target functions Raj with the partial state assignment
tj and store in b.
Instantiate the indicator functions I with the partial state assignment
tj and store in I(cid:48).

1 ), . . . ,(cid:98)wk(hk−γgaj

//Instantiate the variables in Tj to the assignment given in tj.

//Use variable elimination to solve ﬁrst cost network, and update Bellman error, if error
for this branch is larger.
Let ε = max (ε, VariableElimination(C − b + I(cid:48),O)).
//Use variable elimination to solve second cost network, and update Bellman error, if error
for this branch is larger.
Let ε = max (ε, VariableElimination(−C + b + I(cid:48),O)).
//Update the indicator functions.
Let Ij(x) = −∞1(x = tj) and update the indicators I = I ∪ Ij.

Return ε.

Figure 10: Algorithm for computing Bellman error for factored value function H(cid:98)w.

435

Guestrin, Koller, Parr & Venkataraman

(cid:195)

BellmanErr(H(cid:98)w) = (cid:107)T ∗H(cid:98)w − H(cid:98)w(cid:107)∞ ;
(cid:80)

(cid:80)
(cid:80)
x(cid:48) P(cid:98)π(x(cid:48) | x)
i wihi(x) − R(cid:98)π(x) − γ
(cid:80)
j wjhj(x(cid:48)) −(cid:80)
(cid:80)
x(cid:48) P(cid:98)π(x(cid:48) | x)
j wjhj(x(cid:48)) ,
i wihi(x)
If the rewards R(cid:98)π and the transition model P(cid:98)π are factored appropriately, then we can
network as described in Section 4.2.1. However, (cid:98)π is a decision list policy and it does not

compute each one of these two maximizations (maxx) using variable elimination in a cost

maxx R(cid:98)π(x) + γ

= max

maxx

(cid:33)

.

induce a factored transition model. Fortunately, as in the approximate policy iteration
algorithm in Section 6, we can exploit the structure in the decision list to perform such
maximization eﬃciently. In particular, as in approximate policy iteration, we will generate
two cost networks for each branch in the decision list. To guarantee that our maximization
is performed only over states where this branch is relevant, we include the same type of
indicator functions, which will force irrelevant states to have a value of −∞, thus guaran-
teeing that at each point of the decision list policy we obtain the corresponding state with
the maximum error. The state with the overall largest Bellman error will be the maximum
over the ones generated for each point the in the decision list policy. The complete factored
algorithm for computing the Bellman error is outlined in Figure 10.

One last interesting note concerns our approximate policy iteration algorithm with max-
norm projection of Section 6.
In all our experiments, this algorithm converged, so that
w(t) = w(t+1) after some iterations. If such convergence occurs, then the objective function
φ(t+1) of the linear program in our last iteration is equal to the Bellman error of the ﬁnal
policy:

Lemma 7.1 If approximate policy iteration with max-norm projection converges, so that
w(t) = w(t+1) for some iteration t, then the max-norm projection error φ(t+1) of the last

iteration is equal to the Bellman error for the ﬁnal value function estimate H(cid:98)w = Hw(t):

BellmanErr(H(cid:98)w) = φ(t+1).

Proof: See Appendix A.4.

Thus, we can bound the loss of acting according to the ﬁnal policy π(t+1) by substituting

φ(t+1) into the Bellman error bound:

Corollary 7.2 If approximate policy iteration with max-norm projection converges after

t iterations to a ﬁnal value function estimate H(cid:98)w associated with a greedy policy (cid:98)π =
Greedy(H(cid:98)w), then the loss of acting according to (cid:98)π instead of the optimal policy π∗ is

bounded by:

(cid:176)(cid:176)V∗ − V(cid:98)π
where V(cid:98)π is the actual value of the policy (cid:98)π.

(cid:176)(cid:176)∞ ≤ 2γφ(t+1)

1 − γ

,

Therefore, when approximate policy iteration converges we can obtain a bound on the
quality of the resulting policy without needing to compute the Bellman error explicitly.

436

Efficient Solution Algorithms for Factored MDPs

8. Exploiting Context-speciﬁc Structure

Thus far, we have presented a suite of algorithms which exploit additive structure in the
reward and basis functions and sparse connectivity in the DBN representing the transition
model. However, there exists another important type of structure that should also be
exploited for eﬃcient decision making: context-speciﬁc independence (CSI). For example,
consider an agent responsible for building and maintaining a house, if the painting task can
only be completed after the plumbing and the electrical wiring have been installed, then
the probability that the painting is done is 0, in all contexts where plumbing or electricity
are not done, independently of the agents action. The representation we have used so far in
this paper would use a table to represent this type of function. This table is exponentially
large in the number of variables in the scope of the function, and ignores the context-speciﬁc
structure inherent in the problem deﬁnition.

Boutilier et al. (Boutilier et al., 1995; Dearden & Boutilier, 1997; Boutilier, Dean, &
Hanks, 1999; Boutilier et al., 2000) have developed a set of algorithms which can exploit CSI
in the transition and reward models to perform eﬃcient (approximate) planning. Although
this approach is often successful in problems where the value function contains suﬃcient
context-speciﬁc structure, the approach is not able to exploit the additive structure which
is also often present in real-world problems.

In this section, we extend the factored MDP model to include context-speciﬁc structure.
We present a simple, yet eﬀective extension of our algorithms which can exploit both CSI
and additive structure to obtain eﬃcient approximations for factored MDPs. We ﬁrst extend
the factored MDP representation to include context-speciﬁc structure and then show how
the basic operations from Section 4 required by our algorithms can be performed eﬃciently
in this new representation.

8.1 Factored MDPs with Context-speciﬁc and Additive Structure
There are several representations for context-speciﬁc functions. The most common are
decision trees (Boutilier et al., 1995), algebraic decision diagrams (ADDs) (Hoey, St-Aubin,
Hu, & Boutilier, 1999), and rules (Zhang & Poole, 1999). We choose to use rules as our
basic representation, for two main reasons. First, the rule-based representation allows a
fairly simple algorithm for variable elimination, which is a key operation in our framework.
Second, rules are not required to be mutually exclusive and exhaustive, a requirement that
can be restrictive if we want to exploit additive independence, where functions can be
represented as a linear combination of a set of non-mutually exclusive functions.

We begin by describing the rule-based representation (along the lines of Zhang and
Poole’s presentation (1999)) for the probabilistic transition model, in particular, the CPDs
of our DBN model. Roughly speaking, each rule corresponds to some set of CPD entries
that are all associated with a particular probability value. These entries with the same
value are referred to as consistent contexts:
Deﬁnition 8.1 Let C ⊆ {X, X(cid:48)} and c ∈ Dom(C). We say that c is consistent with
b ∈ Dom(B), for B ⊆ {X, X(cid:48)}, if c and b have the same assignment for the variables in
C ∩ B.
The probability of these consistent contexts will be represented by probability rules:

437

Guestrin, Koller, Parr & Venkataraman

(a)

(b)

η1 = (cid:104)¬Electrical : 0(cid:105)

η2 = (cid:104)Electrical ∧ ¬ Plumbing : 0(cid:105)
η3 = (cid:104)Electrical ∧ Plumbing : 0.95(cid:105)

(c)

η4 = (cid:104)¬Electrical : 0(cid:105)

η5 = (cid:104)Electrical ∧ ¬Plumbing : 0(cid:105)

η6 = (cid:104)Electrical ∧ Plumbing ∧ ¬Painting : 0(cid:105)
η7 = (cid:104)Electrical ∧ Plumbing ∧ Painting : 0.9(cid:105)

(d)

Figure 11: Example CPDs for variable the Painting’ = true represented as decision trees:
(a) when the action is paint; (b) when the action is not paint. The same CPDs
can be represented by probability rules as shown in (c) and (d), respectively.

Deﬁnition 8.2 A probability rule η = (cid:104)c : p(cid:105) is a function η : {X, X(cid:48)} (cid:55)→ [0, 1], where the
context c ∈ Dom(C) for C ⊆ {X, X(cid:48)} and p ∈ [0, 1], such that η(x, x(cid:48)) = p if (x, x(cid:48)) is
consistent with c and is equal to 1 otherwise.

In this case, it is convenient to require that the rules be mutually exclusive and exhaus-

tive, so that each CPD entry is uniquely deﬁned by its association with a single rule.

Deﬁnition 8.3 A rule-based conditional probability distribution (rule CPD) Pa is a func-
tion Pa : ({X(cid:48)
i} ∪ X) (cid:55)→ [0, 1], composed of a set of probability rules {η1, η2, . . . , ηm} whose
contexts are mutually exclusive and exhaustive. We deﬁne:

where ηj is the unique rule in Pa for which cj is consistent with (x(cid:48)
for all x,

i, x). We require that,

i | x) = ηj(x, x(cid:48)),

Pa(x(cid:48)

i | x) = 1.

Pa(x(cid:48)
(cid:88)

x(cid:48)

i

We can deﬁne Parentsa(X(cid:48)
i) to be the union of the contexts of the rules in Pa(X(cid:48)
example of a CPD represented by a set of probability rules is shown in Figure 11.

i | X). An

Rules can also be used to represent additive functions, such as reward or basis functions.

We represent such context speciﬁc value dependencies using value rules:

438

Electrical Electrical PlumbingPlumbingP(Painting’) = 0Not doneDoneDoneNot doneP(Painting’) = 0P(Painting’) = 0.95Electrical Electrical PlumbingPlumbingP(Painting’) = 0Not doneDonePaintingPaintingDoneDoneNot doneNot doneP(Painting’) = 0P(Painting’) = 0P(Painting’) = 0.9Efficient Solution Algorithms for Factored MDPs

Deﬁnition 8.4 A value rule ρ = (cid:104)c : v(cid:105) is a function ρ : X (cid:55)→ R such that ρ(x) = v when
x is consistent with c and 0 otherwise.
Note that a value rule (cid:104)c : v(cid:105) has a scope C.

It is important to note that value rules are not required to be mutually exclusive and
exhaustive. Each value rule represents a (weighted) indicator function, which takes on a
value v in states consistent with some context c, and 0 in all other states. In any given state,
the values of the zero or more rules consistent with that state are simply added together.

Example 8.5 In our construction example, we might have a set of rules:

ρ1 = (cid:104)Plumbing = done : 100(cid:105);
ρ2 = (cid:104)Electricity = done : 100(cid:105);
ρ3 = (cid:104)Painting = done : 100(cid:105);
ρ4 = (cid:104)Action = plumb : −10(cid:105);

...

which, when summed together, deﬁne the reward function R = ρ1 + ρ2 + ρ3 + ρ4 + ···.

In general, our reward function Ra is represented as a rule-based function:

(cid:80)n

Deﬁnition 8.6 A rule-based function f : X (cid:55)→ R is composed of a set of rules {ρ1, . . . , ρn}
such that f(x) =

i=1 ρi(x).

In the same manner, each one of our basis functions hj is now represented as a rule-based
function.

This notion of a rule-based function is related to the tree-structure functions used by
Boutilier et al. (2000), but is substantially more general. In the tree-structure value func-
tions, the rules corresponding to the diﬀerent leaves are mutually exclusive and exhaustive.
Thus, the total number of diﬀerent values represented in the tree is equal to the number
of leaves (or rules). In the rule-based function representation, the rules are not mutually
exclusive, and their values are added to form the overall function value for diﬀerent settings
of the variables. Diﬀerent rules are added in diﬀerent settings, and, in fact, with k rules,
one can easily generate 2k diﬀerent possible values, as is demonstrated in Section 9. Thus,
the rule-based functions can provide a compact representation for a much richer class of
value functions.

Using this rule-based representation, we can exploit both CSI and additive independence
in the representation of our factored MDP and basis functions. We now show how the basic
operations in Section 4 can be adapted to exploit our rule-based representation.

8.2 Adding, Multiplying and Maximizing Consistent Rules
In our table-based algorithms, we relied on standard sum and product operators applied to
tables. In order to exploit CSI using a rule-based representation, we must redeﬁne these
standard operations. In particular, the algorithms will need to add or multiply rules that
ascribe values to overlapping sets of states.

We will start by deﬁning these operations for rules with the same context:

439

Guestrin, Koller, Parr & Venkataraman

Deﬁnition 8.7 Let ρ1 = (cid:104)c : v1(cid:105) and ρ2 = (cid:104)c : v2(cid:105) be two rules with context c. Deﬁne the
rule product as ρ1 × ρ2 = (cid:104)c : v1 · v2(cid:105), and the rule sum as ρ1 + ρ2 = (cid:104)c : v1 + v2(cid:105).
Note that this deﬁnition is restricted to rules with the same context. We will address this
issue in a moment. First, we will introduce an additional operation which maximizes a
variable from a set of rules, which otherwise share a common context:
Deﬁnition 8.8 Let Y be a variable with Dom[Y ] = {y1, . . . , yk}, and let ρi, for each i =
1, . . . , k, be a rule of the form ρi = (cid:104)c ∧ Y = yi : vi(cid:105). Then for the rule-based function
f = ρ1 + ··· + ρk, deﬁne the rule maximization over Y as maxY f = (cid:104)c : maxi vi(cid:105) .
After this operation, Y has been maximized out from the scope of the function f.

These three operations we have just described can only be applied to sets of rules that
satisfy very stringent conditions. To make our set of rules amenable to the application
of these operations, we might need to reﬁne some of these rules. We therefore deﬁne the
following operation:
Deﬁnition 8.9 Let ρ = (cid:104)c : v(cid:105) be a rule, and Y be a variable. Deﬁne the rule split
Split(ρ(cid:54) Y ) of ρ on a variable Y as follows: If Y ∈ Scope[C], then Split(ρ(cid:54) Y ) = {ρ};
otherwise,

Split(ρ(cid:54) Y ) = {(cid:104)c ∧ Y = yi : v(cid:105) | yi ∈ Dom[Y ]} .

Thus, if we split a rule ρ on variable Y that is not in the scope of the context of ρ, then we
generate a new set of rules, with one for each assignment in the domain of Y .
In general, the purpose of rule splitting is to extend the context c of one rule ρ coincide
with the context c(cid:48) of another consistent rule ρ(cid:48). Naively, we might take all variables in
Scope[C(cid:48)] − Scope[C] and split ρ recursively on each one of them. However, this process
creates unnecessarily many rules: If Y is a variable in Scope[C(cid:48)] − Scope[C] and we split ρ
on Y , then only one of the |Dom[Y ]| new rules generated will remain consistent with ρ(cid:48): the
one which has the same assignment for Y as the one in c(cid:48). Thus, only this consistent rule
needs to be split further. We can now deﬁne the recursive splitting procedure that achieves
this more parsimonious representation:
Deﬁnition 8.10 Let ρ = (cid:104)c : v(cid:105) be a rule, and b be a context such that b ∈ Dom[B].
Deﬁne the recursive rule split Split(ρ(cid:54) b) of ρ on a context b as follows:

1. {ρ}, if c is not consistent with b; else,
2. {ρ}, if Scope[B] ⊆ Scope[C]; else,
3. {Split(ρi(cid:54) b) | ρi ∈ Split(ρ(cid:54) Y )}, for some variable Y ∈ Scope[B] − Scope[C] .

In this deﬁnition, each variable Y ∈ Scope[B] − Scope[C] leads to the generation of k =
|Dom(Y )| rules at the step in which it is split. However, only one of these k rules is used
(cid:80)
in the next recursive step because only one is consistent with b. Therefore, the size of the
Y ∈Scope[B]−Scope[C](|Dom(Y )| − 1). This size is independent of the
split set is simply 1 +
order in which the variables are split within the operation.

440

Efficient Solution Algorithms for Factored MDPs

Note that only one of the rules in Split(ρ(cid:54) b) is consistent with b: the one with context
c ∧ b. Thus, if we want to add two consistent rules ρ1 = (cid:104)c1 : v1(cid:105) and ρ2 = (cid:104)c2 : v2(cid:105), then
all we need to do is replace these rules by the set:

Split(ρ1(cid:54) c2) ∪ Split(ρ2(cid:54) c1),

and then simply replace the resulting rules (cid:104)c1 ∧ c2 : v1(cid:105) and (cid:104)c2 ∧ c1 : v2(cid:105) by their sum
(cid:104)c1 ∧ c2 : v1 + v2(cid:105). Multiplication is performed in an analogous manner.

Example 8.11 Consider adding the following set of consistent rules:

ρ1 = (cid:104)a ∧ b : 5(cid:105),
ρ2 = (cid:104)a ∧ ¬c ∧ d : 3(cid:105).

In these rules, the context c1 of ρ1 is a ∧ b, and the context c2 of ρ2 is a ∧ ¬c ∧ d.

Rules ρ1 and ρ2 are consistent, therefore, we must split them to perform the addition

 (cid:104)a ∧ b ∧ c : 5(cid:105),
(cid:40)

(cid:104)a ∧ b ∧ ¬c ∧ ¬d : 5(cid:105),
(cid:104)a ∧ b ∧ ¬c ∧ d : 5(cid:105).

(cid:104)a ∧ ¬b ∧ ¬c ∧ d : 3(cid:105),
(cid:104)a ∧ b ∧ ¬c ∧ d : 3(cid:105).

operation:

Likewise,

Split(ρ1(cid:54) c2) =

Split(ρ2(cid:54) c1) =

The result of adding rules ρ1 and ρ2 is

(cid:104)a ∧ b ∧ c : 5(cid:105),
(cid:104)a ∧ b ∧ ¬c ∧ ¬d : 5(cid:105),
(cid:104)a ∧ b ∧ ¬c ∧ d : 8(cid:105),
(cid:104)a ∧ ¬b ∧ ¬c ∧ d : 3(cid:105).

8.3 Rule-based One-step Lookahead
Using this compact rule-based representation, we are able to compute a one-step lookahead
plan eﬃciently for models with signiﬁcant context-speciﬁc or additive independence.

As in Section 4.1 for the table-based case, the rule-based Qa function can be represented
as the sum of the reward function and the discounted expected value of the next state.
Due to our linear approximation of the value function, the expectation term is, in turn,
represented as the linear combination of the backprojections of our basis functions. To
exploit CSI, we are representing the rewards and basis functions as rule-based functions.
To represent Qa as a rule-based function, it is suﬃcient for us to show how to represent the
backprojection gj of the basis function hj as a rule-based function.

Each hj is a rule-based function, which can be written as hj(x) =

(x), where
. Each rule is a restricted scope function; thus, we can

i

i ρ(hj )

(cid:80)

has the form

ρ(hj )
: v(hj )
i
simplify the backprojection as:

c(hj )
i

i

(cid:68)

(cid:69)

441

Guestrin, Koller, Parr & Venkataraman

RuleBackproja(ρ) , where ρ is given by (cid:104)c : v(cid:105), with c ∈ Dom[C].

Let g = {}.
Select the set P of relevant probability rules:
i ∈ C and c is consistent with cj}.
P = {ηj ∈ P (X(cid:48)
Remove the X(cid:48) assignments from the context of all rules in P.
// Multiply consistent rules:
While there are two consistent rules η1 = (cid:104)c1 : p1(cid:105) and η2 = (cid:104)c2 : p2(cid:105):

i | Parents(X(cid:48)

i)) | X(cid:48)

If c1 = c2, replace these two rules by (cid:104)c1 : p1p2(cid:105);
Else replace these two rules by the set: Split(η1(cid:54) c2) ∪ Split(η2(cid:54) c1).

// Generate value rules:
For each rule ηi in P:

Return g.

Update the backprojection g = g ∪ {(cid:104)ci : piv(cid:105)}.

Figure 12: Rule-based backprojection.

j (x) =
ga

=

=

=

ρ(hj )
i

(cid:88)

Pa(x(cid:48) | x)hj(x(cid:48)) ;
Pa(x(cid:48) | x)
(cid:88)

Pa(x(cid:48) | x)ρ(hj )
| x);

x(cid:48)
v(hj )
i Pa(c(hj )

i

i

i

(x(cid:48));

(x(cid:48));

x(cid:48)

(cid:88)
(cid:88)
(cid:88)
(cid:88)

x(cid:48)

i

i

where the term v(hj )
projection operation by RuleBackproja(ρ(hj )

i Pa(c(hj )

i

).

i

| x) can be written as a rule function. We denote this back-

The backprojection procedure, described in Figure 12, follows three steps. First, the
relevant rules are selected: In the CPDs for the variables that appear in the context of ρ,
we select the rules consistent with this context, as these are the only rules that play a role
in the backprojection computation. Second, we multiply all consistent probability rules to
form a local set of mutually-exclusive rules. This procedure is analogous to the addition
procedure described in Section 8.2. Now that we have represented the probabilities that
can aﬀect ρ by a mutually-exclusive set, we can simply represent the backprojection of ρ
by the product of these probabilities with the value of ρ. That is, the backprojection of ρ is
a rule-based function with one rule for each one of the mutually-exclusive probability rules
ηi. The context of this new value rule is the same as that of ηi, and the value is the product
of the probability of ηi and the value of ρ.

Example 8.12 For example, consider the backprojection of a simple rule,

ρ = (cid:104) Painting = done : 100(cid:105),

through the CPD in Figure 11(c) for the paint action:

RuleBackprojpaint(ρ) =

(cid:88)

x(cid:48)

Ppaint(x(cid:48) | x)ρ(x(cid:48));

442

Efficient Solution Algorithms for Factored MDPs

(cid:88)

=

Painting(cid:48)

3(cid:89)

Ppaint(Painting

(cid:48) | x)ρ(Painting

(cid:48));

(cid:88)

i

= 100

ηi(Painting’ = done, x) .

i=1

Note that the product of these simple rules is equivalent to the decision tree CPD shown in
Figure 11(a). Hence, this product is equal to 0 in most contexts, for example, when electricity
is not done at time t. The product in non-zero only in one context: in the context associated
with rule η3. Thus, we can express the result of the backprojection operation by a rule-based
function with a single rule:

RuleBackprojpaint(ρ) = (cid:104)Plumbing ∧ Electrical : 95(cid:105).

Similarly, the backprojection of ρ when the action is not paint can also be represented by a
single rule:

RuleBackproj¬paint(ρ) = (cid:104)Plumbing ∧ Electrical ∧ Painting : 90(cid:105).

Using this algorithm, we can now write the backprojection of the rule-based basis func-

tion hj as:

j (x) =
ga

RuleBackproja(ρ(hj )

i

),

(23)

where ga
simplicity of notation, we use ga
jection. Using this notation, we can write Qa(x) = Ra(x) + γ
rule-based function.

j is a sum of rule-based functions, and therefore also a rule-based function. For
j = RuleBackproja(hj) to refer to this deﬁnition of backpro-
j (x), which is again a

j wjga

(cid:80)

8.4 Rule-based Maximization Over the State Space
The second key operation required to extend our planning algorithms to exploit CSI is to
modify the variable elimination algorithm in Section 4.2.1 to handle the rule-based rep-
resentation.
In Section 4.2.1, we showed that the maximization of a linear combination
of table-based functions with restricted scope can be performed eﬃciently using non-serial
dynamic programming (Bertele & Brioschi, 1972), or variable elimination. To exploit struc-
ture in rules, we use an algorithm similar to variable elimination in a Bayesian network with
context-speciﬁc independence (Zhang & Poole, 1999).

Intuitively, the algorithm operates by selecting the value rules relevant to the variable
being maximized in the current iteration. Then, a local maximization is performed over
this subset of the rules, generating a new set of rules without the current variable. The
procedure is then repeated recursively until all variables have been eliminated.

More precisely, our algorithm “eliminates” variables one by one, where the elimina-
tion process performs a maximization step over the variable’s domain. Suppose that we
are eliminating Xi, whose collected value rules lead to a rule function f, and f involves
additional variables in some set B, so that f’s scope is B ∪ {Xi}. We need to compute
the maximum value for Xi for each choice of b ∈ Dom[B]. We use MaxOut (f, Xi) to de-
note a procedure that takes a rule function f(B, Xi) and returns a rule function g(B) such

443

Guestrin, Koller, Parr & Venkataraman

MaxOut (f, B)
Let g = {}.
Add completing rules to f : (cid:104)B = bi : 0(cid:105), i = 1, . . . , k.
// Summing consistent rules:
While there are two consistent rules ρ1 = (cid:104)c1 : v1(cid:105) and ρ2 = (cid:104)c2 : v2(cid:105):

If c1 = c2, then replace these two rules by (cid:104)c1 : v1 + v2(cid:105);
Else replace these two rules by the set: Split(ρ1(cid:54) c2) ∪ Split(ρ2(cid:54) c1).

// Maximizing out variable B:
Repeat until f is empty:

Then remove these rules from f and add rule (cid:104)c : maxi vi(cid:105) to g;

If there are rules (cid:104)c ∧ B = bi : vi(cid:105),∀bi ∈ Dom(B) :
Else select two rules: ρi = (cid:104)ci ∧ B = bi : vi(cid:105) and ρj = (cid:104)cj ∧ B = bj : vj(cid:105)
such that ci is consistent with cj, but not identical, and replace
them with Split(ρi(cid:54) cj) ∪ Split(ρj(cid:54) ci) .

Return g.

Figure 13: Maximizing out variable B from rule function f.

that: g(b) = maxxi f(b, xi). Such a procedure is an extension of the variable elimination
algorithm of Zhang and Poole (Zhang & Poole, 1999).
The rule-based variable elimination algorithm maintains a set F of value rules, initially
containing the set of rules to be maximized. The algorithm then repeats the following steps
for each variable Xi until all variables have been eliminated:

1. Collect all rules which depend on Xi into fi — fi = {(cid:104)c : v(cid:105) ∈ F | Xi ∈ C} — and

remove these rules from F.

2. Perform the local maximization step over Xi: gi = MaxOut (fi, Xi);
3. Add the rules in gi to F; now, Xi has been “eliminated.”
The cost of this algorithm is polynomial in the number of new rules generated in the
maximization operation MaxOut (fi, Xi). The number of rules is never larger and in many
cases exponentially smaller than the complexity bounds on the table-based maximization in
Section 4.2.1, which, in turn, was exponential only in the induced width of the cost network
graph (Dechter, 1999). However, the computational costs involved in managing sets of rules
usually imply that the computational advantage of the rule-based approach over the table-
based one will only be signiﬁcant in problems that possess a fair amount of context-speciﬁc
structure.

In the remainder of this section, we present the algorithm for computing the local
maximization MaxOut (fi, Xi). In the next section, we show how these ideas can be applied
to extending the algorithm in Section 4.2.2 to exploit CSI in the LP representation for
planning in factored MDPs.

The procedure, presented in Figure 13, is divided into two parts: ﬁrst, all consistent
rules are added together as described in Section 8.2; then, variable B is maximized. This
maximization is performed by generating a set of rules, one for each assignment of B, whose
contexts have the same assignment for all variables except for B, as in Deﬁnition 8.8. This
set is then substituted by a single rule without a B assignment in its context and with value
equal to the maximum of the values of the rules in the original set. Note that, to simplify

444

Efficient Solution Algorithms for Factored MDPs

the algorithm, we initially need to add a set of value rules with 0 value, which guarantee
that our rule function f is complete (i.e., there is at least one rule consistent with every
context).

The correctness of this procedure follows directly from the correctness of the rule-based
variable elimination procedure described by Zhang and Poole, merely by replacing summa-
tions with product with max, and products with products with sums. We conclude this
section with a small example to illustrate the algorithm:
Example 8.13 Suppose we are maximizing a for the following set of rules:

ρ1 = (cid:104)¬a : 1(cid:105),
ρ2 = (cid:104)a ∧ ¬b : 2(cid:105),
ρ3 = (cid:104)a ∧ b ∧ ¬c : 3(cid:105),
ρ4 = (cid:104)¬a ∧ b : 1(cid:105).

When we add completing rules, we get:

ρ5 = (cid:104)¬a : 0(cid:105),
ρ6 = (cid:104)a : 0(cid:105).

In the ﬁrst part of the algorithm, we need to add consistent rules: We add ρ5 to ρ1 (which
remains unchanged), combine ρ1 with ρ4, ρ6 with ρ2, and then the split of ρ6 on the context
of ρ3, to get the following inconsistent set of rules:

ρ2 = (cid:104)a ∧ ¬b : 2(cid:105),
ρ3 = (cid:104)a ∧ b ∧ ¬c : 3(cid:105),
ρ7 = (cid:104)¬a ∧ b : 2(cid:105),
ρ8 = (cid:104)¬a ∧ ¬b : 1(cid:105),
ρ9 = (cid:104)a ∧ b ∧ c : 0(cid:105),

(from adding ρ4 to the consistent rule from Split(ρ1(cid:54) b))
(from Split(ρ1(cid:54) b))
(from Split(ρ6(cid:54) a ∧ b ∧ ¬c)).

Note that several rules with value 0 are also generated, but not shown here because they are
added to other rules with consistent contexts. We can move to the second stage (repeat loop)
of MaxOut. We remove ρ2, and ρ8, and maximize a out of them, to give:

ρ10 = (cid:104)¬b : 2(cid:105).

We then select rules ρ3 and ρ7 and split ρ7 on c (ρ3 is split on the empty set and is not
changed),

ρ11 = (cid:104)¬a ∧ b ∧ c : 2(cid:105),
ρ12 = (cid:104)¬a ∧ b ∧ ¬c : 2(cid:105).

Maximizing out a from rules ρ12 and ρ3, we get:

ρ13 = (cid:104)b ∧ ¬c : 3(cid:105).

We are left with ρ11, which maximized over its counterpart ρ9 gives

ρ12 = (cid:104)b ∧ ¬c : 2(cid:105).

Notice that, throughout this maximization, we have not split on the variable C when ¬b ∈ ci,
giving us only 6 distinct rules in the ﬁnal result. This is not possible in a table-based
representation, since our functions would then be over the 3 variables a,b,c, and therefore
must have 8 entries.

445

Guestrin, Koller, Parr & Venkataraman

(cid:80)

constraints of the form: φ ≥(cid:80)

8.5 Rule-based Factored LP
(cid:80)
In Section 4.2.2, we showed that the LPs used in our algorithms have exponentially many
i wi ci(x) − b(x),∀x, which can be substituted by a single,
i wi ci(x)− b(x). We then showed that, using
equivalent, non-linear constraint: φ ≥ maxx
variable elimination, we can represent this non-linear constraint by an equivalent set of
linear constraints in a construction we called the factored LP. The number of constraints in
the factored LP is linear in the size of the largest table generated in the variable elimination
procedure. This table-based algorithm can only exploit additive independence. We now
extend the algorithm in Section 4.2.2 to exploit both additive and context-speciﬁc structure,
by using the rule-based variable elimination described in the previous section.
Suppose we wish to enforce the more general constraint 0 ≥ maxy F w(y), where F w(y) =
j (y) such that each fj is a rule. As in the table-based version, the superscript w means
j f w
that fj might depend on w. Speciﬁcally, if fj comes from basis function hi, it is multiplied
by the weight wi; if fj is a rule from the reward function, it is not.
In our rule-based factored linear program, we generate LP variables associated with
contexts; we call these LP rules. An LP rule has the form (cid:104)c : u(cid:105); it is associated with a
context c and a variable u in the linear program. We begin by transforming all our original
into LP rules as follows: If rule fj has the form (cid:104)cj : vj(cid:105) and comes from basis
rules f w
j
function hi, we introduce an LP rule ej = (cid:104)cj : uj(cid:105) and the equality constraint uj = wivj.
If fj has the same form but comes from a reward function, we introduce an LP rule of the
same form, but the equality constraint becomes uj = vj.

(cid:80)

Now, we have only LP rules and need to represent the constraint: 0 ≥ maxy

j ej(y).
To represent such a constraint, we follow an algorithm very similar to the variable elimina-
tion procedure in Section 8.4. The main diﬀerence occurs in the MaxOut (f, B) operation in
Figure 13. Instead of generating new value rules, we generate new LP rules, with associated
new variables and new constraints. The simplest case occurs when computing a split or
adding two LP rules. For example, when we add two value rules in the original algorithm,
we instead perform the following operation on their associated LP rules: If the LP rules
are (cid:104)c : ui(cid:105) and (cid:104)c : uj(cid:105), we replace these by a new rule (cid:104)c : uk(cid:105), associated with a new LP
variable uk with context c, whose value should be ui + uj. To enforce this value constraint,
we simply add an additional constraint to the LP: uk = ui + uj. A similar procedure can
be followed when computing the split.

More interesting constraints are generated when we perform a maximization.

In the
rule-based variable elimination algorithm in Figure 13, this maximization occurs when we
replace a set of rules:

(cid:104)c ∧ B = bi : vi(cid:105),∀bi ∈ Dom(B),

(cid:191)

(cid:192)

by a new rule

c : max

i

vi

.

Following the same process as in the LP rule summation above, if we are maximizing

ei = (cid:104)c ∧ B = bi : ui(cid:105),∀bi ∈ Dom(B),

we generate a new LP variable uk associated with the rule ek = (cid:104)c : uk(cid:105). However, we
cannot add the nonlinear constraint uk = maxi ui, but we can add a set of equivalent linear

446

Efficient Solution Algorithms for Factored MDPs

constraints

Therefore, using these simple operations, we can exploit structure in the rule functions
to represent the nonlinear constraint en ≥ maxy
j ej(y), where en is the very last LP
rule we generate. A ﬁnal constraint un = φ implies that we are representing exactly the
constraints in Equation (12), without having to enumerate every state.

uk ≥ ui, ∀i.
(cid:80)

The correctness of our rule-based factored LP construction is a corollary of Theorem 4.4
and of the correctness of the rule-based variable elimination algorithm (Zhang & Poole,
1999) .
Corollary 8.14 The constraints generated by the rule-based factored LP construction are
equivalent to the non-linear constraint in Equation (12). That is, an assignment to (φ, w)
satisﬁes the rule-based factored LP constraints if and only if it satisﬁes the constraint in
Equation (12).
The number of variables and constraints in the rule-based factored LP is linear in the
number of rules generated by the variable elimination process. In turn, the number of rules
is no larger, and often exponentially smaller, than the number of entries in the table-based
approach.

To illustrate the generation of LP constraints as just described, we now present a small

example:
Example 8.15 Let e1, e2, e3, and e4 be the set of LP rules which depend on the variable
b being maximized. Here, rule ei is associated with the LP variable ui:

e1 = (cid:104)a ∧ b : u1(cid:105),
e2 = (cid:104)a ∧ b ∧ c : u2(cid:105),
e3 = (cid:104)a ∧ ¬b : u3(cid:105),
e4 = (cid:104)a ∧ b ∧ ¬c : u4(cid:105).

In this set, note that rules e1 and e2 are consistent. We combine them to generate the
following rules:

e5 = (cid:104)a ∧ b ∧ c : u5(cid:105),
e6 = (cid:104)a ∧ b ∧ ¬c : u1(cid:105).

and the constraint u1 + u2 = u5. Similarly, e6 and e4 may be combined, resulting in:

e7 = (cid:104)a ∧ b ∧ ¬c : u6(cid:105).

with the constraint u6 = u1 + u4. Now, we have the following three inconsistent rules for
the maximization:

e3 = (cid:104)a ∧ ¬b : u3(cid:105),
e5 = (cid:104)a ∧ b ∧ c : u5(cid:105),
e7 = (cid:104)a ∧ b ∧ ¬c : u6(cid:105).

Following the maximization procedure, since no pair of rules can be eliminated right away,
we split e3 and e5 to generate the following rules:

e8 = (cid:104)a ∧ ¬b ∧ c : u3(cid:105),
e9 = (cid:104)a ∧ ¬b ∧ ¬c : u3(cid:105),
e5 = (cid:104)a ∧ b ∧ c : u5(cid:105).

447

Guestrin, Koller, Parr & Venkataraman

We can now maximize b out from e8 and e5, resulting in the following rule and constraints
respectively:

e10 = (cid:104)a ∧ c : u7(cid:105),
u7 ≥ u5,
u7 ≥ u3.

Likewise, maximizing b out from e9 and e6, we get:

e11 = (cid:104)a ∧ ¬c : u8(cid:105),
u8 ≥ u3,
u8 ≥ u6;

which completes the elimination of variable b in our rule-based factored LP.

We have presented an algorithm for exploiting both additive and context-speciﬁc struc-
ture in the LP construction steps of our planning algorithms. This rule-based factored LP
approach can now be applied directly in our approximate linear programming and approx-
imate policy iteration algorithms, which were presented in Sections 5 and 6.

The only additional modiﬁcation required concerns the manipulation of the decision
list policies presented in Section 6.2. Although approximate linear programming does not
require any explicit policy representation (or the default action model), approximate pol-
icy iteration require us to represent such policy. Fortunately, no major modiﬁcations are
In particular, the conditionals (cid:104)ti, ai, δi(cid:105) in the decision
required in the rule-based case.
list policies are already context-speciﬁc rules. Thus, the policy representation algorithm in
Section 6.2 can be applied directly with our new rule-based representation. Therefore, we
now have a complete framework for exploiting both additive and context-speciﬁc structure
for eﬃcient planning in factored MDPs.

9. Experimental Results

The factored representation of a value function is most appropriate in certain types of
systems: Systems that involve many variables, but where the strong interactions between
the variables are fairly sparse, so that the decoupling of the inﬂuence between variables
does not induce an unacceptable loss in accuracy. As argued by Herbert Simon (1981)
in “Architecture of Complexity,” many complex systems have a “nearly decomposable,
hierarchical structure,” with the subsystems interacting only weakly between themselves. To
evaluate our algorithm, we selected problems that we believe exhibit this type of structure.
In this section, we perform various experiments intended to explore the performance
of our algorithms. First, we compare our factored approximate linear programming (LP)
and approximate policy iteration (PI) algorithms. We also compare to the L2-projection
algorithm of Koller and Parr (2000). Our second evaluation compares a table-based im-
plementation to a rule-based implementation that can exploit CSI. Finally, we present
comparisons between our approach and the algorithms of Boutilier et al. (2000).

9.1 Approximate LP and Approximate PI
In order to compare our approximate LP and approximate PI algorithms, we tested both on
the SysAdmin problem described in detail in Section 2.1. This problem relates to a system

448

Efficient Solution Algorithms for Factored MDPs

administrator who has to maintain a network of computers; we experimented with various
network architectures, shown in Figure 1. Machines fail randomly, and a faulty machine
increases the probability that its neighboring machines will fail. At every time step, the
SysAdmin can go to one machine and reboot it, causing it to be working in the next time
step with high probability. Recall that the state space in this problem grows exponentially
in the number of machines in the network, that is, a problem with m machines has 2m states.
Each machine receives a reward of 1 when working (except in the ring, where one machine
receives a reward of 2, to introduce some asymmetry), a zero reward is given to faulty
machines, and the discount factor is γ = 0.95. The optimal strategy for rebooting machines
will depend upon the topology, the discount factor, and the status of the machines in the
network. If machine i and machine j are both faulty, the beneﬁt of rebooting i must be
weighed against the expected discounted impact of delaying rebooting j on j’s successors.
For topologies such as rings, this policy may be a function of the status of every single
machine in the network.

The basis functions used included independent indicators for each machine, with value
1 if it is working and zero otherwise (i.e., each one is a restricted scope function of a single
variable), and the constant basis, whose value is 1 for all states. We selected straightforward
variable elimination orders: for the “Star” and “Three Legs” topologies, we ﬁrst eliminated
the variables corresponding to computers in the legs, and the center computer (server) was
eliminated last; for “Ring,” we started with an arbitrary computer and followed the ring
order; for “Ring and Star,” the ring machines were eliminated ﬁrst and then the center one;
ﬁnally, for the “Ring of Rings” topology, we eliminated the computers in the outer rings
ﬁrst and then the ones in the inner ring.

We implemented the factored policy iteration and linear programming algorithms in
Matlab, using CPLEX as the LP solver. Experiments were performed on a Sun UltraSPARC-
II, 359 MHz with 256MB of RAM. To evaluate the complexity of the approximate policy
iteration with max-norm projection algorithm, tests were performed with increasing the
number of states, that is, increasing number of machines on the network. Figure 14 shows
the running time for increasing problem sizes, for various architectures. The simplest one
is the “Star,” where the backprojection of each basis function has scope restricted to two
variables and the largest factor in the cost network has scope restricted to two variables.
The most diﬃcult one was the “Bidirectional Ring,” where factors contain ﬁve variables.

Note that the number of states is growing exponentially (indicated by the log scale in
Figure 14), but running times increase only logarithmically in the number of states, or
polynomially in the number of variables. We illustrate this behavior in Figure 14(d), where
we ﬁt a 3rd order polynomial to the running times for the “unidirectional ring.” Note that
the size of the problem description grows quadratically with the number of variables: adding
a machine to the network also adds the possible action of ﬁxing that machine. For this
problem, the computation cost of our factored algorithm empirically grows approximately
, for a problem with n variables, as opposed to the exponential complexity
as O
— poly (2n,|A|) — of the explicit algorithm.
For further evaluation, we measured the error in our approximate value function relative
to the true optimal value function V∗. Note that it is only possible to compute V∗ for small
problems; in our case, we were only able to go up to 10 machines. For comparison, we
also evaluated the error in the approximate value function produced by the L2-projection

(n · |A|)1.5(cid:162)
(cid:161)

449

Guestrin, Koller, Parr & Venkataraman

(a)

(b)

(c)

(d)

Figure 14: (a)–(c) Running times for policy iteration with max-norm projection on variants
of the SysAdmin problem; (d) Fitting a polynomial to the running time for the
“Ring” topology.

algorithm of Koller and Parr (2000). As we discussed in Section 6.4, the L2 projections in
factored MDPs by Koller and Parr are diﬃcult and time consuming; hence, we were only
able to compare the two algorithms for smaller problems, where an equivalent L2-projection
can be implemented using an explicit state space formulation. Results for both algorithms
are presented in Figure 15(a), showing the relative error of the approximate solutions to
the true value function for increasing problem sizes. The results indicate that, for larger
problems, the max-norm formulation generates a better approximation of the true optimal
value function V∗ than the L2-projection. Here, we used two types of basis functions: the
same single variable functions, and pairwise basis functions. The pairwise basis functions
contain indicators for neighboring pairs of machines (i.e., functions of two variables). As
expected, the use of pairwise basis functions resulted in better approximations.

450

01002003004005001E+001E+021E+041E+061E+081E+101E+121E+14number of statesTotal Time (minutes)Ring3 LegsStar010020030040011001000010000001000000001E+10number of statesTotal Time (minutes)Ring of RingsRing and Star01002003004005006001E+001E+021E+041E+061E+081E+101E+121E+14number of statesTotal Time (minutes)UnidirectionalBidirectionalRing:Fitting a polynomial:time = 0.0184|X|3 - 0.6655|X|2 + 9.2499|X| - 31.922Quality of the fit: R2 = 0.9990200400600800100012000102030405060number of variables  |X|Total Time (minutes)Efficient Solution Algorithms for Factored MDPs

(a)

(b)

Figure 15: (a) Relative error to optimal value function V∗ and comparison to L2 projection
for “Ring”; (b) For large models, measuring Bellman error after convergence.

For these small problems, we can also compare the actual value of the policy generated
by our algorithm to the value of the optimal policy. Here, the value of the policy generated
by our algorithm is much closer to the value of the optimal policy than the error implied by
the diﬀerence between our approximate value function and V∗. For example, for the “Star”
architecture with one server and up to 6 clients, our approximation with single variable
basis functions had relative error of 12%, but the policy we generated had the same value
as the optimal policy. In this case, the same was true for the policy generated by the L2
projection.
In a “Unidirectional Ring” with 8 machines and pairwise basis, the relative
error between our approximation and V∗ was about 10%, but the resulting policy only had
a 6% loss over the optimal policy. For the same problem, the L2 approximation has a value
function error of 12%, and a true policy loss was 9%. In other words, both methods induce
policies that have lower errors than the errors in the approximate value function (at least
for small problems). However, our algorithm continues to outperform the L2 algorithm,
even with respect to actual policy loss.
For large models, we can no longer compute the correct value function, so we cannot
evaluate our results by computing (cid:107)V∗ − Hw(cid:107)∞. Fortunately, as discussed in Section 7,
the Bellman error can be used to provide a bound on the approximation error and can be
computed eﬃciently by exploiting problem-speciﬁc structure. Figure 15(b) shows that the
Bellman error increases very slowly with the number of states.

It is also valuable to look at the actual decision-list policies generated in our experiments.
First, we noted that the lists tended to be short, the length of the ﬁnal decision list policy
grew approximately linearly with the number of machines. Furthermore, the policy itself
is often fairly intuitive. In the “Ring and Star” architecture, for example, the decision list
says: If the server is faulty, ﬁx the server; else, if another machine is faulty, ﬁx it.

Thus far, we have presented scaling results for running times and approximation error for
our approximate PI approach. We now compare this algorithm to the simpler approximate

451

00.10.20.3345678910number of variablesRelative error:Max norm, single basisL2, single basisMax norm, pair basisL2, pair basis00.10.20.30.41E+001E+021E+041E+061E+081E+101E+121E+14number of statesBellman Error / RmaxRing3 LegsStarGuestrin, Koller, Parr & Venkataraman

(a)

(b)

Figure 16: Approximate LP versus approximate PI on the SysAdmin problem with a “Ring”

topology: (a) running time; (b) estimated value of policy.

LP approach of Section 5. As shown in Figure 16(a), the approximate LP algorithm for
factored MDPs is signiﬁcantly faster than the approximate PI algorithm. In fact, approxi-
mate PI with single-variable basis functions variables is more costly computationally than
the LP approach using basis functions over consecutive triples of variables. As shown in
Figure 16(b), for singleton basis functions, the approximate PI policy obtains slightly better
performance for some problem sizes. However, as we increase the number of basis functions
for the approximate LP formulation, the value of the resulting policy is much better. Thus,
in this problem, our factored approximate linear programming formulation allows us to use
more basis functions and to obtain a resulting policy of higher value, while still maintaining
a faster running time. These results, along with the simpler implementation, suggest that
in practice one may ﬁrst try to apply the approximate linear programming algorithm before
deciding to move to the more elaborate approximate policy iteration approach.

9.2 Comparing Table-based and Rule-based Implementations

Our next evaluation compares a table-based representation, which exploits only additive
independence, to the rule-based representation presented in Section 8, which can exploit
both additive and context-speciﬁc independence. For these experiments, we implemented
our factored approximate linear programming algorithm with table-based and rule-based
representations in C++, using CPLEX as the LP solver. Experiments were performed on
a Sun UltraSPARC-II, 400 MHz with 1GB of RAM.

To evaluate and compare the algorithms, we utilized a more complex extension of the
SysAdmin problem. This problem, dubbed the Process-SysAdmin problem, contains three
state variables for each machine i in the network: Loadi, Statusi and Selectori. Each com-
puter runs processes and receives rewards when the processes terminate. These processes
are represented by the Loadi variable, which takes values in {Idle, Loaded, Success}, and the
computer receives a reward when the assignment of Loadi is Success. The Statusi variable,

452

02040608010012014016018020005101520253035number of machinesTotal running time (minutes)PI single basisLP single basisLP pair basisLP triple basis0100200300400010203040number of machinesDiscounted reward of final policy (averaged over 50 trials of 100 steps)PI single basisLP single basisLP pair basisLP triple basisEfficient Solution Algorithms for Factored MDPs

(a)

(b)

(c)

Figure 17: Running time for Process-SysAdmin problem for various topologies: (a) “Star”;

(b) “Ring”; (c) “Reverse star” (with ﬁt function).

453

0501001502001E+001E+071E+141E+211E+281E+351E+42number of statestotal running time (minutes)Table-based, single+ basisRule-based, single+ basisTable-based, pair basisRule-based, pair basis0501001502002501E+001E+041E+081E+121E+161E+201E+241E+28number of statestotal running time (minutes)Table-based, single+ basisRule-based, single+ basisTable-based, pair basisRule-based, pair basis010020030040050060005101520number of machinestotal running time (minutes)Table-based, single+ basisRule-based, single+ basisy = 0.2294x - 4.5415x  + 30.974x - 67.851R  = 0.99952y = 7E-17 x * 18     + 2E-06 x * 18     + 0.1124R  = 0.995(x-1)232(x-1)2Guestrin, Koller, Parr & Venkataraman

Figure 18: Fraction of total running time spent in CPLEX for the Process-SysAdmin prob-

lem with a “Ring” topology.

representing the status of machine i, takes values in {Good, Faulty, Dead}; if its value is
Faulty, then processes have a smaller probability of terminating and if its value is Dead,
then any running process is lost and Loadi becomes Idle. The status of machine i can be-
come Faulty and eventually Dead at random; however, if machine i receives a packet from
a dead machine, then the probability that Statusi becomes Faulty and then Dead increases.
The Selectori variable represents this communication by selecting one of the neighbors of i
uniformly at random at every time step. The SysAdmin can select at most one computer
to reboot at every time step.
If computer i is rebooted, then its status becomes Good
with probability 1, but any running process is lost, i.e., the Loadi variable becomes Idle.
Thus, in this problem, the SysAdmin must balance several conﬂicting goals: rebooting a
machine kills processes, but not rebooting a machine may cause cascading faults in network.
Furthermore, the SysAdmin can only choose one machine to reboot, which imposes the ad-
ditional tradeoﬀ of selecting only one of the (potentially many) faulty or dead machines in
the network to reboot.

We experimented with two types of basis functions: “single+” includes indicators over
all of the joint assignments of Loadi, Statusi and Selectori, and “pair” which, in addition,
includes a set of indicators over Statusi, Statusj, and Selectori = j, for each neighbor j
of machine i in the network. The discount factor was γ = 0.95. The variable elimination
order eliminated all of the Loadi variables ﬁrst, and then followed the same patterns as in
the simple SysAdmin problem, eliminating ﬁrst Statusi and then Selectori when machine i
is eliminated.

Figure 17 compares the running times for the table-based implementation to the ones
for the rule-based representation for three topologies: “Star,” “Ring,” and “Reverse star.”
The “Reverse star” topology reverses the direction of the inﬂuences in the “Star”: rather
than the central machine inﬂuencing all machines in the topology, all machines inﬂuence
the central one. These three topologies demonstrate three diﬀerent levels of CSI: In the

454

00.20.40.60.8105101520number of machinesCPLEX time / Total timeTable-based, single+ basisRule-based, single+ basisEfficient Solution Algorithms for Factored MDPs

“Star” topology, the factors generated by variable elimination are small. Thus, although the
running times are polynomial in the number of state variables for both methods, the table-
based representation is signiﬁcantly faster than the rule-based one, due to the overhead of
managing the rules. The “Ring” topology illustrates an intermediate behavior: “single+”
basis functions induce relatively small variable elimination factors, thus the table-based
approach is faster. However, with “pair” basis the factors are larger and the rule-based
approach starts to demonstrate faster running times in larger problems. Finally, the “Re-
verse star” topology represents the worst-case scenario for the table-based approach. Here,
the scope of the backprojection of a basis function for the central machine will involve all
computers in the network, as all machines can potentially inﬂuence the central one in the
next time step. Thus, the size of the factors in the table-based variable elimination ap-
proach are exponential in the number of machines in the network, which is illustrated by
the exponential growth in Figure 17(c). The rule-based approach can exploit the CSI in this
problem; for example, the status of the central machine Status0 only depends on machine
j if the value selector is j, i.e., if Selector0 = j. By exploiting CSI, we can solve the same
problem in polynomial time in the number of state variables, as seen in the second curve in
Figure 17(c).

It is also instructive to compare the portion of the total running time spent in CPLEX
for the table-based as compared to the rule-based approach. Figure 18 illustrates this
comparison. Note that amount of time spent in CPLEX is signiﬁcantly higher for the
table-based approach. There are two reasons for this diﬀerence: ﬁrst, due to CSI, the LPs
generated by the rule-based approach are smaller than the table-based ones; second, rule-
based variable elimination is more complex than the table-based one, due to the overhead
introduced by rule management. Interestingly, the proportion of CPLEX time increases as
the problem size increases, indicating that the asymptotic complexity of the LP solution is
higher than that of variable elimination, thus suggesting that, for larger problems, additional
large-scale LP optimization procedures, such as constraint generation, may be helpful.

9.3 Comparison to Apricodd

The most closely related work to ours is a line of research that began with the work of
Boutilier et al. (1995).
In particular, the approximate Apricodd algorithm of Hoey et
al. (1999), which uses analytic decision diagrams (ADDs) to represent the value function
is a strong alternative approach for solving factored MDPs. As discussed in detail in Sec-
tion 10, the Apricodd algorithm can successfully exploit context-speciﬁc structure in the
value function, by representing it with the set of mutually-exclusive and exhaustive branches
of the ADD. On the other hand, our approach can exploit both additive and context-speciﬁc
structure in the problem, by using a linear combination of non-mutually-exclusive rules. To
better understand this diﬀerence, we evaluated both our rule-based approximate linear
programming algorithm and Apricodd in two problems, Linear and Expon, designed by
Boutilier et al. (2000) to illustrate respectively the best-case and the worst-case behavior
of their algorithm.
In these experiments, we used the web-distributed version of Apri-
codd (Hoey, St-Aubin, Hu, & Boutilier, 2002), running it locally on a Linux Pentium III
700MHz with 1GB of RAM.

455

Guestrin, Koller, Parr & Venkataraman

(a)

(b)

Figure 19: Comparing Apricodd to rule-based approximate linear programming on the (a)

Linear and (b) Expon problems.

These two problems involve n binary variables X1, . . . , Xn and n deterministic actions
a1, . . . , an. The reward is 1 when all variables Xk are true, and is 0 otherwise. The problem
is discounted by a factor γ = 0.99. The diﬀerence between the Linear and the Expon
problems is in the transition probabilities. In the Linear problem, the action ak sets the
variable Xk to true and makes all succeeding variables, Xi for i > k, false. If the state space
of the Linear problem is seen as a binary number, the optimal policy is to set repeatedly the
largest bit (Xk variable) which has all preceding bits set to true. Using an ADD, the optimal
value function for this problem can be represented in linear space, with n+1 leaves (Boutilier
et al., 2000). This is the “best-case” for Apricodd, and the algorithm can compute this value
function quite eﬃciently. Figure 19(a) compares the running time of Apricodd to that of
one of our algorithms with indicator basis functions between pairs of consecutive variables.
Note that both algorithms obtain the same policy in polynomial time in the number of
variables. However, in such structured problems, the eﬃcient implementation of the ADD
package used in Apricodd makes it faster in this problem.

On the other hand, the Expon problem illustrates the worst-case for Apricodd. In this
problem, the action ak sets the variable Xk to true, if all preceding variables, Xi for i < k, are
true, and it makes all preceding variables false. If the state space is seen as a binary number,
the optimal policy goes through all binary numbers in sequence, by repeatedly setting the
largest bit (Xk variable) which has all preceding bits set to true. Due to discounting, the
optimal value function assigns a value of γ2n−j−1 to the jth binary number, so that the
value function contains exponentially many diﬀerent values. Using an ADD, the optimal
value function for this problem requires an exponential number of leaves (Boutilier et al.,
2000), which is illustrated by the exponential running time in Figure 19(b). However,
the same value function can be approximated very compactly as a factored linear value
function using n + 1 basis functions: an indicator over each variable Xk and the constant
base. As shown in Figure 19(b), using this representation, our factored approximate linear
programming algorithm computes the value function in polynomial time. Furthermore, the

456

y = 0.1473x3 - 0.8595x2 + 2.5006x - 1.5964R2 = 0.9997y = 0.0254x2 + 0.0363x + 0.0725R2 = 0.99830102030405068101214161820Number of variablesTime (in seconds)ApricoddRule-basedy = 5.275x3 - 29.95x2 + 53.915x - 28.83R2 = 10100200300400500681012Number of variables Time  (in seconds)ApricoddRule-basedy = 3E-05 * 2  - 0.0026 * 2  + 5.6737R2 = 0.9999xx2Efficient Solution Algorithms for Factored MDPs

(a)

(c)

(b)

(d)

Figure 20: Comparing Apricodd to rule-based approximate linear programming with “sin-
gle+” basis functions on the Process-SysAdmin problem with “Ring” topology
(a) running time and (b) value of the resulting policy; and with “Star” topology
(c) running time and (d) value of the resulting policy.

policy obtained by our approach was optimal for this problem. Thus, in this problem, the
ability to exploit additive independence allows an eﬃcient polynomial time solution.

We have also compared Apricodd to our rule-based approximate linear programming
algorithm on the Process-SysAdmin problem. This problem has signiﬁcant additive struc-
ture in the reward function and factorization in the transition model. Although this type of
structure is not exploited directly by Apricodd, the ADD approximation steps performed by
the algorithm can, in principle, allow Apricodd to ﬁnd approximate solutions to the prob-
lem. We spent a signiﬁcant amount of time attempting to ﬁnd the best set of parameters
for Apricodd for these problems.4 We settled on the “sift” method of variable reordering
and the “round” approximation method with the “size” (maximum ADD size) criteria. To

4. We are very grateful to Jesse Hoey and Robert St-Aubin for their assistance in selecting the parameters.

457

0102030405060024681012Number of machinesRunning time (minutes)Rule-based LPApricodd051015202530024681012Number of machinesDiscounted value of policy (avg. 50 runs of 100 steps)Rule-based LPApricodd05101520253035404550024681012Number of machinesRunning time (minutes)Rule-based LPApricodd051015202530024681012Number of machinesDiscounted value of policy (avg. 50 runs of 100 steps)Rule-based LPApricoddGuestrin, Koller, Parr & Venkataraman

allow the value function representation to scale with the problem size, we set the maximum
ADD size to 4000 + 400n for a network with n machines. (We experimented with a variety
of diﬀerent growth rates for the maximum ADD size; here, as for the other parameters,
we selected the choice that gave the best results for Apricodd.) We compared Apricodd
with these parameters to our rule-based approximate linear programming algorithm with
“single+” basis functions on a Pentium III 700MHz with 1GB of RAM. These results are
summarized in Figure 20.

On very small problems (up to 4–5 machines), the performance of the two algorithms is
fairly similar in terms of both the running time and the quality of the policies generated.
However, as the problem size grows, the running time of Apricodd increases rapidly, and
becomes signiﬁcantly higher than that of our algorithm . Furthermore, as the problem size
increases, the quality of the policies generated by Apricodd also deteriorates. This diﬀerence
in policy quality is caused by the diﬀerent value function representation used by the two
algorithms. The ADDs used in Apricodd represent k diﬀerent values with k leaves; thus,
they are forced to agglomerate many diﬀerent states and represent them using a single value.
For smaller problems, such agglomeration can still represent good policies. Unfortunately,
as the problem size increases and the state space grows exponentially, Apricodd’s policy
representation becomes inadequate, and the quality of the policies decreases. On the other
hand, our linear value functions can represent exponentially many values with only k basis
functions, which allows our approach to scale up to signiﬁcantly larger problems.

10. Related Work

The most closely related work to ours is a line of research that began with the work of
Boutilier et al. (1995). We address this comparison separately below, but we begin this
section with some broader background references.

10.1 Approximate MDP Solutions
The ﬁeld of MDPs, as it is popularly known, was formalized by Bellman (1957) in the
1950’s. The importance of value function approximation was recognized at an early stage
by Bellman himself (1963). In the early 1990’s the MDP framework was recognized by AI
researchers as a formal framework that could be used to address the problem of planning
under uncertainty (Dean, Kaelbling, Kirman, & Nicholson, 1993).

Within the AI community, value function approximation developed concomitantly with
the notion of value function representations for Markov chains. Sutton’s seminal paper on
temporal diﬀerence learning (1988), which addressed the use of value functions for prediction
but not planning, assumed a very general representation of the value function and noted
the connection to general function approximators such as neural networks. However, the
stability of this combination was not directly addressed at that time.

Several important developments gave the AI community deeper insight into the rela-
tionship between function approximation and dynamic programming. Tsitsiklis and Van
Roy (1996a) and, independently, Gordon (1995) popularized the analysis of approximate
MDP methods via the contraction properties of the dynamic programming operator and
function approximator. Tsitsiklis and Van Roy (1996b) later established a general con-
vergence result for linear value function approximators and T D(λ), and Bertsekas and

458

Efficient Solution Algorithms for Factored MDPs

Tsitsiklis (1996) uniﬁed a large body of work on approximate dynamic programming under
the name of Neuro-dynamic Programming, also providing many novel and general error
analyses.

Approximate linear programming for MDPs using linear value function approximation
was introduced by Schweitzer and Seidmann (1985), although the approach was somewhat
deprecated until fairly recently due the lack of compelling error analyses and the lack of an
eﬀective method for handling the large number of constraints. Recent work by de Farias
and Van Roy (2001a, 2001b) has started to address these concerns with new error bounds
and constraint sampling methods. Our approach, rather than sampling constraints, utilizes
structure in the model and value function to represent all of the constraints compactly.

10.2 Factored Approaches

Tatman and Shachter (1990) considered the additive decomposition of value nodes in inﬂu-
ence diagrams. A number of approaches to factoring of general MDPs have been explored in
the literature. Techniques for exploiting reward functions that decompose additively were
studied by Meuleau et al. (1998), and by Singh and Cohn (1998).

The use of factored representations such as dynamic Bayesian networks was pioneered
by Boutilier et al. (1995) and has developed steadily in recent years. These methods rely
on the use of context-speciﬁc structures such as decision trees or analytic decision diagrams
(ADDs) (Hoey et al., 1999) to represent both the transition dynamics of the DBN and
the value function. The algorithms use dynamic programming to partition the state space,
representing the partition using a tree-like structure that branches on state variables and
assigns values at the leaves. The tree is grown dynamically as part of the dynamic pro-
gramming process and the algorithm creates new leaves as needed: A leaf is split by the
application of a DP operator when two states associated with that leaf turn out to have
diﬀerent values in the backprojected value function. This process can also be interpreted
as a form of model minimization (Dean & Givan, 1997).

The number of leaves in a tree used to represent a value function determines the compu-
tational complexity of the algorithm. It also limits the number of distinct values that can
be assigned to states: since the leaves represent a partitioning of the state space, every state
maps to exactly one leaf. However, as was recognized early on, there are trivial MDPs which
require exponentially large value functions. This observation led to a line of approximation
algorithms aimed at limiting the tree size (Boutilier & Dearden, 1996) and, later, limiting
the ADD size (St-Aubin, Hoey, & Boutilier, 2001). Kim and Dean (2001) also explored
techniques for discovering tree-structured value functions for factored MDPs. While these
methods permit good approximate solutions to some large MDPs, their complexity is still
determined by the number of leaves in the representation and the number of distinct values
than can be assigned to states is still limited as well.

Tadepalli and Ok (1996) were the ﬁrst to apply linear value function approximation
to Factored MDPs. Linear value function approximation is a potentially more expressive
approximation method because it can assign unique values to every state in an MDP without
requiring storage space that is exponential in the number of state variables. The expressive
power of a tree with k leaves can be captured by a linear function approximator with k basis
functions such that basis function hi is an indicator function that tests if a state belongs

459

Guestrin, Koller, Parr & Venkataraman

in the partition of leaf i. Thus, the set of value functions that can be represented by a
tree with k leaves is a subset of the set of value functions that can be represented by a
value function with k basis functions. Our experimental results in Section 9.3 highlight this
diﬀerence by showing an example problem that requires exponentially many leaves in the
value function, but that can be approximated well using a linear value function.

The main advantage of tree-based value functions is that their structure is determined
dynamically during the solution of the MDP. In principle, as the value function representa-
tion is derived automatically from the model description, this approach requires less insight
from the user. In problems for which the value function can be well approximated by a rel-
atively small number of values, this approach provides an excellent solution to the problem.
Our method of linear value function approximation aims to address what we believe to be
the more common case, where a large range of distinct values is required to achieve a good
approximation.

Finally, we note that Schuurmans and Patrascu (2001), based on our earlier work on
max-norm projection using cost networks and linear programs, independently developed
an alternative approach to approximate linear programming using a cost network. Our
method embeds a cost network inside a single linear program. By contrast, their method
is based on a constraint generation approach, using a cost network to detect constraint
violations. When constraint violations are found, a new constraint is added, repeatedly
generating and attempting to solve LPs until a feasible solution is found.
Interestingly,
as the approach of Schuurmans and Patrascu uses multiple calls to variable elimination in
order to speed up the LP solution step, it will be most successful when the time spent
solving the LP is signiﬁcantly larger than the time required for variable elimination. As
suggested in Section 9.2, the LP solution time is larger for the table-based approach. Thus,
Schuurmans and Patrascu’s constraint generation method will probably be more successful
in table-based problems than in rule-based ones.

11. Conclusions

In this paper, we presented new algorithms for approximate linear programming and ap-
proximate dynamic programming (value and policy iteration) for factored MDPs. Both
of these algorithms leverage on a novel LP decomposition technique, analogous to vari-
able elimination in cost networks, which reduces an exponentially large LP to a provably
equivalent, polynomial-sized one.
Our approximate dynamic programming algorithms are motivated by error analyses
showing the importance of minimizing L∞ error. These algorithms are more eﬃcient and
substantially easier to implement than previous algorithms based on the L2-projection. Our
experimental results suggest that they also perform better in practice.

Our approximate linear programming algorithm for factored MDPs is simpler, easier to
implement and more general than the dynamic programming approaches. Unlike our policy
iteration algorithm, it does not rely on the default action assumption, which states that
actions only aﬀect a small number of state variables. Although this algorithm does not have
the same theoretical guarantees as max-norm projection approaches, empirically it seems to
be a favorable option. Our experiments suggest that approximate policy iteration tends to
generate better policies for the same set of basis functions. However, due to the computa-

460

Efficient Solution Algorithms for Factored MDPs

tional advantages, we can add more basis functions to the approximate linear programming
algorithm, obtaining a better policy and still maintaining a much faster running time than
approximate policy iteration.

Unlike previous approaches, our algorithms can exploit both additive and context-
speciﬁc structure in the factored MDP model. Typical real-world systems possess both
of these types of structure.
thus, this feature of our algorithms will increase the appli-
cability of factored MDPs to more practical problems. We demonstrated that exploiting
context-speciﬁc independence, by using a rule-based representation instead of the standard
table-based one, can yield exponential improvements in computational time when the prob-
lem has signiﬁcant amounts of CSI. However, the overhead of managing sets of rules make
it less well-suited for simpler problems. We also compared our approach to the work of
Boutilier et al. (2000), which exploits only context-speciﬁc structure. For problems with
signiﬁcant context-speciﬁc structure in the value function, their approach can be faster due
to their eﬃcient handling of the ADD representation. However, there are problems with
signiﬁcant context-speciﬁc structure in the problem representation, rather than in the value
function, which require exponentially large ADDs.
In some such problems, we demon-
strated that by using a linear value function our algorithm can obtain a polynomial-time
near-optimal approximation of the true value function.

The success of our algorithm depends on our ability to capture the most important
structure in the value function using a linear, factored approximation. This ability, in turn,
depends on the choice of the basis functions and on the properties of the domain. The
algorithms currently require the designer to specify the factored basis functions. This is a
limitation compared to the algorithms of Boutilier et al. (2000), which are fully automated.
However, our experiments suggest that a few simple rules can be quite successful for de-
signing a basis. First, we ensure that the reward function is representable by our basis. A
simple basis that, in addition, contained a separate set of indicators for each variable often
did quite well. We can also add indicators over pairs of variables; most simply, we can choose
these according to the DBN transition model, where an indicator is added between variables
Xi and each one of the variables in Parents(Xi), thus representing one-step inﬂuences. This
procedure can be extended, adding more basis functions to represent more inﬂuences as
required. Thus, the structure of the DBN gives us indications of how to choose the basis
functions. Other sources of prior knowledge can also be included for further specifying the
basis.

Nonetheless, a general algorithm for choosing good factored basis functions still does
not exist. However, there are some potential approaches: First, in problems with CSI, one
could apply the algorithms of Boutilier et al. for a few iterations to generate partial tree-
structured solutions. Indicators deﬁned over the variables in backprojection of the leaves
could, in turn, be used to generate a basis set for such problems. Second, the Bellman
error computation, which can be performed eﬃciently as shown in Section 7, does not only
provide a bound on the quality of the policy, but also the actual state where the error is
largest. This knowledge can be used to create a mechanism to incrementally increase the
basis set, adding new basis functions to tackle states with high Bellman error.

There are many other possible extensions to this work. We have already pursued ex-
tensions to collaborative multiagent systems, where multiple agents act simultaneously to
maximize the global reward (Guestrin et al., 2001b), and factored POMDPs, where the

461

Guestrin, Koller, Parr & Venkataraman

full state is not observed directly, but indirectly through observation variables (Guestrin,
Koller, & Parr, 2001c). However, there are other settings that remain to be explored. In
particular, we hope to address the problem of learning a factored MDP and planning in a
competitive multiagent system.

Additionally, in this paper we have tackled problems where the induced width of the cost
network is suﬃciently low or that possess suﬃcient context-speciﬁc structure to allow for
the exact solution of our factored LPs. Unfortunately, some practical problems may have
prohibitively large induced width. We plan to leverage on ideas from loopy belief prop-
agation algorithms for approximate inference in Bayesian networks (Pearl, 1988; Yedidia,
Freeman, & Weiss, 2001) to address this issue.

We believe that the methods described herein signiﬁcantly further extend the eﬃciency,
applicability and general usability of factored models and value functions for the control of
practical dynamic systems.

Acknowledgements

We are very grateful to Craig Boutilier, Dirk Ormoneit and Uri Lerner for many useful
discussions, and to the anonymous reviewers for their detailed and thorough comments. We
also would like to thank Jesse Hoey, Robert St-Aubin, Alan Hu, and Craig Boutilier for
distributing their algorithm and for their very useful assistance in using Apricodd and in
selecting its parameters. This work was supported by the DoD MURI program, adminis-
tered by the Oﬃce of Naval Research under Grant N00014-00-1-0637, by Air Force contract
F30602-00-2-0598 under DARPA’s TASK program, and by the Sloan Foundation. The ﬁrst
author was also supported by a Siebel Scholarship.

Appendix A. Proofs

A.1 Proof of Lemma 3.3
There exists a setting to the weights — the all zero setting — that yields a bounded max-
norm projection error βP for any policy (βP ≤ Rmax). Our max-norm projection operator
chooses the set of weights that minimizes the projection error β(t) for each policy π(t). Thus,
the projection error β(t) must be at least as low as the one given by the zero weights βP
(which is bounded). Thus, the error remains bounded for all iterations.

A.2 Proof of Theorem 3.5
First, we need to bound our approximation of Vπ(t):

(cid:176)(cid:176)(cid:176)Vπ(t) − Hw(t)

≤

(cid:176)(cid:176)(cid:176)∞ ≤
(cid:176)(cid:176)(cid:176)Vπ(t) − Hw(t)

(cid:176)(cid:176)(cid:176)Tπ(t)Hw(t) − Hw(t)
(cid:176)(cid:176)(cid:176)Tπ(t)Hw(t) − Hw(t)
(cid:176)(cid:176)(cid:176)∞ ≤ 1

1 − γ

(cid:176)(cid:176)(cid:176)Vπ(t) − Tπ(t)Hw(t)
(cid:176)(cid:176)(cid:176)∞ +
(cid:176)(cid:176)(cid:176)Vπ(t) − Hw(t)
(cid:176)(cid:176)(cid:176)∞ + γ
(cid:176)(cid:176)(cid:176)Tπ(t)Hw(t) − Hw(t)

(cid:176)(cid:176)(cid:176)∞ ; (triangle inequality;)
(cid:176)(cid:176)(cid:176)∞ ; (Tπ(t) is a contraction.)
(cid:176)(cid:176)(cid:176)∞ = β(t)

(24)

1 − γ

Moving the second term to the right hand side and dividing through by 1 − γ, we obtain:

.

462

Efficient Solution Algorithms for Factored MDPs

For the next part of the proof, we adapt a lemma of Bertsekas and Tsitsiklis (1996, Lemma
6.2, p.277) to ﬁt into our framework. After some manipulation, this lemma can be refor-
mulated as:

(cid:176)(cid:176)(cid:176)Vπ(t) − Hw(t)

(cid:176)(cid:176)(cid:176)∞ .

(25)

(cid:107)V∗ − Vπ(t+1)(cid:107)∞ ≤ γ (cid:107)V∗ − Vπ(t)(cid:107)∞ +

2γ
1 − γ

The proof is concluded by substituting Equation (24) into Equation (25) and, ﬁnally, in-
duction on t.

A.3 Proof of Theorem 4.4
First, note that the equality constraints represent a simple change of variable. Thus, we
can rewrite Equation (12) in terms of these new LP variables ufi

zi as:

ufi
zi,

(26)

(cid:88)

i

φ ≥ max

x

(cid:88)

i

φ ≥

where any assignment to the weights w implies an assignment for each ufi
we only have LP variables.
It remains to show that the factored LP construction is equivalent to the constraint in
Equation (26). For a system with n variables {X1, . . . , Xn}, we assume, without loss of
generality, that variables are eliminated starting from Xn down to X1. We now prove the
equivalence by induction on the number of variables.

zi. After this stage,

The base case is n = 0, so that the functions ci(x) and b(x) in Equation (12) all have

empty scope. In this case, Equation (26) can be written as:

uei.

(27)

In this case, no transformation is done on the constraint, and equivalence is immediate.

Now, we assume the result holds for systems with i−1 variables and prove the equivalence
for a system with i variables. In such a system, the maximization can be decomposed into
two terms: one with the factors that do not depend on Xi, which are irrelevant to the
maximization over Xi, and another term with all the factors that depend on Xi. Using this
decomposition, we can write Equation (26) as:

φ ≥ max

x1,...,xi

≥

max

x1,...,xi−1

(cid:88)
 (cid:88)

uej
zj ;

j

l : xi(cid:54)∈zl

 .

uej
zj

(cid:88)

j : xi∈zj

uel
zl

+ max

xi

(28)

z corresponding to the second term on
At this point we can deﬁne new LP variables ue
the right hand side of the constraint. These new LP variables must satisfy the following
constraint:

z ≥ max
ue

xi

uej
(z,xi)[Zj ].

(29)

(cid:96)(cid:88)

j=1

463

Guestrin, Koller, Parr & Venkataraman

This new non-linear constraint is again represented in the factored LP construction by a
set of equivalent linear constraints:

z ≥ (cid:96)(cid:88)

ue

j=1

(z,xi)[Zj ],∀z, xi.
uej

(30)

The equivalence between the non-linear constraint Equation (29) and the set of linear con-
straints in Equation (30) can be shown by considering binding constraints. For each new
z, there are |Xi| new constraints created, one for each value xi of Xi.
LP variable created ue
For any assignment to the LP variables in the right hand side of the constraint in Equa-
tion (30), only one of these |Xi| constraints is relevant. That is, one where
(z,xi)[Zj ]
is maximal, which corresponds to the maximum over Xi. Again, if for each value of z more
than one assignment to Xi achieves the maximum, then any of (and only) the constraints
corresponding to those maximizing assignments could be binding. Thus, Equation (29) and
Equation (30) are equivalent.

(cid:80)(cid:96)

j=1 uej

Substituting the new LP variables ue
φ ≥ max
x1,...,xi−1

z into Equation (28), we get:

(cid:88)

uel
zl

+ ue
z,

l : xi(cid:54)∈zl

which does not depend on Xi anymore. Thus, it is equivalent to a system with i−1 variables,
concluding the induction step and the proof.

A.4 Proof of Lemma 7.1
First note that at iteration t + 1 the objective function φ(t+1) of the max-norm projection
LP is given by:

(cid:176)(cid:176)(cid:176)Hw(t+1) −

(cid:179)

φ(t+1) =

Rπ(t+1) + γPπ(t+1)Hw(t+1)

(cid:180)(cid:176)(cid:176)(cid:176)∞ .

However, by convergence the value function estimates are equal for both iterations:

So we have that:

φ(t+1) =

(cid:176)(cid:176)(cid:176)Hw(t) −

In operator notation, this term is equivalent to:

w(t+1) = w(t).

(cid:179)
(cid:176)(cid:176)(cid:176)Hw(t) − Tπ(t+1)Hw(t)

Rπ(t+1) + γPπ(t+1)Hw(t)

(cid:176)(cid:176)(cid:176)∞ .

(cid:180)(cid:176)(cid:176)(cid:176)∞ .

φ(t+1) =

Note that, π(t+1) = Greedy(Hw(t)) by deﬁnition. Thus, we have that:

Finally, substituting into the previous expression, we obtain the result:

Tπ(t+1)Hw(t) = T ∗Hw(t).

(cid:176)(cid:176)(cid:176)Hw(t) − T ∗Hw(t)

(cid:176)(cid:176)(cid:176)∞ .

φ(t+1) =

464

Efficient Solution Algorithms for Factored MDPs

References

Arnborg, S., Corneil, D. G., & Proskurowski, A. (1987). Complexity of ﬁnding embeddings

in a K-tree. SIAM Journal of Algebraic and Discrete Methods, 8 (2), 277 – 284.

Becker, A., & Geiger, D. (2001). A suﬃciently fast algorithm for ﬁnding close to optimal

clique trees. Artiﬁcial Intelligence, 125 (1-2), 3–17.

Bellman, R., Kalaba, R., & Kotkin, B. (1963). Polynomial approximation – a new compu-

tational technique in dynamic programming. Math. Comp., 17 (8), 155–161.

Bellman, R. E. (1957). Dynamic Programming. Princeton University Press, Princeton, New

Jersey.

Bertele, U., & Brioschi, F. (1972). Nonserial Dynamic Programming. Academic Press, New

York.

Bertsekas, D., & Tsitsiklis, J. (1996). Neuro-Dynamic Programming. Athena Scientiﬁc,

Belmont, Massachusetts.

Boutilier, C., Dean, T., & Hanks, S. (1999). Decision theoretic planning: Structural assump-
tions and computational leverage. Journal of Artiﬁcial Intelligence Research, 11, 1 –
94.

Boutilier, C., & Dearden, R. (1996). Approximating value trees in structured dynamic

programming. In Proc. ICML, pp. 54–62.

Boutilier, C., Dearden, R., & Goldszmidt, M. (1995). Exploiting structure in policy con-

struction. In Proc. IJCAI, pp. 1104–1111.

Boutilier, C., Dearden, R., & Goldszmidt, M. (2000). Stochastic dynamic programming

with factored representations. Artiﬁcial Intelligence, 121 (1-2), 49–107.

Cheney, E. W. (1982). Approximation Theory (2nd edition). Chelsea Publishing Co., New

York, NY.

de Farias, D., & Van Roy, B. (2001a). The linear programming approach to approximate

dynamic programming. Submitted to Operations Research.

de Farias, D., & Van Roy, B. (2001b). On constraint sampling for the linear program-
ming approach to approximate dynamic programming. To appear in Mathematics of
Operations Research.

Dean, T., Kaelbling, L. P., Kirman, J., & Nicholson, A. (1993). Planning with deadlines in
stochastic domains. In Proceedings of the Eleventh National Conference on Artiﬁcial
Intelligence (AAAI-93), pp. 574–579, Washington, D.C. AAAI Press.

Dean, T., & Kanazawa, K. (1989). A model for reasoning about persistence and causation.

Computational Intelligence, 5 (3), 142–150.

Dean, T., & Givan, R. (1997). Model minimization in Markov decision processes.

In
Proceedings of the Fourteenth National Conference on Artiﬁcial Intelligence (AAAI-
97), pp. 106–111, Providence, Rhode Island, Oregon. AAAI Press.

Dearden, R., & Boutilier, C. (1997). Abstraction and approximate decision theoretic plan-

ning. Artiﬁcial Intelligence, 89 (1), 219–283.

465

Guestrin, Koller, Parr & Venkataraman

Dechter, R. (1999). Bucket elimination: A unifying framework for reasoning. Artiﬁcial

Intelligence, 113 (1–2), 41–85.

Gordon, G. (1995). Stable function approximation in dynamic programming. In Proceedings
of the Twelfth International Conference on Machine Learning, pp. 261–268, Tahoe
City, CA. Morgan Kaufmann.

Guestrin, C. E., Koller, D., & Parr, R. (2001a). Max-norm projections for factored MDPs.
In Proceedings of the Seventeenth International Joint Conference on Artiﬁcial Intel-
ligence (IJCAI-01), pp. 673 – 680, Seattle, Washington. Morgan Kaufmann.

Guestrin, C. E., Koller, D., & Parr, R. (2001b). Multiagent planning with factored MDPs.
In 14th Neural Information Processing Systems (NIPS-14), pp. 1523–1530, Vancouver,
Canada.

Guestrin, C. E., Koller, D., & Parr, R. (2001c). Solving factored POMDPs with linear value
functions.
In Seventeenth International Joint Conference on Artiﬁcial Intelligence
(IJCAI-01) workshop on Planning under Uncertainty and Incomplete Information,
pp. 67 – 75, Seattle, Washington.

Guestrin, C. E., Venkataraman, S., & Koller, D. (2002). Context speciﬁc multiagent coor-
dination and planning with factored MDPs. In The Eighteenth National Conference
on Artiﬁcial Intelligence (AAAI-2002), pp. 253–259, Edmonton, Canada.

Hoey, J., St-Aubin, R., Hu, A., & Boutilier, C. (1999). SPUDD: Stochastic planning us-
ing decision diagrams. In Proceedings of the Fifteenth Conference on Uncertainty in
Artiﬁcial Intelligence (UAI-99), pp. 279–288, Stockholm, Sweden. Morgan Kaufmann.
Hoey, J., St-Aubin, R., Hu, A., & Boutilier, C. (2002). Stochastic planning using decision

diagrams – C implementation. http://www.cs.ubc.ca/spider/staubin/Spudd/.

Howard, R. A., & Matheson, J. E. (1984). Inﬂuence diagrams. In Howard, R. A., & Math-
eson, J. E. (Eds.), Readings on the Principles and Applications of Decision Analysis,
pp. 721–762. Strategic Decisions Group, Menlo Park, California.

Keeney, R. L., & Raiﬀa, H. (1976). Decisions with Multiple Objectives: Preferences and

Value Tradeoﬀs. Wiley, New York.

Kim, K.-E., & Dean, T. (2001). Solving factored Mdps using non-homogeneous partition-
ing. In Proceedings of the Seventeenth International Joint Conference on Artiﬁcial
Intelligence (IJCAI-01), pp. 683 – 689, Seattle, Washington. Morgan Kaufmann.

Kjaerulﬀ, U. (1990). Triangulation of graphs – algorithms giving small total state space.
Tech. rep. TR R 90-09, Department of Mathematics and Computer Science, Strand-
vejen, Aalborg, Denmark.

Koller, D., & Parr, R. (1999). Computing factored value functions for policies in structured
MDPs. In Proceedings of the Sixteenth International Joint Conference on Artiﬁcial
Intelligence (IJCAI-99), pp. 1332 – 1339. Morgan Kaufmann.

Koller, D., & Parr, R. (2000). Policy iteration for factored MDPs. In Proceedings of the
Sixteenth Conference on Uncertainty in Artiﬁcial Intelligence (UAI-00), pp. 326 –
334, Stanford, California. Morgan Kaufmann.

466

Efficient Solution Algorithms for Factored MDPs

Meuleau, N., Hauskrecht, M., Kim, K., Peshkin, L., Kaelbling, L., Dean, T., & Boutilier, C.
(1998). Solving very large weakly-coupled Markov decision processes. In Proceedings
of the 15th National Conference on Artiﬁcial Intelligence, pp. 165–172, Madison, WI.
Pearl, J. (1988). Probabilistic Reasoning in Intelligent Systems: Networks of Plausible In-

ference. Morgan Kaufmann, San Mateo, California.

Puterman, M. L. (1994). Markov decision processes: Discrete stochastic dynamic program-

ming. Wiley, New York.

Reed, B. (1992). Finding approximate separators and computing tree-width quickly.

In

24th Annual Symposium on Theory of Computing, pp. 221–228. ACM.

Schuurmans, D., & Patrascu, R. (2001). Direct value-approximation for factored MDPs.
In Advances in Neural Information Processing Systems (NIPS-14), pp. 1579–1586,
Vancouver, Canada.

Schweitzer, P., & Seidmann, A. (1985). Generalized polynomial approximations in Marko-
vian decision processes. Journal of Mathematical Analysis and Applications, 110, 568
– 582.

Simon, H. A. (1981). The Sciences of the Artiﬁcial (second edition). MIT Press, Cambridge,

Massachusetts.

Singh, S., & Cohn, D. (1998). How to dynamically merge Markov decision processes. In
Jordan, M. I., Kearns, M. J., & Solla, S. A. (Eds.), Advances in Neural Information
Processing Systems, Vol. 10. The MIT Press.

St-Aubin, R., Hoey, J., & Boutilier, C. (2001). APRICODD: Approximate policy construc-
tion using decision diagrams. In Advances in Neural Information Processing Systems
13: Proceedings of the 2000 Conference, pp. 1089–1095, Denver, Colorado. MIT Press.
Stiefel, E. (1960). Note on Jordan elimination, linear programming and Tchebycheﬀ ap-

proximation. Numerische Mathematik, 2, 1 – 17.

Sutton, R. S. (1988). Learning to predict by the methods of temporal diﬀerences. Machine

Learning, 3, 9–44.

Tadepalli, P., & Ok, D. (1996). Scaling up average reward reinforcmeent learning by approx-
imating the domain models and the value function. In Proceedings of the Thirteenth
International Conference on Machine Learning, Bari, Italy. Morgan Kaufmann.

Tatman, J. A., & Shachter, R. D. (1990). Dynamic programming and inﬂuence diagrams.

IEEE Transactions on Systems, Man and Cybernetics, 20 (2), 365–379.

Tsitsiklis, J. N., & Van Roy, B. (1996a). Feature-based methods for large scale dynamic

programming. Machine Learning, 22, 59–94.

Tsitsiklis, J. N., & Van Roy, B. (1996b). An analysis of temporal-diﬀerence learning with
function approximation. Technical report LIDS-P-2322, Laboratory for Information
and Decision Systems, Massachusetts Institute of Technology.

Van Roy, B. (1998). Learning and Value Function Approximation in Complex Decision

Processes. Ph.D. thesis, Massachusetts Institute of Technology.

467

Guestrin, Koller, Parr & Venkataraman

Williams, R. J., & Baird, L. C. I. (1993). Tight performance bounds on greedy policies based
on imperfect value functions. Tech. rep., College of Computer Science, Northeastern
University, Boston, Massachusetts.

Yedidia, J., Freeman, W., & Weiss, Y. (2001). Generalized belief propagation. In Advances
in Neural Information Processing Systems 13: Proceedings of the 2000 Conference,
pp. 689–695, Denver, Colorado. MIT Press.

Zhang, N., & Poole, D. (1999). On the role of context-speciﬁc independence in probabilistic
reasoning. In Proceedings of the Sixteenth International Joint Conference on Artiﬁcial
Intelligence (IJCAI-99), pp. 1288–1293. Morgan Kaufmann.

468

