LEARNING STRUCTURED PREDICTION MODELS:

A LARGE MARGIN APPROACH

A DISSERTATION

SUBMITTED TO THE DEPARTMENT OF COMPUTER SCIENCE

AND THE COMMITTEE ON GRADUATE STUDIES

OF STANFORD UNIVERSITY

IN PARTIAL FULFILLMENT OF THE REQUIREMENTS

FOR THE DEGREE OF

DOCTOR OF PHILOSOPHY

Ben Taskar

December 2004

c(cid:176) Copyright by Ben Taskar 2005

All Rights Reserved

ii

I certify that I have read this dissertation and that, in my opin-
ion, it is fully adequate in scope and quality as a dissertation
for the degree of Doctor of Philosophy.

Daphne Koller

Computer Science Department

Stanford University
(Principal Advisor)

I certify that I have read this dissertation and that, in my opin-
ion, it is fully adequate in scope and quality as a dissertation
for the degree of Doctor of Philosophy.

Andrew Y. Ng

Computer Science Department

Stanford University

I certify that I have read this dissertation and that, in my opin-
ion, it is fully adequate in scope and quality as a dissertation
for the degree of Doctor of Philosophy.

Fernando Pereira

Computer Science Department

University of Pennsylvania

Approved for the University Committee on Graduate Stud-
ies:

iii

iv

To my parents, Mark and Tsilya, and my love, Anat.

Abstract

Most questions require more than just true-false or multiple-choice answers. Yet super-
vised learning, like standardized testing, has placed the heaviest emphasis on complex
questions with simple answers. The acquired expertise must now be used to address tasks
that demand answers as complex as the questions. Such complex answers may consist of
multiple interrelated decisions that must be weighed against each other to arrive at a glob-
ally satisfactory and consistent solution to the question. In natural language processing, we
often need to construct a global, coherent analysis of a sentence, such as its corresponding
part-of-speech sequence, parse tree, or translation into another language. In computational
biology, we analyze genetic sequences to predict 3D structure of proteins, ﬁnd global align-
ment of related DNA strings, and recognize functional portions of a genome. In computer
vision, we segment complex objects in cluttered scenes, reconstruct 3D shapes from stereo
and video, and track motion of articulated bodies.

We typically handle the exponential explosion of possible answers by building mod-
els that compactly capture the structural properties of the problem: sequential, grammat-
ical, chemical, temporal, spatial constraints and correlations. Such structured models in-
clude graphical models such as Markov networks (Markov random ﬁelds), recursive lan-
guage models such as context free grammars, combinatorial optimization problems such as
weighted matchings and graph-cuts. This thesis presents a discriminative estimation frame-
work for structured models based on the large margin principle underlying support vector
machines. Intuitively, the large-margin criterion provides an alternative to probabilistic,
likelihood-based estimation methods by concentrating directly on the robustness of the de-
cision boundary of a model. Our framework deﬁnes a suite of efﬁcient learning algorithms
that rely on the expressive power of convex optimization to compactly capture inference or

vii

solution optimality in structured models. For some of these models, alternative estimation
methods are intractable.

The largest portion of the thesis is devoted to Markov networks, which are undirected
probabilistic graphical models widely used to efﬁciently represent and reason about joint
multivariate distributions. We use graph decomposition to derive an exact, compact, con-
vex formulation for large-margin estimation of Markov networks with sequence and other
low-treewidth structure. Seamless integration of kernels with graphical models allows ef-
ﬁcient, accurate prediction in real-world tasks. We analyze the theoretical generalization
properties of max-margin estimation in Markov networks and derive a novel type of bound
on structured error. Using an efﬁcient online-style algorithm that exploits inference in the
model and analytic updates, we solve very large estimation problems.

We deﬁne an important subclass of Markov networks, associative Markov networks
(AMNs), which captures positive correlations between variables and permits exact infer-
ence which scales up to tens of millions of nodes and edges. While likelihood-based meth-
ods are believed to be intractable for AMNs over binary variables, our framework allows
exact estimation of such networks of arbitrary connectivity and topology. We also intro-
duce relational Markov networks (RMNs), which compactly deﬁne templates for Markov
networks for domains with relational structure: objects, attributes, relations.

In addition to graphical models, our framework applies to a wide range of other models:
We exploit context free grammar structure to derive a compact max-margin formulation that
allows high-accuracy parsing in cubic time by using novel kinds of lexical information. We
use combinatorial properties of weighted matchings to develop an exact, efﬁcient formu-
lation for learning to match and apply it to prediction of disulﬁde connectivity in proteins.
Finally, we derive a max-margin formulation for learning the scoring metric for clustering
from clustered training data, which tightly integrates metric learning with the clustering
algorithm, tuning one to the other in a joint optimization.

We describe experimental applications to a diverse range of tasks, including handwrit-
ing recognition, 3D terrain classiﬁcation, disulﬁde connectivity prediction in proteins, hy-
pertext categorization, natural language parsing, email organization and image segmen-
tation. These empirical evaluations show signiﬁcant improvements over state-of-the-art
methods and promise wide practical use for our framework.

viii

Acknowledgements

I am profoundly grateful to my advisor, Daphne Koller. Her tireless pursuit of excellence in
research, teaching, advising, and every other aspect of her academic work is truly inspira-
tional. I am indebted to Daphne for priceless and copious advice about selecting interesting
problems, making progress on difﬁcult ones, pushing ideas to their full development, writ-
ing and presenting results in an engaging manner.

I would like to thank my thesis committee, Andrew Ng and Fernando Pereira, as well
as my defense committee members, Stephen Boyd and Sebastian Thrun, for their excellent
suggestions and thought-provoking questions. I have learned a great deal from their work
and their inﬂuence on this thesis is immense. In particular, Fernando’s work on Markov
networks has inspired my focus on this subject. Andrew’s research on clustering and clas-
siﬁcation has informed many of the practical problems addressed in the thesis. Sebastian
introduced me to the fascinating problems in 3D vision and robotics. Finally, Stephen’s
book on convex optimization is the primary source of many of the insights and derivations
in this thesis.

Daphne’s research group is an institution in itself. I am very lucky to have been a part
of it and shared the company, the ideas, the questions and the expertise of Pieter Abbeel,
Drago Anguelov, Alexis Battle, Luke Biewald, Xavier Boyen, Vassil Chatalbashev, Gal
Chechik, Lise Getoor, Carlos Guestrin, Uri Lerner, Uri Nodelman, Dirk Ormoneit, Ron
Parr, Eran Segal, Christian Shelton, Simon Tong, David Vickrey, Haidong Wang and Ming
Fai Wong.

Jean-Claude Latombe was my ﬁrst research advisor when I was still an undergraduate
at Stanford. His thoughtful guidance and quick wit were a great welcome and inspiration
to continue my studies. When I started my research in machine learning with Daphne, I

ix

had the privilege and pleasure to work with Nir Friedman, Lise Getoor and Eran Segal.
They have taught me to remain steadfast when elegant theories meet the ragged edge of
real problems. Lise has been a great friend and my other big sister throughout my graduate
life. I could not wish for more caring advice and encouragement than she has given me all
these years.

I was lucky to meet Michael Collins, Michael Littman and David McAllester all in
one place, while I was a summer intern at AT&T. Collins’ work on learning large-margin
tagging and parsing models motivated me to look at such methods for other structured
models. I am very glad I had the chance to work with him on the max-margin parsing
project. Michael Littman, with his endearing combination of humor and warmth, lightness
and depth, has been a constant source of encouragement and inspiration. David’s wide-
ranging research on probability and logic, languages and generalization bounds, to mention
a few, enlightened much of my work.

(Almost) everything I know about natural language processing I learned from Chris
Manning and Dan Klein. Chris’ healthy scepticism and emphasis on the practical has kept
me from going down many dead-end paths. Dan has an incredible gift of making ideas
work, and better yet, explaining why other ideas do not work.

I would like to express my appreciation and gratitude to all my collaborators for their
excellent ideas, hard work and dedication: Pieter Abbeel, Drago Anguelov, Peter Bartlett,
Luke Biewald, Vassil Chatalbashev, Michael Collins, Nir Friedman, Audrey Gasch, Lise
Getoor, Carlos Guestrin, Geremy Heitz, Dan Klein, Daphne Koller, Chris Manning, David
McAllester, Eran Segal, David Vickrey and Ming Fai Wong.

Merci beaucoup to Pieter Abbeel, my sounding board for many ideas in convex opti-
mization and learning, for numerous enlightening discussions that we have had anytime,
anywhere: gym, tennis court, biking to EV, over cheap Thai food. Ogromnoye spasibo to
my ofﬁcemate, sportsmate, always late, ever-ready to checkmate, Drago Anguelov, who
is always willing to share with me everything from research problems to music and back-
packing treks to Russian books and Belgian beer. Blagodarya vi mnogo for another great
Bulgarian I have the good luck to know, Vasco Chatalbashev, for his company and ideas,
good cheer and the great knack for always coming through. Muchas gracias to Carlos
Guestrin, my personal climbing instructor, fellow photography fanatic, avid grillmaster

x

and exploiter-of-structure extraordinaire, for opening his ear and heart to me when it mat-
ters most. Mh-goi-saai to Ming Fai Wong, for his sense of humor, kind heart and excellent
work.

Many thanks to my friends who have had nothing to do with work in this thesis, but
worked hard to keep my relative sanity throughout. I will not list all of you here, but my
gratitude to you is immense.

My parents, Mark and Tsilya, have given me unbending support and constant encour-
agement. I thank them for all the sacriﬁces they have made to ensure that their children
would have freedom and opportunities they never had in Soviet Union. To my sister, Anna,
my brother-in-law, Ilya, and my sweet niece, Talia, I am grateful for bringing me so much
joy and love. To my tireless partner in work and play, tears and laughter, hardship and love,
Anat Caspi, thank you for making me happy next to you.

xi

xii

Contents

Abstract

Acknowledgements

1 Introduction

. .

. .
1.1 Supervised learning . .
1.2 Complex prediction problems .
.
.
1.3 Structured models .
.
1.4 Contributions .
. .
.
1.5 Thesis outline .
. .
.
.
1.6 Previously published work .

.
.
.
.
. .

.
.
.
.
. .

. .
.
.
.
.
.
.
. .

. .
.
.
.
.
.
.
. .

. .
.
.
.
.
.
.
. .

. .
.
.
.
.
.
.
. .

. .

. .

. .

. .

. .

. .
.
.
.
.
.
.
. .

.
.
.
.
.
. .

vii

ix

1
.
.
2
. .
4
.
.
6
.
.
8
. 11
.
. . .
. 13

.
. .
. .
.
. . .
.
.

.
.
.
.
.
.
. . .
.
. .
.
.
. .
.

. .
. .
. .
. .
. .
.
.

.
.
.
.
.
.
.
.
.
.
. .

. .
. .
. .
. .
. .
.
.

15

16
. . 19
. . 20
.
. 21
. . 21
. 22
.

. .
. .
.
.
. .
. .

.
.
.
.
. .
.
.
.
.

. .
. .
.
.
. .
. .

.
.
.
.
. .
.
.
.
.

. .
. .
.
. .
. .

.
.
. .
.
.

I Models and methods

2 Supervised learning

2.1 Classiﬁcation with generalized linear models
.
2.2 Logistic regression .
.
.
2.3 Logistic dual and maximum entropy . .
. .
2.4 Support vector machines .
.
2.5 SVM dual and kernels

. .
.
.

. .
.
.

. .
.
.

. .
.
.

.

.

.

.

.

.

.

.

.

.

. .
.
.

. .
.
.

.
.
.
. .

.
.
.
.
. .
.
.

3 Structured models

3.1 Probabilistic models: generative and conditional . .

.

.

. .

.

.

. .

.

. .

.

24
. 25

xiii

.

3.2 Prediction models: normalized and unnormalized .
.
3.3 Markov networks . .
.
.
.
.
.

.
.
.
3.3.1 Representation . . .
.
.
3.3.2
.
. .
3.3.3 Linear programming MAP inference .
.
.

3.4 Context free grammars .
3.5 Combinatorial problems

.
.
.
.
.
.
.
.
. .
.
.

Inference . . .

.
.
.

.
.
.

.
.
.

.
.
.

.
.
.

.
.
.

.
.
.

.
.

.
.

.
.

.
.

.
.

.

.

.

.

.
.

.
.

.
.

.
.

.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
. .
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
. .
.
.
.
.
.
.
.
.

. .
.
.

. .
.
.

. .
.
.

.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

. 27
. 27
. 28
. 31
. 34
. 37
. 40

42
. 43
. 43
. 48
. 50
. 50
. 52
. 53
. 55

57

58
. 59
.
.
. 61
. . 65
.
. 69
. 70
.
. 73
.
.
. 74

75
. 75
. 78

.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.

4.1 Max-margin estimation .

4 Structured maximum margin estimation
.
.
.

.
.
4.1.1 Min-max formulation .
.
4.1.2 Certiﬁcate formulation .

.
.
.

.

.

.
.
.

.
.
.

.
.
.

4.2 Approximations: upper and lower bounds .

4.2.1 Constraint generation .
.
4.2.2 Constraint strengthening .
.
.

4.3 Related work .
4.4 Conclusion . .

. . .
.
. .

.
.

.
.

.
.

.
.

.
.

.
.

.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
. .
. .
.
. .
.
.
.
.
.
.

. .
.
.
.
.
.
.
.
.
.
.
.
.
.
.

II Markov networks

5 Markov networks

5.1 Maximum likelihood estimation .
.
5.2 Maximum margin estimation .
.
. .
. .
5.3 M3N dual and kernels . .
5.4 Untriangulated models
.
.
.
.
.
.
.
.
.
.
5.5 Generalization bound .
.
.
.
.
.
.
5.6 Related work .
5.7 Conclusion . .
.
.
.
.
.
.

. . .
.
. .

.
.
.
.
.

.
.
.
.
. .
.
.
.
.
.
.
.
.

.
.
.
.
. .
.
.
.
.
.
.
.
.

.
.
.
.
. .
.
.
.
.
.
.
.
.

. .
. .
. .
.
.
.
.
.
.
.
.

6 M3N algorithms and experiments
. .
.
. . .

6.1 Solving the M3N QP .
.

SMO .

6.1.1

. .

.

. .
.
.

.
.

.
.

.
.

. .
.
.

.
.

.
.

.
.

.
.

xiv

6.1.2
6.1.3

.
Selecting SMO pairs .
.
.
.
Structured SMO .
.
.
.
.
. .
. .
.
.
.
.

. .
.
. . .

.
.
. .
.
.

.
.
.

.

6.2 Experiments .
6.3 Related work . .
6.4 Conclusion .

.
.
.
.
.
.
. .
.
.

.
.
.
.
.
.
. .
.
.

. .
. .
. .
.
. .
. .
. .
.
.
.
.
.
.
.
. .
. .
. .
.
.
.
.
.
.

.
.
. .
.
.
. .

.

7 Associative Markov networks
.
.
.
.
. .

7.3.1 Graph construction .
7.3.2 Multi-class case .
. .

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
. .
. .
. .
. .
.
.
.
.
.
.
.
. .
. .
. .
. .

7.1 Associative networks .
. .
7.2 LP Inference .
.
.
. .
7.3 Min-cut inference .

. .
.
.
.
.
.
. .
.
.
.
.
.
. .
.
. .
. .
.
. .
. .
. .
.
.
.
.
.
.
. .
.
. .
. .
. .
. .
. .
. .
7.4 Max-margin estimation . .
. .
.
.
.
.
.
.
.
7.5 Experiments .
.
.
.
.
.
.
.
. .
. .
. .
. .
. .
. .
. .
7.6 Related work . .
.
.
. .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
7.7 Conclusion .

. .
.
. . .

.
.
. .
.
.

.
.
.

.

8 Relational Markov networks

.

. .

. .

. .

. .

. .

. .

. .

. .

8.1 Relational classiﬁcation . .
8.2 Relational Markov networks
. .
8.3 Approximate inference and learning .
.
.
.
8.4 Experiments .
.
.
.
.
.
.
. .
. .
. .
. .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
. .
. .
. .
. .
. .
.
.
.
.
.
.
.
.
.
.

.
Flat models .
8.4.1
8.4.2 Link model
.
8.4.3 Cocite model
.
.

8.5 Related work . .
8.6 Conclusion .

.
.
.
.
. .
. .
. .
.
.

.
. . .

. .
. .
.
.
.
.
.
.
. .
. . .
. .
. .

. .

.
. .
. .
.
.
.
. .
.
. .
. .
.
.
.
. .
.
.
.
. .

. .
.
.

. .

. .

. .

. .

. .
.
.

.
.
.
.
.
.
. .
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
. .
.
.

.
.
. .
.
.
.
.
.
.
.
.
.
.
. .
.
.

.
.
.
.
. .

. .
.
.
. .
.
. .
. . .

.
.
.
.
. .
.
. .

. .
.

. 79
.
.
. . 81
.
. 85
.
.
. .
. 87
. 87
.
.

89
. . 90
.
. .
.
. 91
.
. .
.
. 93
. . .
. . 93
.
.
.
. . 95
.
.
.
. . 97
.
. .
. 99
.
. .
.
. .
.
. 104
. 104
.
.
. .

.
. .
.
.
. . .
.
.
. .
.
.
.
.
.
.
. .
.
. .
.
. .
. .
.
. .
. . .

. .
.

. .
.
.
. .
.
. .
.
.
. .
.
.
. .
. .
. .
. .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
. .
. .
.
.
. .
.
. . .

.
. .
.
.
.
.
.
. .
.
.

109
. . 110
.
. 113
. . 116
. 118
.
.
. 119
. . 120
. . 121
. 123
. 124

III Broader applications: parsing, matching, clustering

9 Context free grammars

9.1 Context free grammar model

.

. .

. .

. .

. .

. .

.

. .

.

.

. .

.

.

. .

.

127

128
. . 128

xv

.

.

.

.

.

.
.

.
.

.
.

.
.

.
9.2 Context free parsing .
9.3 Discriminative parsing models .

.
.
9.3.1 Maximum likelihood estimation .
.
9.3.2 Maximum margin estimation .
.
.
.
.
.
.
.
.

9.4 Structured SMO for CFGs
9.5 Experiments . .
.
.
9.6 Related work .
9.7 Conclusion . .
.

. .
.
. . .
.
. .

.
.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.

.
.
.

10 Matchings

.

10.1 Disulﬁde connectivity prediction .
.
.
10.2 Learning to match .
.
.
10.3 Min-max formulation .
.
10.4 Certiﬁcate formulation .
.
.
.
10.5 Kernels
.
.
.
10.6 Experiments . .
10.7 Related work .
.
.
.
.
10.8 Conclusion . .

. . .
.
. .
. . .
. .
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.

. .

.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

11 Correlation clustering

.
.
.
.
. .
. .
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

. .
. .
.
.
.
.
.
.
.
.
.
.
.
.

. .
. .
. .
.
.
.
.
.
.
.
.
.
.

.

.

.

.

.

.

.

.

.

.

.
.
. .

11.1 Clustering formulation .

. .
.
.
.
11.1.1 Linear programming relaxation .
.
11.1.2 Semideﬁnite programming relaxation .
.
.
. .
.
.
.
.
.
.
.
.
.
.
.
.

11.2 Learning formulation .
.
11.3 Dual formulation and kernels .
.
11.4 Experiments . .
.
.
.
.
11.4.1 Irrelevant features
11.4.2 Email clustering . .
.
11.4.3 Image segmentation .
.
.

11.5 Related work .
11.6 Conclusion . .

. . .
. .
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

. .

.
.

.
.

.
.

.
.

.

.

.

.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.

. 132
. 133
. 134
. 135
. 138
. 138
. 142
. 143

144
. 145
. 146
. 148
. 150
. 153
. 154
. 157
. 159

160
. 161
. 162
. 163
. 164
. 167
. 168
. 168
. 168
. 170
. 172
. 173

xvi

IV Conclusions and future directions

175

12 Conclusions and future directions
.

12.1 Summary of contributions

12.2 Extensions and open problems .

. .

. .

.
.

. .

. .

. .

. .

. .

. .

.
. .

. .
.
.

.
12.1.1 Structured maximum margin estimation .
.
12.1.2 Markov networks: max-margin, associative, relational
.
12.1.3 Broader applications: parsing, matching, clustering .
.
.
.
.
. .
.
.
.
.
. . .
.

. .
12.2.1 Theoretical analysis and optimization algorithms .
.
12.2.2 Novel prediction tasks
.
12.2.3 More general learning settings .
.
. .

. .
. .
. .
.
.
.
.
.
. .
. .
.

.
. .
. .

. . .

. .

. .

. .

. .

. .

.

.
.
.

.

.

.

.

. .

.

.

.

. .

.

.
.

176
. . 176
. 177
.
.
. 180
.
. 182
. . 183
.
. 183
.
. 184
. . 185
. 187

. .
.
.
.
.
.
.
. .
.
.
.
.
.
.
.
. .

. .
.
.
.
.
.
.
.
.
.
.
. .
.
.
.
.
.
.
.
.
. .
.
. .

12.3 Future . .

.
.
.
.
.
.
.

188
. 188
.
. . 189
. . 190
. . 195
. 195
.
.
. 197
. 199
.

202

A Proofs and derivations

.

.

.

.
.
. .
. .

A.1 Proof of Theorem 5.5.1 .

.
.
.
A.1.1 Binary classiﬁcation . .
. .
A.1.2 Structured classiﬁcation . .

. .
.
.
. .
. .
.
.
A.2.1 Binary AMNs .
. .
.
.
A.2.2 Multi-class AMNs
.
A.2.3 Derivation of the factored primal and dual max-margin QP .

A.2 AMN proofs and derivations .
. .
.
.

.
. . .
. .
.
.
.
.
.
.
.
.
. .
.
.
.
.
. .
.
.

. .
.
.
.
.
. .
.
.
. .
.

.
.
.
. .
. .
. .

.
.
.
.
.
.
. .
.
. .

.
.
.
.
. .

. .
. .
.
.

. .
. .
.
.

. .
. .
.
.

.
.
. .
. .

.
.
.
.
.
.

.
.
.
.
.
.

Bibliography

xvii

.
.

.

.
.

.

.
.

.

.
.

.

. .
.
.

.

.

.
.

.

.
.

.

.
.

.

.
.

.

.
.

.

.
.

.

.
.

.

.
.

.

.
.

.

.
.

.

.
.

.

.
.

.

.
.

.

. 140
. 140

. 156

List of Tables

9.1 Parsing results on development set
.
9.2 Parsing results on test set

.

.

.

.

.
.

.
.

10.1 Bond connectivity prediction results .

xviii

List of Figures

1.1 Supervised learning setting . .
1.2 Examples of complex prediction problems .

. .

. .

. .

. .

. .

. .

.
. .

2.1 Handwritten character recognition . .
2.2 Classiﬁcation loss and upper bounds .

. .
.
.

. .
.
.

. .
.

.
. .

.

3.1 Handwritten word recognition .
.
3.2 Chain Markov network .
.
.
3.3 Diamond Markov network .
. .
3.4 Diamond network junction tree .
3.5 Marginal agreement . .
3.6 Example parse tree . .

. .
. .

. .
. .

. .
. .
. .
. .
. .
.
.
.
.
.
.
.
.
.
.
. .
. .
. .
. .
. .
.
.
.
.
.
.
.
.
.
.
.
. .
. .
. .
. .
. .
. .
. .
. .
. .
. .
.

. .
.
.

. .
.
.

.
.
. .
.
.
. .
. .
. .

.
.
. .

.
.
. .

. .
.
.
. .
.
.
.
.
.
.

. .
.
.

. .
.
.

.
.
. .
.
.
. .
. .
. .

.
.
. .

.
.
. .

. .
.

.
. .

. .
.
.

3
4

. .
.

.
. .

. . 19
. 20
.

.

. .
.
. .
.
.
.
.
.
.

.
. .
.
.
. .
.
. .
.

. . .
. .
. .
. .
. . .

. 25
. 29
. 32
. . 34
. 35
. 37

4.1 Exact and approximate constraints for max-margin estimation .
4.2 A constraint generation algorithm.
.

. .

. .

. .

. .

. .

. .

.

.

.

.
.

5.1 Chain M3N example
. .
5.2 Diamond Markov network .

.

.

. .
. .

.
. .

. .

. .

. .

. .

. .

. .

. .

. .

. .
.

. .
.

. .

. .
.

. .
.

.
. .

. .
. .

.
.
. .

.
.

. . 51
. . 52

.
.
. .

. 64
. 69

. .
6.1 Block-coordinate ascent . .
.
.
.
6.2 SMO subproblem .
.
.
.
6.3 SMO pair selection .
.
.
6.4 Structured SMO diagram .
.
6.5 Structured SMO pair selection .
.
.
.
6.6 OCR results .

. .
.
.
.
.
.
.

. . .

.
.

.
.

.

.

.

.

.

.

. .
.
.
.
.
.
.
.
.
.
.

. .
.
.
.
.
.
.
.
.
.
.

. .
.
.
.
.
.
.
.
.
.
.

.
. .
.
.
.
. .
.
.
.
.
.
.
.
.
.
.

. .
. .
.
.
. .
. .
. .

.
.
.
.
. .
.
.
.
.
.
.

. .
. .
.
.
. .
. .
. .

.
.
. .
. .
. .
. .
.
.
.
. .
.
.
. .
. . .
.

.
.
. .
.
.
.

. . 77
.
. 79
. . 80
. . 82
. . 85
. 86
.

xix

.
.

.
.

.
.
. .

.
.
. .

.
.
. .

.
.
. .

.
.
. .

.
.
. .

3D laser scan range map of the Stanford Quad.

. 94
.
.
.
7.1 Min-cut graph construction .
. 96
. .
7.2 α-expansion algorithm .
.
. .
. 100
.
.
7.3 Segbot: roving robot equipped with SICK2 laser sensors.
. 101
.
.
7.4
.
.
. 102
.
.
.
7.5 Comparison of terrain classiﬁcation models (detail) .
. 103
.
.
7.6 Min-cut inference running times .
.
.
7.7 Comparison of terrain classiﬁcation models (zoomed-out) .
. 106
.
7.8 Labeled portion of the test terrain dataset (Ground truth and SVM predictions)107
7.9 Labeled portion of the test terrain dataset (Voted-SVM and AMN predictions)108

.
.
. .
.
.
.
.
.
.
.
.
.
.

.
.
. .
.
.
.
.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.

.
.
.

.

.

.

.

.

.

.

.

.

.

.

.
.
.
.

.

.
.
.

.
.
.
.

.
.
.
.

.

.
.
.

.
.
.
.

.
.
.
.

.

.
.
.

.
.
.
.

.
.
.
.

.

.
.
.

.
.
.
.

.
.
.
.

.

.
.
.

.
.
.
.

.
.
.
.

.

.
.
.

.
.
.
.

.
.
.
.

.

.
.
.

.
.
.
.

.
.
.
.

.

.
.
.

.
.
.
.

.
.
.
.

.

.
.
.

.
.
.
.

.
.
.
.

.

.
.
.

.
.
.
.

.
.
.
.

.

.
.
.

.
.
.
.

.
.
.
.

.

.
.
.

.
.
.
.

.
.
.
.

.

.
.
.

.
.
.
.

. 113
. 120
. 121
. 122

. 130

. 147
. 150
. 157

. 169
. 170
. 171
. 172

8.1 Link model for document classiﬁcation .
.
8.2 WebKB results: ﬂat models .
.
.
8.3 WebKB results: link model .
.
8.4 WebKB results: cocite model .
.

.
.
.

.
.
.

.
.
.

.
.
.

.
.
.

.
.
.
.

9.1 Two representations of a binary parse tree .

.
.
.
.

.

.
.
. .
. .
.
.

. .

.
.
.
10.1 PDB protein 1ANS .
10.2 Number of constraints vs. number of bonds
. .
10.3 Learning curve for bond connectivity prediction .

.
.

.

.

.

.

.

.

.

.

.

.

.

11.1 Learning to cluster with irrelevant features .
.
11.2 Learning to organize email
.
11.3 Two segmentations by different users .
.
.
11.4 Two segmentations by different models

.
.
.

.
.

.

.

.

.

.

.
.
.
.

. .
. .
.
.
. .

xx

Chapter 1

Introduction

The breadth of tasks addressed by machine learning is rapidly expanding. Major appli-
cations include medical diagnosis, scientiﬁc discovery, ﬁnancial analysis, fraud detection,
DNA sequence analysis, speech and handwriting recognition, game playing, image analy-
sis, robot locomotion and many more. Of course, the list of things we would like a computer
to learn to do is much, much longer. As we work our way down that list, we encounter the
need for very sophisticated decision making from our programs.

Some tasks, for example, handwriting recognition, are performed almost effortlessly
by a person, but remain difﬁcult and error-prone for computers. The complex synthesis
of many levels of signal processing a person executes when confronted by a line of hand-
written text is daunting. The reconstruction of an entire sentence from the photons hitting
the retina off of each tiny patch of an image undoubtedly requires an elaborate interplay of
recognition and representation of the pen-strokes, the individual letters, whole words and
constituent phrases.

Computer scientists, as opposed to, say, neuroscientists, are primarily concerned with
achieving acceptable speed and accuracy of recognition rather than modeling this compli-
cated process with any biological verity. Computational models for handwriting recogni-
tion aim to capture the salient properties of the problem: typical shapes of the letters, likely
letter combinations that make up words, common ways to combine words into phrases, fre-
quent grammatical constructions of the phrases, etc. Machine learning offers an alternative
to encoding all the intricate details of such a model from scratch. One of its primary goals

1

2

CHAPTER1. INTRODUCTION

is to devise efﬁcient algorithms for training computers to automatically acquire effective
and accurate models from experience.

In this thesis, we present a discriminative learning framework and a novel family of efﬁ-
cient models and algorithms for complex recognition tasks in several disciplines, including
natural language processing, computer vision and computational biology. We develop the-
oretical foundations for our approach and show a wide range of experimental applications,
including handwriting recognition, 3-dimensional terrain classiﬁcation, disulﬁde connec-
tivity in protein structure prediction, hypertext categorization, natural language parsing,
email organization and image segmentation.

1.1 Supervised learning

The most basic supervised learning task is classiﬁcation. Suppose we wish to learn to
recognize a handwritten character from a scanned image. This is a classiﬁcation task,
because we must assigns a class (an English letter from ‘a’ through ‘z’) to an observation of
an object (an image). Essentially, a classiﬁer is a function that maps an input (an image) to
an output (a letter). In the supervised learning setting, we construct a classiﬁer by observing
labeled training examples, in our case, sample images paired with appropriate letters. The
main problem addressed by supervised learning is generalization. The learning program is
allowed to observe only a small sample of labeled images to produce an accurate classiﬁer
on unseen images of letters.

More formally, let x denote an input. For example, a black-and-white image x can be
represented as a vector of pixel intensities. We use X to denote the space of all possible
inputs. Let y denote the output, and Y be the discrete space of possible outcomes (e.g.,
26 letters ‘a’-‘z’). A classiﬁer (or hypothesis) h is a function from X to Y, h : X (cid:55)→ Y.
We denote the set of all classiﬁers that our learning program can produce as H (hypothesis
class). Then given a set of labeled examples {x(i), y(i)}, i = 1, . . . , m, a learning program
seeks to produce a classiﬁer h ∈ H that will work well on unseen examples x, usually by
ﬁnding h that accurately classiﬁes training data. The diagram in Fig. 1.1 summarizes the
supervised learning setting.

1.1. SUPERVISEDLEARNING

3

Figure 1.1: Supervised learning setting

The problem of classiﬁcation has a long history and highly developed theory and prac-
tice (see for example, Mitchell [1997]; Vapnik [1995]; Duda et al. [2000]; Hastie et al.
[2001]). The two most important dimensions of variation of classiﬁcation algorithms is the
hypothesis class H and the criterion for selection of a hypothesis h from H given the train-
ing data. In this thesis, we build upon the generalized linear model family, which underlies
standard classiﬁers such as logistic regression and support vector machines. Through the
use of kernels to implicitly deﬁne high-dimensional and even inﬁnite-dimensional input
representations, generalized linear models can approximate arbitrarily complex decision
boundaries.

The task of selecting a hypothesis h reduces to estimating model parameters. Broadly
speaking, probabilistic estimation methods associate a joint distribution p(x, y) or condi-
tional distribution p(y | x) with h and select a model based on the likelihood of the data
[Hastie et al., 2001]. Joint distribution models are often called generative, while condi-
tional models are called discriminative. Large margin methods, by contrast, select a model
based on a more direct measure of conﬁdence of its predictions on the training data called
the margin [Vapnik, 1995]. The difference between these two methods is one of the key

Labeled dataLearningPredictionHypothesesNew data4

CHAPTER1. INTRODUCTION

Figure 1.2: Examples of complex prediction problems (inputs-top, outputs-bottom):
(a) handwriting recognition [image (cid:55)→ word];
(b) natural language parsing [sentence (cid:55)→ parse tree];
(c) disulﬁde bond prediction in proteins [amino-acid sequence (cid:55)→ bond structure (shown in yellow)];
(d) terrain segmentation [3D image (cid:55)→ segmented objects (trees, bushes, buildings, ground)]

themes in this thesis.

Most of the research has focused on the analysis and classiﬁcation algorithms for the
case of binary outcomes |Y| = 2, or a small number of classes. In this work, we focus
on prediction tasks that involve not a single decision with a small set of outcomes, but a
complex, interrelated collection of decisions.

1.2 Complex prediction problems

Consider once more the problem of character recognition. In fact, a more natural and useful
task is recognizing words and entire sentences. Fig. 1.2(a) shows an example handwritten
word “brace.” Distinguishing between the second letter and fourth letter (‘r’ and ‘c’) in iso-
lation is actually far from trivial, but in the context of the surrounding letters that together
form a word, this task is much less error-prone for humans and should be for computers
as well. It is also more complicated, as different decisions must be weighed against each
other to arrive at the globally satisfactory prediction. The space of all possible outcomes

The screen was a sea of redRSCCPCYWGGCPWGQNCYPEGCSGPKVbrace(a)(b)(c)(d)1.2. COMPLEXPREDICTIONPROBLEMS

5

Y is immense, usually exponential in the number of individual decisions, for example, the
number of 5 letter sequences (265). However, most of these outcomes are unlikely given
the observed input. By capturing the most salient structure of the problem, for example the
strong local correlations between consecutive letters, we will construct compact models
that efﬁciently deal with this complexity. Below we list several examples from different
ﬁelds.

• Natural language processing

Vast amounts of electronically available text have spurred a tremendous amount of
research into automatic analysis and processing of natural language. We mention
some of the lower-level tasks that have received a lot of recent attention [Charniak,
1993; Manning & Sch¨utze, 1999]. Part-of-speech tagging involves assigning each
word in a sentence a part-of-speech tag, such as noun, verb, pronoun, etc. As with
handwriting recognition, capturing sequential structure of correlations between con-
secutive tags is key. In parsing, the goal is to recognize the recursive phrase structure
of a sentence, such as verbal, noun and prepositional phrases and their nesting in
relation to each other. Fig. 1.2(b) shows a parse tree corresponding to the sentence:
“The screen was a sea of red” (more on this in Ch. 9). Many other problems, such as
named-entity and relation extraction, text summarization, translation, involve com-
plex global decision making.

• Computational biology

The last two decades have yielded a wealth of high-throughput experimental data,
including complete sequencing of many genomes, precise measurements of protein
3D structure, genome-wide assays of mRNA levels and protein-protein interactions.
Major research has been devoted to gene-ﬁnding, alignment of sequences, protein
structure prediction, molecular pathway discovery [Gusﬁeld, 1997; Durbin et al.,
1998]. Fig. 1.2(c) shows disulﬁde bond structure (shown in yellow) we would like to
predict from the amino-acid sequence of the protein (more on this in Ch. 10).

• Computer vision

As digital cameras and optical scanners become commonplace accessories, medical
imaging technology produces detailed physiological measurements, laser scanners

6

CHAPTER1. INTRODUCTION

capture 3D environments, satellites and telescopes bring pictures of Earth and distant
stars, we are ﬂooded with images we would like our computer to analyze. Example
tasks include object detection and segmentation, motion tracking, 3D reconstruction
from stereo and video, and much more [Forsyth & Ponce, 2002]. Fig. 1.2(d) shows a
3D laser range data image of the Stanford campus collected by a roving robot which
we would like to segment into objects such as trees, bushes, buildings, ground, etc.
(more on this in Ch. 7).

1.3 Structured models

This wide range of problems have been tackled using various models and methods. We
focus on the models that compactly capture correlation and constraint structure inherent to
many tasks. Abstractly, a model assigns a score (or likelihood in probabilistic models) to
each possible input/output pair (x, y), typically through a compact, parameterized scoring
function. Inference in these models refers to computing the highest scoring output given
the input and usually involves dynamic programming or combinatorial optimization.

• Markov networks

Markov networks (a.k.a. Markov random ﬁelds) are extensively used to model com-
plex sequential, spatial, and relational interactions in prediction problems arising in
many ﬁelds. These problems involve labeling a set of related objects that exhibit
local consistency. Markov networks compactly represent complex joint distributions
of the label variables by modeling their local interactions. Such models are encoded
by a graph, whose nodes represent the different object labels, and whose edges rep-
resent and quantify direct dependencies between them. The graphical structure of
the models encodes the qualitative aspects of the distribution: direct dependencies as
well as conditional independencies. The quantitative aspect of the model is deﬁned
by the potentials that are associated with nodes and cliques of the graph. The graph-
ical structure of the network (more precisely, the treewidth of the graph, which we
formally deﬁne in Ch. 3) is critical to efﬁcient inference and learning in the model.

• Context free grammars

1.3. STRUCTUREDMODELS

7

Context-free grammars are one of the primary formalisms for capturing the recur-
sive structure of syntactic constructions [Manning & Sch¨utze, 1999]. For example,
in Fig. 1.2, the non-terminal symbols (labels of internal nodes) correspond to syntac-
tic categories such as noun phrase (NP), verbal phrase (VP) or prepositional phrase
(PP) and part-of-speech tags like nouns (NN), verbs (VBD), determiners (DT) and
prepositions (IN). The terminal symbols (leaves) are the words of the sentence. A
CFG consists of recursive productions (e.g. V P → V P P P , DT → The) that
can be applied to derive a sentence of the language. The productions deﬁne the set
of syntactically allowed phrase structures (derivations). By compactly deﬁning a
probability distribution over individual productions, probabilistic CFGs construct a
distribution over parse trees and sentences, and the prediction task reduces to ﬁnding
the most likely tree given the sentence. The context free restriction allows efﬁcient
inference and learning in such models.

• Combinatorial structures

Many important computational tasks are formulated as combinatorial optimization
problems such as the maximum weight bipartite and perfect matching, spanning
tree, graph-cut, edge-cover, and many others [Lawler, 1976; Papadimitriou & Stei-
glitz, 1982; Cormen et al., 2001]. Although the term ‘model’ is often reserved for
probabilistic models, we use the term model very broadly, to include any scheme
that assigns scores to the output space Y and has a procedure for ﬁnding the opti-
mal scoring y. For example, the disulﬁde connectivity prediction in Fig. 1.2(c) can
be modeled by maximum weight perfect matchings, where the weights deﬁne po-
tential bond strength based on the local amino-acid sequence properties. The other
combinatorial structures we consider and apply in this thesis include graph cuts and
partitions, bipartite matchings, and spanning trees.

The standard methods of estimation for Markov networks and context free grammars
are based on maximum likelihood, both joint and conditional. However, maximum like-
lihood estimation of scoring function parameters for combinatorial structures is often in-
tractable because of the problem of deﬁning a normalized distribution over an exponential
set of combinatorial structures.

8

CHAPTER1. INTRODUCTION

1.4 Contributions

This thesis addresses the problem of efﬁcient learning of high-accuracy models for complex
prediction problems. We consider a very large class of structured models, from Markov
networks to context free grammars to combinatorial graph structures such as matchings
and cuts. We focus on those models where exact inference is tractable, or can be efﬁciently
approximated.

◦ Learning framework for structured models

We propose a general framework for efﬁcient estimation of models for structured
prediction. An alternative to likelihood-based methods, this framework builds upon
the large margin estimation principle. Intuitively, we ﬁnd parameters such that in-
ference in the model (dynamic programming, combinatorial optimization) predicts
the correct answers on the training data with maximum conﬁdence. We develop gen-
eral conditions under which exact large margin estimation is tractable and present
two formulations for structured max-margin estimation that deﬁne compact convex
optimization problems, taking advantage of prediction task structure. The ﬁrst for-
mulation relies on the ability to express inference in the model as a compact convex
optimization problem. The second one only requires compactly expressing optimal-
ity of a given assignment according to the model and applies to a broader range of
combinatorial problems. These two formulations form the foundation which the rest
of the thesis develops.

◦ Markov networks

The largest portion of the thesis is devoted to novel estimation algorithms, represen-
tational extensions, generalization analysis and experimental validation for Markov
networks, a model class of choice in many structured prediction tasks in language,
vision and biology.

(cid:46) Low-treewidth Markov networks

We use graph decomposition to derive an exact, compact, convex learning for-
mulation for Markov networks with sequence and other low-treewidth structure.
The seamless integration of kernels with graphical models allows us to create

1.4. CONTRIBUTIONS

9

very rich models that leverage the immense amount of research in kernel de-
sign and graphical model decompositions for efﬁcient, accurate prediction in
real-world tasks. We also use approximate graph decomposition to derive a
compact approximate formulation for Markov networks in which inference is
intractable.

(cid:46) Scalable online algorithm

We present an efﬁcient algorithm for solving the estimation problem called
Structured SMO. Our online-style algorithm uses inference in the model and
analytic updates to solve extremely large estimation problems.

(cid:46) Generalization analysis

We analyze the theoretical generalization properties of max-margin estimation
in Markov networks and derive a novel margin-based bound for structured pre-
diction. This bound is the ﬁrst to address structured error (e.g. proportion
of mislabeled pixels in an image) and uses a proof that exploits the graphical
model structure.

(cid:46) Learning associative Markov networks (AMNs)

We deﬁne an important subclass of Markov networks that captures positive cor-
relations present in many domains. We show that for AMNs over binary vari-
ables, our framework allows exact estimation of networks of arbitrary connec-
tivity and topology, for which likelihood methods are believed to be intractable.
For the non-binary case, we provide an approximation that works well in prac-
tice. We present an AMN-based method for object segmentation from 3D range
data. By constraining the class of Markov networks to AMNs, our models are
learned efﬁciently and, at run-time, scale up to tens of millions of nodes and
edges.

(cid:46) Representation and learning of relational Markov networks

We introduce relational Markov networks (RMNs), which compactly deﬁne
templates for Markov networks for domains with relational structure objects,

10

CHAPTER1. INTRODUCTION

attributes, relations. The graphical structure of an RMN is based on the rela-
tional structure of the domain, and can easily model complex interaction pat-
terns over related entities. We use approximate inference in these complex mod-
els, in which exact inference is intractable, to derive an approximate learning
formulation. We apply this class of models to classiﬁcation of hypertext using
hyperlink structure to deﬁne relations between webpages.

◦ Broader applications: parsing, matching, clustering

The other large portion the thesis addresses a range of prediction tasks with very di-
verse models: context free grammars for natural language parsing, perfect matchings
for disulﬁde connectivity in protein structure prediction, graph partitions for cluster-
ing documents and segmenting images.

(cid:46) Learning to parse

We exploit context free grammar structure to derive a compact max-margin
formulation and show high-accuracy parsing in cubic time by exploiting novel
kinds of lexical information. We show experimental evidence of the model’s
improved performance over several baseline models.

(cid:46) Learning to match

We use combinatorial properties of weighted matchings to develop an exact,
efﬁcient algorithm for learning to match. We apply our framework to predic-
tion of disulﬁde connectivity in proteins using perfect non-bipartite matchings.
The algorithm we propose uses kernels, which makes it possible to efﬁciently
embed the features in very high-dimensional spaces and achieve state-of-the-art
accuracy.

(cid:46) Learning to cluster

We derive a max-margin formulation for learning the afﬁnity metric for clus-
tering from clustered training data. In contrast to algorithms that learn a metric
independently of the algorithm that will be used to cluster the data, we describe
a formulation that tightly integrates metric learning with the clustering algo-
rithm, tuning one to the other in a joint optimization. Experiments on synthetic
and real-world data show the ability of the algorithm to learn an appropriate

1.5. THESISOUTLINE

11

clustering metric for a variety of desired clusterings, including email folder or-
ganization and image segmentation.

1.5 Thesis outline

Below is a summary of the rest of the chapters in the thesis:

Chapter 2. Supervised learning: We review basic deﬁnitions and statistical framework
for classiﬁcation. We deﬁne hypothesis classes, loss functions, risk. We consider
generalized linear models, including logistic regression and support vector machines,
and review estimation methods based on maximizing likelihood, conditional likeli-
hood and margin. We describe the relationship between the dual estimation problems
and kernels.

Chapter 3. Structured models: In this chapter, we deﬁne the abstract class of structured
prediction problems and models addressed by the thesis. We compare probabilistic
models, generative and discriminative and unnormalized models. We describe repre-
sentation and inference for Markov networks, including dynamic and linear program-
ming inference. We also brieﬂy describe context free grammars and combinatorial
structures as models.

Chapter 4. Structured maximum margin estimation: This chapter outlines the main prin-

ciples of maximum margin estimation for structured models. We address the expo-
nential blow-up of the naive problem formulation by deriving two general equivalent
convex formulation. These formulations, min-max and certiﬁcate, allow us to ex-
ploit decomposition and combinatorial structure of the prediction task. They lead
to polynomial size programs for estimation of models where the prediction problem
is tractable. We also discuss approximations, in particular using upper and lower
bounds, for solving intractable or very large problems.

Chapter 5. Markov networks: We review maximum conditional likelihood estimation
and present maximum margin estimation for Markov networks. We use graphical
model decomposition to derive a convex, compact formulation that seamlessly in-
tegrates kernels with graphical models. We analyze the theoretical generalization

12

CHAPTER1. INTRODUCTION

properties of max-margin estimation and derive a novel margin-based bound for
structured classiﬁcation.

Chapter 6. M3N algorithms and experiments: We present an efﬁcient algorithm for solv-
ing the estimation problem in graphical models, called Structured SMO. Our online-
style algorithm uses inference in the model and analytic updates to solve extremely
large quadratic problems. We present experiments with handwriting recognition,
where our models signiﬁcantly outperform other approaches by effectively capturing
correlation between adjacent letters and incorporating high-dimensional input repre-
sentation via kernels.

Chapter 7. Associative Markov networks: We deﬁne an important subclass of Markov
networks, associative Markov networks (AMNs), that captures positive interactions
present in many domains. We show that for associative Markov networks of over bi-
nary variables, max-margin estimation allows exact training of networks of arbitrary
connectivity and topology, for which maximum likelihood methods are believed to
be intractable. For the non-binary case, we provide an approximation that works
well in practice. We present an AMN-based method for object segmentation from
3D range data that scales to very large prediction tasks involving tens of millions of
points.

Chapter 8. Relational Markov networks: We introduce the framework of relational Mar-
kov networks (RMNs), which compactly deﬁnes templates for Markov networks in
domains with rich structure modeled by objects, attributes and relations. The graph-
ical structure of an RMN is based on the relational structure of the domain, and can
easily model complex patterns over related entities. As we show, the use of an undi-
rected, discriminative graphical model avoids the difﬁculties of deﬁning a coherent
generative model for graph structures in directed models and allows us tremendous
ﬂexibility in representing complex patterns. We provide experimental results on a
webpage classiﬁcation task, showing that accuracy can be signiﬁcantly improved by
modeling relational dependencies.

Chapter 9. Context free grammars: We present max-margin estimation for natural lan-
guage parsing on the decomposition properties of context free grammars. We show

1.6. PREVIOUSLYPUBLISHEDWORK

13

that this framework allows high-accuracy parsing in cubic time by exploiting novel
kinds of lexical information. We show experimental evidence of the model’s im-
proved performance over several baseline models.

Chapter 10. Perfect matchings: We apply our framework to learning to predict disulﬁde
connectivity in proteins using perfect matchings. We use combinatorial properties of
weighted matchings to develop an exact, efﬁcient algorithm for learning the param-
eters of the model. The algorithm we propose uses kernels, which makes it possible
to efﬁciently embed the features in very high-dimensional spaces and achieve state-
of-the-art accuracy.

Chapter 11. Correlation clustering: In this chapter, we derive a max-margin formula-
tion for learning afﬁnity scores for correlation clustering from clustered training data.
We formulate the approximate learning problem as a compact convex program with
quadratic objective and linear or positive-semideﬁnite constraints. Experiments on
synthetic and real-world data show the ability of the algorithm to learn an appro-
priate clustering metric for a variety of desired clusterings, including email folder
organization and image segmentation.

Chapter 12. Conclusions and future directions: We review the main contributions of the
thesis and summarize their signiﬁcance, applicability and limitations. We discuss ex-
tensions and future research directions not addressed in the thesis.

1.6 Previously published work

Some of the work described in this thesis has been published in conference proceedings.
The min-max and certiﬁcate formulations for structured max-margin estimation have not
been published in their general form outlined in Ch. 4, although they underly several pa-
pers mentioned below. The polynomial formulation of maximum margin Markov networks
presented in Ch. 5 was published for a less general case, using a dual decomposition tech-
nique [Taskar et al., 2003a]. Work on associative Markov networks (Ch. 7) was published
with experiments on hypertext and news-wire classiﬁcation [Taskar et al., 2004a]. A paper

14

CHAPTER1. INTRODUCTION

on 3D object segmentation using AMNs, which presents a experiments on terrain classiﬁ-
cation and other tasks, is currently under review (joint work with Drago Anguelov, Vassil
Chatalbashev, Dinkar Gupta, Geremy Heitz, Daphne Koller and Andrew Ng). Taskar et al.
[2002] and Taskar et al.
[2003b] deﬁned and applied the Relational Markov networks
(Ch. 8), using maximum (conditional) likelihood estimation. Natural language parsing
in Ch. 9 was published in Taskar et al. [2004b]. Disulﬁde connectivity prediction using
perfect matchings in Ch. 10 (joint work with Vassil Chatalbashev and Daphne Koller) is
currently under review. Finally, work on correlation clustering in Ch. 11, done jointly with
Pieter Abbeel and Andrew Ng, has not been published.

Part I

Models and methods

15

Chapter 2

Supervised learning

In supervised learning, we seek a function h : X (cid:55)→ Y that maps inputs x ∈ X to outputs
y ∈ Y. The input space X is an arbitrary set (often X = IRn), while the output space Y
we consider in this chapter discrete. A supervised learning problem with discrete outputs,
Y = {y1, . . . , yk}, where k is the number of classes, is called classiﬁcation. In handwritten
character recognition, for example, X is the set of images of letters and Y is the alphabet
(see Fig. 2.1).

The input to an algorithm is training data, a set of m i.i.d. (independent and identically
distributed) samples S = {(x(i), y(i))}m
i=1 drawn from a ﬁxed but unknown distribution D
over X × Y. The goal of a learning algorithm is to output a hypothesis h such that h(x)
will approximate y on new samples from the distribution (x, y) ∼ D.

Learning algorithms can be distinguished among several dimensions, chief among them
is the hypothesis class H of functions h the algorithm outputs. Numerous classes of func-
tions have been well studied, including decision trees, neural networks, nearest-neighbors,
generalized log-linear models and kernel methods (see Quinlan [2001]; Bishop [1995];
Hastie et al. [2001]; Duda et al. [2000], for in-depth discussion of these and many other
models). We will concentrate on the last two classes, for several reasons we discuss be-
low, including accuracy, efﬁciency, and extensibility to more complex structured prediction
tasks will consider in the next chapter.

The second crucial dimension of a learning algorithm is the criterion for selection of h
from H. We arrive at such a criterion by quantifying what it means for h(x) to approximate

16

y. The risk functional R(cid:96)

D[(h)] measures the expected error of the approximation:

R(cid:96)
D[h] = E(x,y)∼D[(cid:96)(x, y, h(x))],

17

(2.1)

where the loss function (cid:96) : X × Y × Y → IR+ measures the penalty for predicting h(x)
on the sample (x, y). In general, we assume that (cid:96)(x, y, ˆy) = 0 if y = ˆy.

A common loss function for classiﬁcation is 0/1 loss

(cid:96)0/1(x, y, h(x)) ≡ 1I(y (cid:54)= h(x)),

where 1I(·) denotes the indicator function, that is, 1I(true) = 1 and 1I(false) = 0.

Since we do not generally know the distribution D, we estimate the risk of h using its

empirical risk R(cid:96)

S, computed on the training sample S:

m(cid:88)

i=1

R(cid:96)
S[h] =

1
m

(cid:96)(x(i), y(i), h(x(i))) =

1
m

m(cid:88)

i=1

(cid:96)i(h(x(i))),

(2.2)

where we abbreviate (cid:96)(x(i), y(i), h(x(i))) = (cid:96)i(h(x(i))). For 0/1 loss, R(cid:96)
proportion of training examples that h misclassiﬁes. R(cid:96)
error or training loss.

S[h] is simply the
S[h] is often called the training

If our set of hypotheses, H, is large enough, we will be able to ﬁnd h that has zero or

very small empirical risk. However, simply selecting a hypothesis with lowest risk

h∗ = arg min

h∈H

R(cid:96)
S[h],

is generally not a good idea. For example, if X = IR,Y = IR and H includes all polynomi-
als of degree m − 1, we can always ﬁnd a polynomial h that passes through all the sample
points (x(i), y(i)), i = (1, ..., m) assuming that all the x(i) are unique. This polynomial is
very likely to overﬁt the training data, that is, it will have zero empirical risk, but high ac-
tual risk. The key to selecting a good hypothesis is to trade-off complexity of class H (e.g.
the degree of the polynomial) with the error on the training data as measured by empirical
risk R(cid:96)
S. For a vast majority of supervised learning algorithms, this fundamental balance is

18

CHAPTER2. SUPERVISEDLEARNING

achieved by minimizing the weighted combination of the two criteria:

(cid:161)D[h] + CR(cid:96)

(cid:162)

h∗ = arg min

h∈H

S[h]

,

(2.3)

where D[h] measures the inherent dimension or complexity of h, and C ≥ 0 is a trade-
off parameter. We will not go into derivation of various complexity measures D[h] here,
but simply adopt the standard measures as needed and refer the reader to Vapnik [1995];
[2001] for details. The term D[h] is often called
Devroye et al.
regularization.

[1996]; Hastie et al.

Depending on the complexity of the class H, the search for the optimal h∗ in (2.3)
may be a daunting task1. For many classes, for example decision trees and multi-layer
neural networks, it is intractable [Bishop, 1995; Quinlan, 2001], and we must resort to
approximate, greedy optimization methods. For these intractable classes, the search pro-
cedure used by the learning algorithm is crucial. Below however, we will concentrate on
models where the optimal h∗ can be found efﬁciently using convex optimization in poly-
nomial time. Hence, the learning algorithms we consider are completely characterized by
the hypothesis class H, the loss function (cid:96), and the regularization D[h].

In general, we consider hypothesis classes of the following parametric form:

hw(x) = arg max

y∈Y

f (w, x, y),

(2.4)

where f (w, x, y) is a function f : W ×X ×Y (cid:55)→ IR, where w ∈ W is a set of parameters,
usually with W ⊆ IRn. We assume that ties in the arg max are broken using some arbitrary
but ﬁxed rule. As we discuss below, this class of hypotheses is very rich and includes
many standard models. The formulation in (2.4) of the hypothesis class in terms of an
optimization procedure will become crucial to extending supervised learning techniques to
cases where the output space Y is more complex.

1For classiﬁcation, minimizing the objective with the usual 0/1 training error is generally a very difﬁcult
problem with multiple maxima for most realistic H. See discussion in the next section about approaches to
dealing with 0/1 loss.

2.1. CLASSIFICATIONWITHGENERALIZEDLINEARMODELS

19

a

b

c

d

e

Figure 2.1: Handwritten character recognition: sample letters from Kassel [1995] data set.

2.1 Classiﬁcation with generalized linear models

For classiﬁcation, we consider the generalized linear family of hypotheses H. Given n
real-valued basis functions fj : X × Y (cid:55)→ IR, a hypothesis hw ∈ H is deﬁned by a set of n
coefﬁcients wj ∈ IR such that:

n(cid:88)

i=1

hw(x) = arg max

y∈Y

wjfj(x, y) = arg max

y∈Y

w(cid:62)f (x, y).

(2.5)

Consider the character recognition example in Fig. 2.1. Our input x is a vector of
pixel values of the image and y is the alphabet {a, . . . , z}. We might have a basis function
fj(x, y) = 1I(xrow,col = on ∧ y = char) for each possible (row, col) and char ∈ Y,
where xrow,col denotes the value of pixel (row, col). Since different letters tend to have
different pixels turned on, this very simple model captures enough information to perform
reasonably well.

The most common loss for classiﬁcation is 0/1 loss. Minimizing the 0/1 risk is generally
a very difﬁcult problem with multiple maxima for any large class H. The standard solution
is minimizing an upper bound on the 0/1 loss, (cid:96)(x, y, h(x)) ≥ (cid:96)(x, y, h(x)). (In addition
to computational advantages of this approach, there are statistical beneﬁts of minimizing a
convex upper bound [Bartlett et al., 2003]). Two of the primary classiﬁcation methods we
consider, logistic regression and support vector machines, differ primarily in their choice of
the upper bound on the training 0/1 loss. The regularization D[hw] for the linear family is
typically the norm of the parameters ||w||p for p = 1, 2. Intuitively, a zero, or small weight
wj implies that the hypothesis hw does not depend on the value of fj(x, y) and hence is
simpler than a hw with a large weight wj.

20

CHAPTER2. SUPERVISEDLEARNING

Figure 2.2: 0/1-loss upper bounded by log-loss and hinge-loss. Horizontal axis shows
w(cid:62)f (x, y) − maxy(cid:48)(cid:54)=y w(cid:62)f (x, y(cid:48)), where y is the correct label for x, while the vertical axis
show the value of the associated loss. The log-loss is shown up to an additive constant for
illustration purposes.

2.2 Logistic regression

In logistic regression, we assign a probabilistic interpretation to the hypothesis hw as deﬁn-
ing a conditional distribution:

Pw(y | x) =

1

exp{w(cid:62)f (x, y)},

Zw(x)

(cid:80)
y∈Y exp{w(cid:62)f (x, y)}. The optimal weights are selected by maximiz-
where Zw(x) =
ing the conditional likelihood of the data (minimizing the log-loss) with some regulariza-
tion. This approach is called the (regularized) maximum likelihood estimation. Common
choices for regularization are 1 or 2-norm regularization on the weights; we use 2-norm
below:

(2.6)

log Zw(x(i)) − w(cid:62)f (x(i), y(i)),

(2.7)

min

||w||2 + C

1
2

(cid:88)

i

where C is a user-speciﬁed constant the determines the trade-off between regularization
and likelihood of the data. The log-loss log Zw(x) − w(cid:62)f (x, y) is an upper bound (up to a
constant) on the 0/1 loss (cid:96)0/1 (see Fig. 2.2).

−2−1.5−1−0.500.511.5200.511.522.533.5log−loss  hinge−loss0/1−loss  2.3. LOGISTICDUALANDMAXIMUMENTROPY

21

2.3 Logistic dual and maximum entropy

The objective function is convex in the parameters w, so we have an unconstrained (differ-
entiable) convex optimization problem. The gradient with respect to w is given by:

w + C

Ei,w[fi(x(i), y)] − fi(x(i), y(i)) = w − C

Ei,w[∆fi(y)],

(cid:88)

i

(cid:88)
(cid:80)

i

y f (y)Pw(y | x(i)) is the expectation under the conditional distribu-
where Ei,w[f (y)] =
tion Pw(y | x(i)) and ∆fi(y) = f (x(i), y(i)) − f (x(i), y). Ignoring the regularization term,
the gradient is zero when the basis function expectations are equal to the basis functions
evaluated on the labels y(i). It can be shown [Cover & Thomas, 1991] that the dual of the
maximum likelihood problem (without regularization) is the maximum entropy problem:

(cid:88)

max

s.t.

Pw(y | x(i)) log Pw(y | x(i))

−
Ei,w[∆fi(y)] = 0, ∀i.

i,y

(2.8)

We can interpret logistic regression as trying to match the empirical basis function expec-
tations while maintaining a high entropy conditional distribution Pw(y | x).

2.4 Support vector machines

Support vector machines [Vapnik, 1995] select the weights based on the “margin” of con-
ﬁdence of hw. In the multi-class SVM formulation [Weston & Watkins, 1998; Crammer &
Singer, 2001], the margin on example i quantiﬁes by how much the true label “wins” over
the wrong ones:

γi =

1
||w|| min
y(cid:54)=y(i)

w(cid:62)f (x(i), y(i)) − w(cid:62)f (x(i), y) =

1
||w|| min
y(cid:54)=y(i)

w(cid:62)∆fi(y),

22

CHAPTER2. SUPERVISEDLEARNING

where ∆fi(y) = f (x(i), y(i))− f (x(i), y). Maximizing the smallest such margin (and allow-
ing for negative margins) is equivalent to solving the following quadratic program:

min

s.t.

||w||2 + C
1
2
w(cid:62)∆fi(y) ≥ (cid:96)0/1(y) − ξi, ∀i, ∀y ∈ Y.

ξi

i

(2.9)

(cid:88)

(cid:88)

i

Note that the slack variable ξi is constrained to be positive in the above program since
(y) − w(cid:62)∆fi(y),
w(cid:62)∆fi(y(i)) = 0 and (cid:96)0/1(y(i)) = 0. We can also express ξi as maxy (cid:96)0/1
and the optimization problem Eq. (2.9) in a form similar to Eq. (2.7):

i

min

||w||2 + C

1
2

max

y

[(cid:96)0/1

i

(y) − w(cid:62)∆fi(y)].

(2.10)

The hinge-loss maxy[(cid:96)0/1
(see Fig. 2.2).

i

(y) − w(cid:62)∆fi(y)] is also an upper bound on the 0/1 loss (cid:96)0/1

2.5 SVM dual and kernels

The form of the dual of Eq. (2.9) is crucial to efﬁcient solution of SVM and the ability to
use a high or even inﬁnite dimensional set of basis functions via kernels.

(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)
(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)(cid:88)

i,y

(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)

(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)2

max

s.t.

αi(y)(cid:96)0/1

i

(y) − 1
2

αi(y) = C, ∀i;

αi(y) ≥ 0, ∀i, y.

αi(y)∆fi(y)

(2.11)

(cid:88)
(cid:88)

i,y

y

In the dual, the αi(y) variables correspond to the w(cid:62)∆fi(y) ≥ (cid:96)0/1(y)−ξi constraints in the
primal Eq. (2.9). The solution to the dual α∗ gives the solution to the primal as a weighted
combination of basis functions of examples:

(cid:88)

i,y

w∗ =

α∗
i (y)∆fi(y).

(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)

(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)(cid:88)

i,y

(cid:88)

(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)

(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)2

(cid:88)

(cid:88)

i,y

j,¯y

(cid:88)

2.5. SVMDUALANDKERNELS

23

The pairings of examples and incorrect labels, (i, y), that have non-zero α∗
support vectors.

i (y), are called

An important feature of the dual formulation is that the basis functions f appear only as

dot products. Expanding the quadratic term, we have:

αi(y)∆fi(y)

=

αi(y)αj(¯y)∆fi(y)(cid:62)∆fj(¯y).

Hence, as long as the dot product f (x, y)(cid:62)f (¯x, ¯y) can be computed efﬁciently, we can
solve Eq. (2.11) independently of the actual dimension of f. Note that at classiﬁcation
time, we also do not need to worry about the dimension of f since:

w(cid:62)f (x, ¯y) =

αi(y)∆fi(y)(cid:62)f (x, ¯y) =

αi(y)[f (x(i), y(i))(cid:62)f (x, ¯y)−f (x(i), y)(cid:62)f (x, ¯y)].

i,y

i,y

For example, we might have basis functions that are polynomial of degree d in terms of
image pixels, fj(x, y) = 1I(xrow1,col1 = on ∧ . . . ∧ xrowd,cold = on ∧ y = char) for each
possible (row1, col1) . . . (rowd, cold) and char ∈ Y. Computing this polynomial kernel
can be done independently of the dimension d, even though the number of basis functions
grows exponentially with d [Vapnik, 1995].

In fact, logistic regression can also be kernelized. However, the hinge loss formulation
usually produces sparse solutions in terms of the number of support vectors, while solutions
to the corresponding kernelized log-loss problem are generally non-sparse (all examples
are support vectors) and require approximations for even relatively small datasets [Wahba
et al., 1993; Zhu & Hastie, 2001].

Chapter 3

Structured models

Consider once more the problem of character recognition. In fact, a more natural and useful
task is recognizing words and entire sentences. Fig. 3.1 shows an example handwritten
word “brace.” Distinguishing between the second letter and fourth letter (‘r’ and ‘c’) in
isolation is far from trivial, but in the context of the surrounding letters that together form
a word, this task is much less error-prone for humans and should be for computers as well.

In this chapter, we consider prediction problems in which the output is not a single
discrete value y, but a set of values y = (y1, . . . , yL), for example an entire sequence
of L characters. For concreteness, let the number of variables L be ﬁxed. The output
space Y ⊆ Y1 × . . . × YL we consider is a subset of product of output spaces of single
variables. In word recognition, each Yj is the alphabet, while Y is the dictionary. This
joint output space is often a proper subset of the product of singleton output spaces, Y ⊂
Y1×. . .×YL. In word recognition, we might restrict that the letter ‘q’ never follows by ‘z’ in
English. In addition to “hard” constraints, the output variables are often highly correlated,
e.g. consecutive letters in a word. We refer to joint spaces with constraints and correlations
as structured. We call problems with discrete output spaces structured classiﬁcation or
structured prediction. Structured models we consider in this chapter (and thesis) predict
the outputs jointly, respecting the constraints and exploiting the correlations in the output
space.

The range of prediction problems these broad deﬁnitions encompass is immense, aris-
ing in ﬁelds as diverse as natural language analysis, machine vision, and computational

24

3.1. PROBABILISTICMODELS:GENERATIVEANDCONDITIONAL

25

b r

a

c

e

Figure 3.1: Handwritten word recognition: sample from Kassel [1995] data set.

biology, to name a few. The class of structured models H we consider is essentially of the
same form as in previous chapter, except that y has been replaced by y:

hw(x) = arg max
y : g(x,y)≤0

w(cid:62)f (x, y),

(3.1)

where as before f (x, y) is a vector of functions f : X × Y (cid:55)→ IRn. The output space
Y = {y : g(x, y) ≤ 0} is deﬁned using a vector of functions g(x, y) that deﬁne the
constraints, where g : X × Y (cid:55)→ IRk. This formulation is very general. Clearly, for
many f , g pairs, ﬁnding the optimal y is intractable. For the most part, we will restrict our
attention to models where this optimization problem can be solved in polynomial time. This
includes, for example, probabilistic models like Markov networks (in certain cases) and
context-free grammars, combinatorial optimization problems like min-cut and matching,
convex optimization such as linear, quadratic and semi-deﬁnite programming.
In other
cases, like intractable Markov networks (Ch. 8) and correlation clustering (Ch. 11), we use
an approximate polynomial time optimization procedure.

3.1 Probabilistic models: generative and conditional

The term model is often reserved for probabilistic models, which can be subdivided into
generative and conditional with respect to the prediction task. A generative model assigns
a normalized joint density p(x, y) to the input and output space X × Y with

(cid:90)

(cid:88)

p(x, y) ≥ 0,

p(x, y) = 1.

y∈Y

x∈X

26

CHAPTER3. STRUCTUREDMODELS

A conditional model assigns a normalized density p(y | x) only over the output space Y
with

p(y | x) = 1

∀x ∈ X .

p(y | x) ≥ 0,

(cid:88)

y∈Y

Probabilistic interpretation of the model offers well-understood semantics and an im-
mense toolbox of methods for inference and learning. It also provides an intuitive measure
of conﬁdence in the predictions of a model in terms of conditional probabilities. In addi-
tion, generative models are typically structured to allow very efﬁcient maximum likelihood
learning. A very common class of generative models is the exponential family:

p(x, y) ∝ exp{w(cid:62)f (x, y)}.

For exponential families, the maximum likelihood parameters w with respect to the joint
distribution can be computed in closed form using the empirical basis function expectations
ES[f (x, y)] [DeGroot, 1970; Hastie et al., 2001].

Of course, this efﬁciency comes at a price. Any model is an approximation to the true
distribution underlying the data. A generative model must make simplifying assumptions
(more precisely, independence assumptions) about the entire p(x, y), while a conditional
model makes many fewer assumption by focusing on p(y | y). Because of this, by opti-
mizing the model to ﬁt the joint distribution p(x, y), we may be tuning the approximation
away from optimal conditional distribution p(y | x), which we use to make the predictions.
Given sufﬁcient data, the conditional model will learn the best approximation to p(y | x)
possible using w, while the generative model p(x, y) will not necessarily do so. Typically,
however, generative models actually need fewer samples to converge to a good estimate of
the joint distribution than conditional models need to accurately represent the conditional
distribution. In a regime with very few training samples (relative to the number of param-
eters w), generative models may actually outperform conditional models [Ng & Jordan,
2001].

3.2. PREDICTIONMODELS:NORMALIZEDANDUNNORMALIZED

27

3.2 Prediction models: normalized and unnormalized

Probabilistic semantics are certainly not necessary for a good predictive model if we are
simply interested in the optimal prediction (the arg max in Eq. (3.1)). As we discussed
in the previous chapter, support vector machines, which do not represent a conditional
distribution, typically perform as well or better than logistic regression [Vapnik, 1995;
Cristianini & Shawe-Taylor, 2000].

In general, we can often achieve higher accuracy models when we do not learn a nor-
malized distribution over the outputs, but concentrate on the margin or decision boundary,
the difference between the optimal y and the rest. Even more importantly, in many cases
we discuss below, normalizing the model (summing over the entire Y) is intractable, while
the optimal y can be found in polynomial time. This fact makes standard maximum like-
lihood estimation infeasible. The learning methods we advocate in this thesis circumvent
this problem by requiring only the maximization problem to be tractable. We still heav-
ily rely on the representation and inference tools familiar from probabilistic models for
the construction of and prediction in unnormalized models, but largely dispense with the
probabilistic interpretation when needed. Essentially, we use the term model very broadly,
to include any scheme that assigns scores to the output space Y and has a procedure for
ﬁnding the optimal scoring y.

In this chapter, we review basic concepts in probabilistic graphical models called Mar-
kov networks or Markov random ﬁelds. We also brieﬂy touch upon examples of context-free
grammars and combinatorial problems that will be explained in greater detail in Part III to
illustrate the range of prediction problems we address.

3.3 Markov networks

Markov networks provide a framework for a rich family of models for both discrete and
continuous prediction [Pearl, 1988; Cowell et al., 1999]. The models treat the inputs and
outputs as random variables X with domain X and Y with domain Y and compactly de-
ﬁne a conditional density p(Y | X) or distribution P (Y | X) (we concentrate here on the

28

CHAPTER3. STRUCTUREDMODELS

conditional Markov networks or CRFs [Lafferty et al., 2001]). The advantage of a graphi-
cal framework is that it can exploit sparseness in the correlations between outputs Y . The
graphical structure of the models encodes the qualitative aspects of the distribution: direct
dependencies as well as conditional independencies. The quantitative aspect of the model
is deﬁned by the potentials that are associated with nodes and cliques of the graph. Before
a formal deﬁnition, consider a ﬁrst-order Markov chain a model for the word recognition
task. In Fig. 3.2, the nodes are associated with output variables Yi and the edges correspond
to direct dependencies or correlations. We do not explicitly represent the inputs X in the
ﬁgure. For example, the model encodes that Yj is conditionally independent of the rest of
the variables given Yj−1, Yj+1. Intuitively, adjacent letters in a word are highly correlated,
but the ﬁrst-order model is making the assertion (which is certainly an approximation) that
once the value of a letter Yj is known, the correlation between a letter Yb before j and a
letter Ya after j is negligible. More precisely, we use a model where

P (Yb | Yj, Ya, x) = P (Yb | Yj, x), P (Ya | Yj, Yb, x) = P (Ya | Yj, x),

b < j < a.

For the purposes of ﬁnding the most likely y, this conditional independence property means
that the optimization problem is decomposable: given that Yj = yj, it sufﬁces to separately
ﬁnd the optimal subsequence from 1 to j ending with yj, and the optimal subsequence
starting with yj from j to L.

3.3.1 Representation
The structure of a Markov network is deﬁned by an undirected graph G = (V,E), where
the nodes are associated with variables V = {Y1, . . . , YL}. A clique is a set of nodes c ⊆ V
that form a fully connected subgraph (every two nodes are connected by an edge). Note that
each subclique of a clique is also a clique, and we consider each node a singleton clique.
In the chain network in Fig. 3.2, the cliques are simply the nodes and the edges: C(G) =
{{Y1}, . . . ,{Y5},{Y1, Y2}, . . . ,{Y4, Y5}}. We denote the set of variables in a clique c as
Yc, an assignment of variables in the clique as yc and the space of all assignments to
the clique as Yc. We focus on discrete output spaces Y below, but many of the same
representation and inference concepts translate to continuous domains. No assumption is

3.3. MARKOVNETWORKS

29

Figure 3.2: First-order Markov chain: φi(Yi) are node potentials, φi,i+1(Yi, Yi+1) are edge
potentials (dependence on x is not shown).

made about X .
Deﬁnition 3.3.1 A Markov network is deﬁned by an undirected graph G = (V,E) and a
set of potentials Φ = {φc}. The nodes are associated with variables V = {Y1, . . . , YL}.
Each clique c ∈ C(G) is associated with a potential φc(x, yc) with φc : X × Yc (cid:55)→ IR+,
which speciﬁes a non-negative value for each assignment yc to variables in Yc and any
input x. The Markov network (G, Φ) deﬁnes a conditional distribution:

(cid:89)

P (y | x) =

1

φc(x, yc),

Z(x)

c∈C(G)

where C(G) is the set of all the cliques of the graph and Z(x) is the partition function
given by Z(x) =

c∈C(G) φc(x, yc).

y∈Y

(cid:80)

(cid:81)

In our example Fig. 3.2, we have node and edge potentials. Intuitively, the node poten-
tials quantify the correlation between the input x and the value of the node, while the edge
potentials quantify the correlation between the pair of adjacent output variables as well as
the input x. Potentials do not have a local probabilistic interpretation, but can be thought
of as deﬁning an unnormalized score for each assignment in the clique. Conditioned on
the image input, appropriate node potentials in our network should give high scores to the
correct letters (‘b’,‘r’,‘a’,‘c’,‘e’), though perhaps there would be some ambiguity with the
second and fourth letter. For simplicity, assume that the edge potentials would not depend

30

CHAPTER3. STRUCTUREDMODELS

on the images, but simply should give high scores to pairs of letters that tend to appear often
consecutively. Multiplied together, these scores should favor the correct output “brace”.

In fact, a Markov network is a generalized log-linear model, since the potentials φc(xc, yc)

could be represented (in log-space) as a sum of basis functions over x, yc:

φc(xc, yc) = exp

wc,kfc,k(x, yc)

= exp

(cid:35)

(cid:163)

(cid:164)

w(cid:62)
c fc(x, yc)

(cid:34)
nc(cid:88)

k=1

(cid:88)

c∈C(G)

where nc is the number of basis functions for the clique c. Hence the log of the conditional
probability is given by:

log P (y | x) =

c fc(x, yc) − log Zw(x).
w(cid:62)

In case of node potentials for word recognition, we could use the same basis functions as
for individual character recognition: fj,k(x, yj) = 1I(xj,row,col = on ∧ yj = char) for each
possible (row, col) in xj, the window of the image that corresponds to letter j and each
char ∈ Yj (we assume the input has been segmented into images xj that correspond to
letters). In general, we condition a clique only on a portion of the input x, which we denote
as xc. For the edge potentials, we can deﬁne basis functions for each combination of letters
(assume for simplicity no dependence on x) : fj,j+1,k(x, yj, yj+1) = 1I(yj = char1∧yj+1 =
char2) for each char1 ∈ Yj and char2 ∈ Yj+1. In this problem (as well as many others),
we are likely to “tie” or “share” the parameters of the model wc across cliques. Usually, all
single node potentials would share the same weights and basis functions (albeit the relevant
portion of the input xc is different) and similarly for the pairwise cliques, no matter in what
position they appear in the sequence.1

With slight abuse of notation, we stack all basis functions into one vector f. For the
sequence model, f has node functions and edge functions, so when c is a node, the edge
functions in f (xc, yc) are deﬁned to evaluate to zero. Similarly, when c is an edge, the node

1Sometimes we might actually want some dependence on the position in the sequence, which can be

accomplished by adding more basis functions that condition on the position of the clique.

3.3. MARKOVNETWORKS

31

functions in f (xc, yc) are also deﬁned to evaluate to zero. Now we can write:

(cid:88)

c∈C(G)

f (x, y) =

f (xc, yc).

We stack the weights in the corresponding manner, so the most likely assignment according
to the model is given by:

arg max

y∈Y

log Pw(y | x) = arg max

y∈Y

w(cid:62)f (x, y),

in the same form as Eq. (3.1).

3.3.2 Inference

There are several important questions that can be answered by probabilistic models. The
task of ﬁnding the most likely assignment, known as maximum a-posteriori (MAP) or most
likely explanation (MPE), is just one of such questions, but most relevant to our discussion.
The Viterbi dynamic programming algorithm solves this problem for chain networks in
O(L) time. Let the highest score of any subsequence from 1 to k > 1 ending with value yk
be deﬁned as

φ∗
k(yk) = max
y1..k−1

φj(x, yj)φj(x, yj−1, yj).

(cid:89)

j

The algorithm computes the highest scores recursively:

φ∗
1(y1) = φ1(x, y1),
φ∗
k(yk) = max

yk−1∈Yk−1

∀y1 ∈ Y1;
φ∗
k−1(yk−1)φj(x, yk)φj(x, yk−1, yk),

1 < k ≤ L, ∀yk ∈ Yk.

The highest scoring sequence has score maxyL φ∗
L(yL). Using the arg max’s of the max’s in
the computation of φ∗, we can back-trace the highest scoring sequence itself. We assume
that score ties are broken in a predetermined way, say according to some lexicographic
order of the symbols.

32

CHAPTER3. STRUCTUREDMODELS

Figure 3.3: Diamond Markov network (added triangulation edge is dashed).

In general Markov networks, MAP inference is NP-hard [Cowell et al., 1999]. How-
ever, there are several important subclasses of networks that allow polynomial time infer-
ence. The most important of these is the class of networks with low tree-width. We need the
concept of triangulation (or chordality) to formally deﬁne tree-width. Recall that a cycle
of length l in an undirected graph G is a sequence of nodes (v0, v1, . . . , vl), distinct except
that v0 = vl, which are connected by edges (vi, vi+1) ∈ G. A chord of this cycle is an edge
(vi, vj) ∈ G between non-consecutive nodes.
Deﬁnition 3.3.2 (Triangulated graph) An undirected graph G is triangulated if every one
of its cycles of length ≥ 4 possesses a chord.

Singly-connected graphs, like chains and trees, are triangulated since they contain no cy-
cles. The simplest untriangulated network is the diamond in Fig. 3.3. To triangulate it,
we can add the edge (Y1, Y3) or (Y2, Y4). In general, there are many possible sets of edges
that can be added to triangulate a graph. The inference procedure creates a tree of cliques
using the graph augmented by triangulation. The critical property of a triangulation for the
inference procedure is the size of the largest clique.
Deﬁnition 3.3.3 (Tree-width of a graph) The tree-width of a triangulated graph G is the
size of its largest clique minus 1. The tree-width of an untriangulated graph G is the
minimum tree-width of all triangulations of G.

3.3. MARKOVNETWORKS

33

The tree-width of a chain or a tree is 1 and the tree-width of Fig. 3.3 is 2. Finding the mini-
mum tree-width triangulation of a general graph is NP-hard, but good heuristic algorithms
exist [Cowell et al., 1999].

The inference procedure is based on a data structure called junction tree that can be
constructed for a triangulated graph. The junction tree is an alternative representation of
the same distribution that allows simple dynamic programming inference similar to the
Viterbi algorithm for chains.

Deﬁnition 3.3.4 (Junction tree) A junction tree T = (V,E) for a triangulated graph G is
a tree in which the nodes are a subset of the cliques of the graph, V ⊆ C(G) and the edges
E satisfy the running intersection property: for any two cliques c and c(cid:48), the variables in
the intersection c ∩ c(cid:48) are contained in the clique of every node of the tree on the (unique)
path between c and c(cid:48).

Fig. 3.4 shows a junction tree for the diamond network. Each of the original clique poten-
tials must associated with exactly one node in the junction tree. For example, the potentials
for the {Y1, Y3, Y4} and {Y1, Y3, Y4} nodes are the product of the associated clique poten-
tials:

φ134(Y1, Y3, Y4) = φ1(Y1)φ4(Y4)φ14(Y1, Y4)φ34(Y3, Y4),

φ123(Y1, Y2, Y3) = φ2(Y2)φ3(Y3)φ12(Y1, Y2)φ23(Y2, Y3).

Algorithms for constructing junction trees from triangulated graphs are described in detail
in Cowell et al. [1999].

The Viterbi algorithm for junction trees picks an arbitrary root r for the tree T and
proceeds recursively from the leaves to compute the highest scoring subtree at a node by
combining the subtrees with highest score from its children. We denote the leaves of the
tree as Lv(T ) and the children of node c (relative to the root r) as Chr(c):

(cid:89)

c(cid:48)∈Chr(c)

φ∗
l (yl) = φl(x, yl),
φ∗
c(yc) = φc(x, yc)

∀l ∈ Lv(T ), ∀yl ∈ Yl;

φ∗
c(cid:48)(yc(cid:48)),

max
yc(cid:48)∼yc

∀c ∈ V(T ) \ Lv(T ), ∀yc ∈ Yc,

34

CHAPTER3. STRUCTUREDMODELS

Figure 3.4: Diamond network junction tree. Each of the original potentials is associated
with a node in the tree.

where yc(cid:48) ∼ yc denotes whether the partial assignment yc is consistent with the partial
assignment yc(cid:48) on the variables in the intersection of c and c(cid:48). The highest score is given by
maxyr φ∗
r(yr). Using the arg max’s of the max’s in the computation of φ∗, we can back-
trace the highest scoring assignment itself. Note that this algorithm is exponential in the
tree-width, the size of the largest clique. Similar type of computations using the junction
tree can be used to compute the partition function Zw(x) (by simply replacing max by
)
as well as marginal probabilities P (yc|x) for the cliques of the graph [Cowell et al., 1999].

(cid:80)

3.3.3 Linear programming MAP inference

In this section, we present an alternative inference method based on linear programming.
Although solving the MAP inference using a general LP solver is less efﬁcient than the
dynamic programming algorithms above, this formulation is crucial in viewing Markov
networks in a uniﬁed framework of the structured models we consider and to our develop-
ment of common estimation methods in later chapters. Let us begin with a linear integer
program to compute the optimal assignment y. We represent an assignment as a set binary
variables µc(yc), one for each clique c and each value of the clique yc, that denotes whether
the assignment has that value, such that:

(cid:89)

(cid:88)

c

c,yc

log

φc(x, yc) =

µc(yc) log φc(x, yc).

3.3. MARKOVNETWORKS

35

Figure 3.5: Example of marginal agreement: row sums of µ12(y1, y2) agree with µ1(y1),
column sums agree with µ2(y2).

We call these variables marginals, as they correspond to the marginals of a distribution that
has all of its mass centered on the MAP instantiation (assuming it is unique). There are
several elementary constraints that such marginals satisfy. First, they must sum to one for
each clique. Second, the marginals for cliques that share variables are consistent. For any
clique c ∈ C and a subclique s ⊂ c, the assignment of the subclique, µs(ys), must be
consistent with the assignment of the clique, µc(yc). Together, these constraints deﬁne a
linear integer program:

(cid:88)
(cid:88)

c,yc

max

s.t.

yc

µs(ys) =

(cid:88)

c∼ys
y(cid:48)

µc(yc) log φc(x, yc)

(3.2)

µc(yc) = 1, ∀c ∈ C;

µc(yc) ∈ {0, 1}, ∀c ∈ C, ∀yc;

µc(y(cid:48)
c),

∀s, c ∈ C, s ⊂ c, ∀ys.

For example, in case the network is a chain or a tree, we will have node and edge marginals
that sum to 1 and agree with each other as in Fig. 3.5.

Clearly, for any assignment y(cid:48), we can deﬁne µc(yc) variables that satisfy the above
c = yc). We can also show that converse is true: any

constraints by setting µc(yc) = 1I(y(cid:48)
valid setting of µc(yc) corresponds to a valid assignment y. In fact,

00000010000000000000001000000000010001000010001036

CHAPTER3. STRUCTUREDMODELS

Lemma 3.3.5 For a triangulated network with unique MAP assignment, the integrality
constraint in the integer program in Eq. (3.2) can be relaxed and the resulting LP is guar-
anteed to have integer solutions.

A proof of this lemma appears in Wainwright et al. [2002]. Intuitively, the constraints force
the marginals µc(yc) to correspond to some valid joint distribution over the assignments.
The optimal distribution with the respect to the objective puts all its mass on the MAP
assignment.
If the MAP assignment is not unique, the value of the LP is the same as
the value of the integer program, and any linear combination of the MAP assignments
maximizes the LP.

In case the network is not triangulated, the set of marginals is not guaranteed to rep-
resent a valid distribution. Consider, for example, the diamond network in Fig. 3.3 with
binary variables, with the following edge marginals that are consistent with the constraints:

µ12(0, 0) = µ12(1, 1) = 0.5,

µ12(1, 0) = µ12(0, 1) = 0;

µ23(0, 0) = µ23(1, 1) = 0.5,

µ23(1, 0) = µ23(0, 1) = 0;

µ34(0, 0) = µ34(1, 1) = 0.5,

µ34(1, 0) = µ34(0, 1) = 0;

µ14(0, 0) = µ34(1, 1) = 0,

µ14(1, 0) = µ14(0, 1) = 0.5.

The corresponding node marginals must all be set to 0.5. Note that the edge marginals for
(1, 2), (2, 3), (3, 4) disallow any assignment other than 0000 or 1111, but the edge marginal
for (1, 4) disallows any assignment that has Y1 = Y4. Hence this set of marginals dis-
allows all assignments. If we triangulate the graph and add the cliques {Y1, Y2, Y3} and
{Y1, Y3, Y4} with their corresponding constraints, the above marginals will be disallowed.
In graphs where triangulation produces very large cliques, exact inference is intractable.
We can resort to the above LP without triangulation as an approximate inference procedure
(augmented with some procedure for rounding possibly fractional solutions). In Ch. 7, we
discuss another subclass of networks where MAP inference using LPs is tractable for any
network topology, but with a restricted type of potentials.

3.4. CONTEXTFREEGRAMMARS

37

Figure 3.6: Example parse tree from Penn Treebank [Marcus et al., 1993].

3.4 Context free grammars

Context-free grammars are one of the primary formalisms for capturing the recursive struc-
ture of syntactic constructions [Manning & Sch¨utze, 1999]. For example, Fig. 3.6 shows
a parse tree for the sentence The screen was a sea of red. This tree is from the Penn Tree-
bank [Marcus et al., 1993], a primary linguistic resource for expert-annotated English text.
The non-terminal symbols (labels of internal nodes) correspond to syntactic categories such
as noun phrase (NP), verbal phrase (VP) or prepositional phrase (PP) and part-of-speech
tags like nouns (NN), verbs (VBD), determiners (DT) and prepositions (IN). The terminal
symbols (leaves) are the words of the sentence.

For clarity of presentation, we restrict our grammars to be in Chomsky normal form2(CNF),

where all rules in the grammar are of the form: A → B C and A → D, where A, B and C
are non-terminal symbols, and D is a terminal symbol.
Deﬁnition 3.4.1 (CFG) A CFG G consists of:

◦ A set of non-terminal symbols, N
◦ A designated set of start symbols, NS ⊆ N
2Any CFG can be represented by another CFG in CNF that generates the same set of sentences.

38

CHAPTER3. STRUCTUREDMODELS

◦ A set of terminal symbols, T
◦ A set of productions, P = {PB,PU}, divided into

(cid:46) Binary productions, PB = {A → B C : A, B, C ∈ N} and
(cid:46) Unary productions, PU = {A → D : A ∈ N , D ∈ T }.

Consider a very simple grammar:

◦ N = {S, NP, VP, PP, NN, VBD, DT, IN}
◦ NS = {S}
◦ T = {The, the, cat, dog, tree, saw, from}
◦ PB = {S → NP VP, NP → DT NN, NP → NP PP, VP → VBD NP,

VP → VP PP, PP → IN NP}.

◦ PU = {DT → The, DT → the, NN → cat, NN → dog, NN → tree, VBD → saw,

IN → from}

A grammar generates a sentence by starting with a symbol in NS and applying the
productions in P to rewrite nonterminal symbols. For example, we can generate The cat
saw the dog by starting with S → NP VP, rewriting the NP as NP → DT NN with DT →
The and NN → cat, then rewriting the VP as VP → VBD NP with VBD → saw, again
using NP → DT NN, but now with DT → the and NN → dog. We can represent such
derivations using trees like in Fig. 3.6 or (more compactly) using bracketed expressions
like the one below:

[[TheDT catNN]NP [sawVBD [theDT dogNN]NP]VP]S .

The simple grammar above can generate sentences of arbitrary length, since it has sev-
eral recursive productions. It can also generate the same sentence several ways. In general,
there are exponentially many parse trees that produce a sentence of length l. Consider the
sentence The cat saw the dog from the tree. The likely analysis of the sentence is that
the cat, sitting in the tree, saw the dog. An unlikely but possible alternative is that the cat

3.4. CONTEXTFREEGRAMMARS

39

actually saw the dog who lived near the tree or was tied to it in the past. Our grammar
allows both interpretations, with the difference being in the analysis of the top-level VP:

[sawVBD [theDT dogNN]NP]VP [[fromIN [theDT treeNN]NP]PP,

sawVBD [[theDT dogNN]NP [fromIN [theDT treeNN]NP]PP]NP.

This kind of ambiguity, called prepositional attachment, is very common in many re-
alistic grammars. A standard approach to resolving ambiguity is to use a PCFG to deﬁne
a joint probability distribution over the space of parse trees Y and sentences X . Standard
PCFG parsers use a Viterbi-style algorithm to compute arg maxy P (x, y) as the most likely
parse tree for a sentence x. The distribution P (x, y) is deﬁned by assigning a probability
to each production and making sure that the sum of probabilities of all productions starting
with a each symbol is 1:

(cid:88)

(cid:88)

P (A → B C) = 1,

P (A → D ) = 1,

∀A ∈ N .

B,C:A→B C∈PB

D:A→D∈PU

(cid:80)

A∈NS

We also need to assign a probability to the different starting symbols P (A) ∈ NS such that
P (A) = 1. The probability of a tree is simply the product of probabilities of the
productions used in the tree (times the probability of the starting symbol). Hence the log-
probability of a tree is a sum of the log-probabilities of its productions. By letting our basis
functions f (x, y) consist of the counts of the productions and w be their log-probabilities,
we can cast PCFG as a structured linear model (in log space). In Ch. 9, we will show how
to represent a parse tree as an assignment of variables Y with appropriate constraints to
express PCFGS (and more generally weighted CFGs) in the form of Eq. (3.1) as

hw(x) = arg max
y : g(x,y)≤0

w(cid:62)f (x, y),

and describe the associated algorithm to compute the highest scoring parse tree y given a
sentence x.

40

CHAPTER3. STRUCTUREDMODELS

3.5 Combinatorial problems

Many important computational tasks are formulated as combinatorial optimization prob-
lems such as the maximum weight bipartite and perfect matching, spanning tree, graph-cut,
edge-cover, bin-packing, and many others [Lawler, 1976; Papadimitriou & Steiglitz, 1982;
Cormen et al., 2001]. These problems arise in applications such as resource allocation,
job assignment, routing, scheduling, network design and many more. In some domains,
the weights of the objective function in the optimization problem are simple and natural
to deﬁne (for example, Euclidian distance or temporal latency), but in many others, con-
structing the weights is an important and labor-intensive design task. Treated abstractly, a
combinatorial space of structures, such as matchings or graph-cuts or trees), together with
a scoring scheme that assigns weights to candidate outputs is a kind of a model.

As a particularly simple and relevant example, consider modeling the task of assigning
reviewers to papers as a maximum weight bipartite matching problem, where the weights
represent the “expertise” of each reviewer for each paper. More speciﬁcally, suppose we
would like to have R reviewers per paper, and that each reviewer be assigned at most P pa-
pers. For each paper and reviewer, we have an a weight qjk indicating the qualiﬁcation level
of reviewer j for evaluating paper k. Our objective is to ﬁnd an assignment for reviewers
to papers that maximizes the total weight. We represent a matching with a set of binary
variables yjk that take the value 1 if reviewer j is assigned to paper k, and 0 otherwise. The
bipartite matching problem can be solved using a combinatorial algorithm or the following
linear program:

(cid:88)
(cid:88)

j,k

max

s.t.

µjkqjk

µjk = R,

(cid:88)

k

µjk ≤ P,

0 ≤ µjk ≤ 1.

(3.3)

j

This LP is guaranteed to produce integer solutions (as long as P and R are integers) for
any weights q(y) [Nemhauser & Wolsey, 1999].

The quality of the solution found depends critically on the choice of weights that de-
ﬁne the objective. A simple scheme could measure the “expertise” as the percent of word

3.5. COMBINATORIALPROBLEMS

41

overlap in the reviewer’s home page and the paper’s abstract. However, we would want to
weight certain words much more (words that are relevant to the subject and infrequent).
Constructing and tuning the weights for a problem is a difﬁcult and time-consuming pro-
cess, just as it is for Markov networks for handwriting recognition.

(cid:80)

As usual, we will represent the objective q(y) as a weighted combination of a set of
basis functions w(cid:62)f (x, y). Let xjk denote the intersection of the set of words occurring in
webpage(j)∩abstract(k), the web page of a reviewer j and the abstract of the paper k. We
jk yjk1I(wordd ∈ xjk), the number of times word d was in both
(cid:80)
can deﬁne fd(x, y) =
the web page of a reviewer and the abstract of the paper that were matched in y. Then the
d wd1I(wordd ∈ xjk), a weighted combination of overlapping
score qjk is simply qjk =
words. In the next chapter we will show how to learn the parameters w in much the same
way we learn the parameters w of a Markov network.

(cid:80)

The space of bipartite matchings illustrates an important property of many structured
spaces: the maximization problem arg maxy∈Y w(cid:62)f (x, y) is easier than the normalization
y∈Y exp{w(cid:62)f (x, y)}. The maximum weight bipartite matching can be found
problem
in polynomial (cubic) time in the number of nodes in the graph using a combinatorial algo-
rithm. However, even simply counting the number of matchings is #P-complete [Valiant,
1979; Garey & Johnson, 1979]. Note that counting is easier than normalization, which is
essentially weighted counting. This fact makes a probabilistic interpretation of the model as
a distribution over matchings intractable to compute. Similarly, exact maximum likelihood
estimation is intractable, since it requires computing the normalization.

Chapter 4

Structured maximum margin estimation

In the previous chapter, we described several important types of structured models of the
form:

(4.1)

hw(x) = arg max
y : g(x,y)≤0

w(cid:62)f (x, y),

where we assume that the optimization problem maxy : g(x,y)≤0 w(cid:62)f (x, y) can be solved
or approximated by a compact convex optimization problem for some convex subset of
parameters w ∈ W. A compact problem formulation is polynomial in the description
length of the objective and the constraints.
Given a sample S = {(x(i), y(i))}m

i=1, we develop methods for ﬁnding parameters w

such that:

w(cid:62)f (x(i), y) ≈ y(i), ∀i,

arg max

y∈Y (i)

where Y (i) = {y : g(x(i), y) ≤ 0}. In this chapter, we describe at an abstract level two
general approaches to structured estimation that we apply in the rest of the thesis. Both of
these approaches deﬁne a convex optimization problem for ﬁnding such parameters w.

There are several reasons to derive compact convex formulations. First and foremost,
we can ﬁnd globally optimal parameters (with ﬁxed precision) in polynomial time. Sec-
ond, we can use standard optimization software to solve the problem. Although special-
purpose algorithms that exploit the structure of a particular problem are often much faster

42

4.1. MAX-MARGINESTIMATION

43

(see Ch. 6), the availability of off-the-shelf software is very important for quick develop-
ment and testing of such models. Third, we can analyze the generalization performance of
the framework without worrying about the actual algorithms used to carry out the optimiza-
tion and the associated woes of intractable optimization problems: local minima, greedy
and heuristic methods, etc.

Our framework applies not only to the standard models typically estimated by prob-
abilistic methods, such as Markov networks and context-free grammars, but also to a
wide range of “unconventional” predictive models. Such models include graph cuts and
weighted matchings, where maximum likelihood estimation is intractable. We provide ex-
act maximum margin solutions for several of these problems (Ch. 7 and Ch. 10).

In prediction problems where the maximization in Eq. (4.1) is intractable, we consider
convex programs that provide only an upper or lower bound on the true solution. We
discuss how to use these approximate solutions for approximate learning of parameters.

4.1 Max-margin estimation

As in the univariate prediction, we measure the error of approximation using a loss func-
tion (cid:96). In structured problems, where we are jointly predicting multiple variables, the loss
is often not just the simple 0-1 loss or squared error. For structured classiﬁcation, a natural
loss function is a kind of Hamming distance between y(i) and h(x(i)): the number of vari-
ables predicted incorrectly. We will explore these and more general loss functions in the
following chapters.

4.1.1 Min-max formulation

Throughout, we will adopt the hinge upper bound (cid:96)i(h(x(i))) on the loss function for struc-
tured classiﬁcation inspired by max-margin criterion:

(cid:96)i(h(x(i))) = max
y∈Y (i)

[w(cid:62)fi(y) + (cid:96)i(y)] − w(cid:62)fi(y(i)) ≥ (cid:96)i(h(x(i))),

44

CHAPTER4. STRUCTUREDMAXIMUMMARGINESTIMATION

where as before, (cid:96)i(h(x(i))) = (cid:96)(x(i), y(i), h(x(i))), (cid:96)i(h(x(i))) = (cid:96)(x(i), y(i), h(x(i))), and
fi(y) = f (x(i), y). With this upper bound, the min-max formulation for structured classiﬁ-
cation problem is analogous to multi-class SVM formulation in Eq. (2.9) and Eq. (2.10):

min

s.t.

ξi

||w||2 + C
1
2
w(cid:62)fi(y(i)) + ξi ≥ max
y∈Y (i)

i

[w(cid:62)fi(y) + (cid:96)i(y)], ∀i.

(4.2)

(cid:88)

(cid:88)

The above formulation is a convex quadratic program in w, since maxy∈Y (i)[w(cid:62)fi(y) +
(cid:96)i(y)] is convex in w (maximum of afﬁne functions is a convex function). For brevity, we
did not explicitly include the constraint that the parameters are in some legal convex set
(w ∈ W, most often IRn), but assume this throughout this chapter.

The problem with Eq. (4.2) is that the constraints have a very unwieldy form. An-
i |Y (i)| linear constraints, which is generally

other way to express this problem is using
exponential in Li, the number of variables in yi.

(cid:80)

min

s.t.

||w||2 + C
1
2
w(cid:62)fi(y(i)) + ξi ≥ w(cid:62)fi(y) + (cid:96)i(y), ∀i, ∀y ∈ Y (i).

ξi

i

(4.3)

This form reveals the “maximum margin” nature of the formulation. We can interpret
1||w||w(cid:62)[fi(y(i)) − fi(y)] as the margin of y(i) over another y ∈ Y (i). Assuming ξi are all
zero (say because C is very large), the constraints enforce

w(cid:62)fi(y(i)) − w(cid:62)fi(y) ≥ (cid:96)i(y),

so minimizing ||w|| maximizes the smallest such margin, scaled by the loss (cid:96)i(y). The
slack variables ξi allow for violations of the constraints at a cost Cξi. If the loss function is
not uniform over all the mistakes y (cid:54)= y(i), then the constraints make costly mistakes (those
with high (cid:96)i(y)) less likely. In Ch. 5 we analyze the effect of non-uniform loss function
(Hamming distance type loss) on generalization, and show a strong connection between the
loss-scaled margin and expected risk of the learned model.

The formulation in Eq. (4.3) is a standard QP with linear constraints, but its exponential

4.1. MAX-MARGINESTIMATION

45

size is in general prohibitive. We now return to Eq. (4.2) and transform it to a a more man-
ageable problem. The key to solving Eq. (4.2) efﬁciently is the loss-augmented inference

[w(cid:62)fi(y) + (cid:96)i(y)].

max
y∈Y (i)

(4.4)

Even if maxy∈Y (i) w(cid:62)fi(y) can be solved in polynomial time using convex optimization, the
form of the loss term (cid:96)i(y) is crucial for the loss-augmented inference to remain tractable.
The range of tractable losses will depend strongly on the problem itself (f and Y). Even
within the range of tractable losses, some are more efﬁciently computable than others. A
large part of the development of structured estimation methods in the following chapters
is identifying appropriate loss functions for the application and designing convex formula-
tions for the loss-augmented inference.

Assume that we ﬁnd such a formulation in terms of a set of variables µi, with a concave

(in µi) objective (cid:101)fi(w, µi) and subject to convex constraints(cid:101)gi(µi):
(cid:101)fi(w, µi).

[w(cid:62)fi(y) + (cid:96)i(y)] =

µi:(cid:101)gi(µi)≤0

max

max
y∈Y (i)

We call such formulation compact if the number of variables µi and constraints(cid:101)gi(µi) is
(cid:101)fi(w, µi) must be convex in w, since Eq. (4.4) is. Likewise,
Note that maxµi:(cid:101)gi(µi)≤0

polynomial in Li, the number of variables in y(i).

(4.5)

we can assume that it is feasible and bounded if Eq. (4.4) is. In the next section, we de-
velop a max-margin formulation that uses Lagrangian duality (see [Boyd & Vandenberghe,
2004] for an excellent review) to deﬁne a joint, compact convex problem for estimating the
parameters w.

To make the symbols concrete, consider the example of the reviewer-assignment prob-
lem we discussed in the previous chapter: we would like a bipartite matching with R re-
viewers per paper and at most P papers per reviewer. Each training sample i consists of a
matching of N (i)
reviewers from some previous year. Let xjk denote the
intersection of the set of words occurring in the web page of a reviewer j and the abstract of
the paper k. Let yjk indicate whether reviewer j is matched to the paper k. We can deﬁne
a basis function fd(xjk, yjk) = yjk1I(wordd ∈ xjk), which indicates whether the word d is

p papers and N (i)
r

(cid:88)
p −(cid:80)

jk

(cid:88)

jk

(cid:88)

(cid:88)

jk

(cid:88)

46

CHAPTER4. STRUCTUREDMAXIMUMMARGINESTIMATION

in both the web page of a reviewer and the abstract of the paper that are matched in y. We
abbreviate the vector of all the basis functions for each edge jk as yjkf (i)

jk = f (x(i)

jk , yjk).

We assume that the loss function decomposes over the variables yij. For example, the

Hamming loss simply counts the number of different edges in the matchings y and y(i):

(cid:96)H
i (y) =

(cid:96)0/1
i,jk(yjk) =

1I(yjk (cid:54)= y(i)

jk ) = RN (i)

p −

yjky(i)
jk .

The last equality follows from the fact that any valid matching for example i has R review-
ers for N (i)
jk represents exactly the number of edges that
are different between y and y(i). Combining the two pieces, we have

p papers, hence RN (i)

jk yjky(i)

w(cid:62)f (x(i), y) =

[w(cid:62)f (xjk, yjk) + (cid:96)0/1

i,jk(yjk)] = RN (i)

p +

yjk[w(cid:62)fjk − y(i)
jk ].

jk

jk

(cid:88)
(cid:88)

jk

max

s.t.

The loss-augmented inference problem can be then written as an LP in µi similar

to Eq. (3.3) (without the constant term RN (i)

p ):

µi,jk[w(cid:62)fjk − y(i)
jk ]

(cid:88)

µi,jk = R,

µi,jk ≤ P,

0 ≤ µi,jk ≤ 1.

j

In terms of Eq. (4.5), (cid:101)fi and(cid:101)gi are afﬁne in µi: (cid:101)fi(w, µi) = RN (i)
and(cid:101)gi(µi) ≤ 0 ⇔(cid:80)

(cid:80)
k µi,jk ≤ P, 0 ≤ µi,jk ≤ 1.

j µi,jk = R,

k

p +

(cid:80)
i,j µi,jk[w(cid:62)fjk−y(i)
jk ]

In general, when we can express maxy∈Y (i) w(cid:62)f (x(i), y) as an LP and we use a loss
function this is linear in the number of mistakes, we have a linear program of this form for
the loss-augmented inference:

di + max (Fiw + ci)(cid:62)µi

s.t. Aiµi ≤ bi, µi ≥ 0,

(4.6)

for appropriately deﬁned di, Fi, ci, Ai, bi, which depend only on x(i), y(i), f (x, y) and
g(x, y). Note that the dependence on w is linear and only in the objective of the LP. If
this LP is compact (the number of variables and constraints is polynomial in the number of

4.1. MAX-MARGINESTIMATION

47

label variables), then we can use it to solve the max-margin estimation problem efﬁciently
by using convex duality.

The Lagrangian associated with Eq. (4.4) is given by

Li,w(µi, λi) = (cid:101)fi(w, µi) − λ(cid:62)

i(cid:101)gi(µi),

(4.7)

where λi ≥ 0 is a vector of Lagrange multipliers, one for each constraint function in

(cid:101)gi(µi). Since we assume that (cid:101)fi(w, µi) is concave in µi and bounded on the non-empty set
µi :(cid:101)gi(µi) ≤ 0, we have strong duality:

(cid:101)fi(w, µi) = min

µi:(cid:101)gi(µi)≤0

max

For many forms of (cid:101)f and(cid:101)g, we can write the Lagrangian dual minλi≥0 maxµi Li,w(µi, λi)

λi≥0

µi

max

Li,w(µi, λi).

explicitly as:

min

s.t.

hi(w, λi)
qi(w, λi) ≤ 0,

(4.8)

(We folded λi ≥ 0 into
where hi(w, λi) and qi(w, λi) are convex in both w and λi.
qi(w, λi) for brevity.) Since the original problem had polynomial size, the dual is polyno-
mial size as well. For example, the dual of the LP in Eq. (4.6) is

di + min b(cid:62)
i λi

s.t. A(cid:62)

i λi ≥ Fiw + ci, λi ≥ 0,
i λi and qi(w, λi) ≤ 0 is {Fiw + ci − A(cid:62)

i λi ≤ 0,−λi ≤ 0}.

(4.9)

where hi(w, λi) = di + b(cid:62)

Plugging Eq. (4.8) into Eq. (4.2), we get

(cid:88)

min

s.t.

||w||2 + C
1
2
w(cid:62)fi(y(i)) + ξi ≥ min

ξi

i

qi(w,λi)≤0

(4.10)

hi(w, λi),

∀i.

Moreover, we can combine the minimization over λ with minimization over {w, ξ}. The

48

CHAPTER4. STRUCTUREDMAXIMUMMARGINESTIMATION

reason for this is that if the right hand side is not at the minimum, the constraint is tighter
than necessary, leading to a suboptimal solution w. Optimizing jointly over λ as well will
produce a solution to {w, ξ} that is optimal.

(cid:88)

(cid:88)

(4.11)

(4.12)

The exact form of this program depends strongly on (cid:101)f and(cid:101)g. For our LP-based example,

Hence we have a joint and compact convex optimization program for estimating w.

we have a QP with linear constraints:

min

s.t.

ξi

||w||2 + C
1
2
w(cid:62)fi(y(i)) + ξi ≥ hi(w, λi), ∀i;
qi(w, λi) ≤ 0, ∀i.

i

min

s.t.

i

ξi

||w||2 + C
1
2
w(cid:62)fi(y(i)) + ξi ≥ di + b(cid:62)
i λi ≥ Fiw + ci, ∀i;
A(cid:62)
λi ≥ 0, ∀i.

i λi, ∀i;

4.1.2 Certiﬁcate formulation

In the previous section, we assumed a compact convex formulation of the loss-augmented
max in Eq. (4.4). There are several important combinatorial problems which allow poly-
nomial time solution yet do not have a compact convex optimization formulation. For
example, maximum weight perfect (non-bipartite) matching and spanning tree problems
can be expressed as linear programs with exponentially many constraints, but no polyno-
mial formulation is known [Bertsimas & Tsitsiklis, 1997; Schrijver, 2003]. Both of these
problems, however, can be solved in polynomial time using combinatorial algorithms. In
some cases, though, we can ﬁnd a compact certiﬁcate of optimality that guarantees that
y(i) = arg maxy[w(cid:62)fi(y) + (cid:96)i(y)] without expressing loss-augmented inference as a com-
pact convex program. Intuitively, just verifying that a given assignment is optimal is some-
times easier than actually ﬁnding it.

4.1. MAX-MARGINESTIMATION

49

Consider the maximum weight spanning tree problem. A basic property of a span-
ning tree is that cutting any edge (j, k) in the tree creates two disconnected sets of nodes
(Vj[jk],Vk[jk]), where j ∈ Vj[jk] and k ∈ Vk[jk]. A spanning tree is optimal with respect
to a set of edge weights if and only if for every edge (j, k) in the tree connecting Vj[jk] and
Vk[jk], the weight of (j, k) is larger than (or equal to) the weight of any other edge (j(cid:48), k(cid:48))
in the graph with j(cid:48) ∈ Vj[jk], k(cid:48) ∈ Vk[jk] [Cormen et al., 2001]. We discuss the conditions
for optimality of perfect matchings in Ch. 10. Suppose that we can ﬁnd a compact convex
formulation of these conditions via a polynomial (in Li) set of functions qi(w, νi), jointly
convex in w and auxiliary variables νi:

∃νi s.t. qi(w, νi) ≤ 0 ⇔ w(cid:62)fi(y(i)) ≥ w(cid:62)fi(y) + (cid:96)i(y), ∀y ∈ Y (i).

Then the following joint convex program in w and ν computes the max-margin parameters:

min

s.t.

||w||2
1
2
qi(w, νi) ≤ 0,

∀i.

(4.13)

Expressing the spanning tree optimality does not require additional variables νi, but in
other problems, such as in perfect matching optimality in Ch. 10, such auxiliary variables
are needed. In the spanning tree problem, suppose yjk encodes whether edge (j, k) is in
the tree and the score of the edge is given by w(cid:62)fi,jk for some basis functions f (x(i)
jk , yjk).
We also assume that the loss function decomposes into a sum of losses over the edges, with
loss for each wrong edge given by (cid:96)i,jk. Then the optimality conditions are:

w(cid:62)fi,jk ≥ w(cid:62)fi,j(cid:48)k(cid:48) + (cid:96)i,j(cid:48)k(cid:48),

∀jk, j(cid:48)k(cid:48) s.t. y(i)

(cid:161)|V (i)|3) constraints for each example i, where |V (i)| is the number

jk = 1, j(cid:48) ∈ Vj[jk], k(cid:48) ∈ Vk[jk].

For a full graph, we have
of nodes in the graph for example i.

Note that this formulation does not allow for violations of the margin constraints (it has
no slack variables ξi). If the basis functions are not sufﬁciently rich to ensure that each y(i)
is optimal, then Eq. (4.1.2) may be infeasible. Essentially, this formulation requires that
the upper bound on the empirical risk be zero, R(cid:96)
S[hw] = 0, and minimizes the complexity

50

CHAPTER4. STRUCTUREDMAXIMUMMARGINESTIMATION

of the hypothesis hw as measured by the norm of the weights.

If the problem is infeasible, the designer could add more basis functions f (x, y) that
take into account additional information about x. One could also add slack variables for
each example and each constraint that would allow violations of optimality conditions with
some penalty. However, these slack variables would not represent upper bounds on the loss
as they are in the min-max formulation, and therefore are less justiﬁed.

4.2 Approximations: upper and lower bounds

There are structured prediction tasks for which we might not be able to solve the estimation
problem exactly. Often, we cannot compute maxy∈Y (i)[w(cid:62)fi(y) + (cid:96)i(y)] exactly or explic-
itly, but can only upper or lower bound it. Fig. 4.1 shows schematically how approximating
of the max subproblem reduces or extends the feasible space of w and ξ and leads to ap-
proximate solutions. The nature of these lower and upper bounds depends on the problem,
but we consider two general cases below.

4.2.1 Constraint generation

When neither compact maximization or optimality formulation is possible, but the max-
imization problem can be solved or approximated by a combinatorial algorithm, we can
resort to constraint generation or cutting plane methods. Consider Eq. (4.3), where we
have an exponential number of linear constraints, one for each i and y ∈ Y (i). Only a sub-
set of those constraints will be active at the optimal solution w. In fact, not more than the
number of parameters n plus the number of examples m can be active in general, since that
is the number of variables. If we can identify a small number of constraints that are critical
to the solution, we do not have to include all of them. Of course, identifying these con-
straints is in general as difﬁcult as solving the problem, but a greedy approach of adding the
most violated constraints often achieves good approximate solutions after adding a small
(polynomial) number of constraints. If we continue adding constraints until there are no
more violated ones, the resulting solution is optimal.

We assume that we have an algorithm that produces y = arg maxy∈Y (i)[w(cid:62)fi(y) +

4.2. APPROXIMATIONS:UPPERANDLOWERBOUNDS

51

Figure 4.1: Exact and approximate constraints on the max-margin quadratic program. The
solid red line represents the constraints imposed by the assignments y ∈ Y(i), whereas the
dashed and dotted lines represent approximate constraints. The approximate constraints
may coincide with the exact constraints in some cases, and be more stringent or relaxed in
others. The parabolic contours represent the value of the objective function and ‘+’, ‘x’ and
‘o’ mark the different optima.

(cid:96)i(y)]. The algorithm is described in Fig. 4.2. We maintain, for each example i, a small

but growing set of assignments (cid:101)Y (i) ⊂ Y (i). At each iteration, we solve the problem with a

(4.14)

1
2

||w||2 + C

w(cid:62)fi(y(i)) + ξi ≥ w(cid:62)fi(y) + (cid:96)i(y), ∀i, ∀y ∈ (cid:101)Y (i).

ξi

s.t.

We then compute y = arg maxy∈Y (i)[w(cid:62)fi(y) + (cid:96)i(y)] for each i and check whether the
constraint w(cid:62)fi(y(i)) + ξi +  ≥ w(cid:62)fi(y) + (cid:96)i(y), is violated, where  is a user deﬁned

The only difference between Eq. (4.3) and Eq. (4.14) is that Y (i) has been replaced by (cid:101)Y (i).
precision parameter. If it is violated, we set (cid:101)Y (i) = (cid:101)Y (i) ∪ y. The algorithm terminates
by (cid:101)Y (i)∪ y keeps tightening with each iteration, terminating when the desired precision  is

when no constraints are violated. In Fig. 4.1, the lower-bound on the constraints provided

reached. We note that if the algorithm that produces y = arg maxy∈Y (i)[w(cid:62)fi(y)+(cid:96)i(y)] is

subset of constraints:

min

(cid:88)

i

Upper-boundExact Lower-bound ×+52

CHAPTER4. STRUCTUREDMAXIMUMMARGINESTIMATION

Input: precision parameter .

1. Initialize: (cid:101)Y (i) = {}, ∀ i.

2. Set violation = 0 and solve for w and ξ by optimizing

(cid:88)

i

||w||2 + C

w(cid:62)fi(y(i)) + ξi ≥ w(cid:62)fi(y) + (cid:96)i(y), ∀i, ∀y ∈ (cid:101)Y (i).

ξi

1
2

min

s.t.

3. For each i,

Compute y = arg maxy∈Y (i)[w(cid:62)fi(y) + (cid:96)i(y)],
if w(cid:62)fi(y(i)) + ξi +  ≤ w(cid:62)fi(y) + (cid:96)i(y),

then set (cid:101)Y (i) = (cid:101)Y (i) ∪ y and violation = 1

4. if violation = 1 goto 2.

Return w.

Figure 4.2: A constraint generation algorithm.

suboptimal, the approximation error of the solution we achieve might be much greater than
. The number of constraints that must be added before the algorithm terminates depends
on the precision  and problem speciﬁc characteristics. See [Bertsimas & Tsitsiklis, 1997;
Boyd & Vandenberghe, 2004] for a more in-depth discussion of cutting planes methods.
This approach may also be computationally faster in providing a very good approximation
in practice if the explicit convex programming formulation is polynomial in size, but very
large, while the maximization algorithm is comparatively fast.

4.2.2 Constraint strengthening

In many problems, the maximization problem we are interested in may be very expensive
or intractable. For example, we consider MAP inference in large tree-width Markov net-
works in Ch. 8, multi-way cut in Ch. 7, graph-partitioning in Ch. 11. Many such problems
can be written as integer programs. Relaxations of such integer programs into LPs, QPs
or SDPs often provide excellent approximation algorithms [Hochbaum, 1997; Nemhauser

& Wolsey, 1999]. The relaxation usually deﬁnes a larger feasible space (cid:101)Y (i) ⊃ Y (i) over

4.3. RELATEDWORK

53

which the maximization is done, where y ∈ (cid:101)Y (i) may correspond to a “fractional” assign-

ment. For example, a solution to the MAP LP in Eq. (3.2) for an untriangulated network
may not correspond to any valid assignment. In such a case, the approximation is an over-
estimate of the constraints:

y∈(cid:101)Y (i)

max

[w(cid:62)fi(y) + (cid:96)i(y)] ≥ max
y∈Y (i)

[w(cid:62)fi(y) + (cid:96)i(y)].

Hence the constraint set is tightened with such invalid assignments. Fig. 4.1 shows how the
over-estimate reduces the feasible space of w and ξ.

Note that for every setting of the weights w that produces fractional solutions for the
relaxation, the approximate constraints are tightened because of the additional invalid as-
signments. In this case, the approximate MAP solution has higher value than any integer
solution, including the true assignment y(i), thereby driving up the corresponding slack ξi.
By contrast, for weights w for which the MAP approximation is integer-valued, the margin
has the standard interpretation as the difference between the score of y(i) and the MAP y
(according to w). As the objective includes a penalty for the slack variable, intuitively,
minimizing the objective tends to drive the weights w away from the regions where the so-
lutions to the approximation are fractional. In essence, the estimation algorithm is ﬁnding
weights that are not necessarily optimal for an exact maximization algorithm, but (close to)
optimal for the particular approximate maximization algorithm used. In practice, we will
show experimentally that such approximations often work very well.

4.3 Related work

Our max-margin formulation is related to a body of work called inverse combinatorial and
convex optimization [Burton & Toint, 1992; Zhang & Ma, 1996; Ahuja & Orlin, 2001;
Heuberger, 2004]. An inverse optimization problem is deﬁned by an instance of an opti-
mization problem maxy∈Y w(cid:62)f (y), a set of nominal weights w0, and a target solution yt.
The goal is to ﬁnd the weights w closest to the nominal w0 in some norm, which make the

54

CHAPTER4. STRUCTUREDMAXIMUMMARGINESTIMATION

target solution optimal:

min

s.t.

||w − w0||p
w(cid:62)f (yt) ≥ w(cid:62)f (y),

∀y ∈ Y.

Most of the attention has been on L1 and L∞ norms, but L2 norm is also used.

The study of inverse problems began with geophysical scientists (see [Tarantola, 1987]
for in-depth discussion of a wide range of applications). Modeling a complex physical
system often involves a large number of parameters which scientists ﬁnd hard or impossible
to set correctly. Provided educated guesses for the parameters w0 and the behavior of the
system as a target, the inverse optimization problem attempts to match the behavior while
not perturbing the “guesstimate” too much.

Although there is a strong connection between inverse optimization problems and our
formulations, the goals are very different than ours. In our framework, we are learning
a parameterized objective function that depends on the input x and will generalize well
in prediction on new instances. Moreover, we do not assume as given a nominal set of
weights. Note that if we set w0 = 0, then w = 0 is trivially the optimal solution. The
solution w depends critically on the choice of nominal weights, which is not appropriate in
the learning setting.

The inverse reinforcement learning problem [Ng & Russell, 2000; Abbeel & Ng, 2004]
is much closer to our setting. The goal is to learn a reward function that will cause a rational
agent to act similar to the observed behavior of an expert. A full description of the problem
is beyond our scope, but we brieﬂy describe the Markov decision process (MDP) model
commonly used for sequential decision making problems where an agent interacts with its
environment. The environment is modeled as a system that can be in one of a set of discrete
states. At every time step, the agent chooses an action from a discrete set of actions and the
system transitions to a next state with a probability that depends on the current state and
the action taken. The agent collects a reward at each step, which generally depends on the
on the current and the next state and the action taken. A rational agent executes a policy
(essentially, a state to action mapping) that maximizes its expected reward. To map this
problem (approximately) to our setting, note that a policy roughly corresponds to the labels

4.4. CONCLUSION

55

y, the state sequence correspond to the input x and the reward for a state/action sequence is
assumed to be w(cid:62)f (x, y) for some basis functions w(cid:62)f (x, y). The goal is to learn w from a
set of state/action sequences (x(i), y(i)) of the expert such that the maximizing the expected
reward according to the system model makes the agent imitate the expert. This and related
problems are formulated as a convex program in Ng and Russell [2000] and Abbeel and
Ng [2004].

4.4 Conclusion

In this chapter, we presented two formulations of structured max-margin estimation that
deﬁne a compact convex optimization problem. The ﬁrst formulation, min-max, relies on
the ability to express inference in the model as a compact convex optimization problem.
The second one, certiﬁcate, only requires expressing optimality of a given assignment ac-
cording to the model. Our framework applies to a wide range of prediction problems that
we explore in the rest of the thesis, including Markov networks, context free grammars, and
many combinatorial structures such as matchings and graph-cuts. The estimation problem
is tractable and exact whenever the prediction problem can be formulated as a compact
convex optimization problem or a polynomial time combinatorial algorithm with compact
convex optimality conditions. When the prediction problem is intractable or very expen-
sive to solve exactly, we resort to approximations that only provide upper/lower bounds
on the predictions. The estimated parameters are then approximate, but produce accurate
approximate prediction models in practice.

Because our approach only relies using the maximum in the model for prediction, and
does not require a normalized distribution P (y | x) over all outputs, maximum margin
estimation can be tractable when maximum likelihood is not. For example, to learn a prob-
abilistic model P (y | x) over bipartite matchings using maximum likelihood requires com-
puting the normalizing partition function, which is #P-complete [Valiant, 1979; Garey &
Johnson, 1979]. By contrast, maximum margin estimation can be formulated as a compact
QP with linear constraints. Similar results hold for non-bipartite matchings and min-cuts.
In models that are tractable for both maximum likelihood and maximum margin, (such
as low-treewidth Markov networks, context free grammars, many other problems in which

56

CHAPTER4. STRUCTUREDMAXIMUMMARGINESTIMATION

inference is solvable by dynamic programming), our approach has an additional advantage.
Because of the hinge-loss, the solutions to the estimation are relatively sparse in the dual
space (as in SVMs), which makes the use of kernels much more efﬁcient. Maximum like-
lihood estimation with kernels results in models that are generally non-sparse and require
pruning or greedy support vector selection methods [Lafferty et al., 2004; Altun et al.,
2004].

The forthcoming formulations in the thesis follow the principles laid out in this chapter.
The range of applications of these principles is very broad and leads to estimation prob-
lems with very interesting structure in each particular problem, from Markov networks and
context-free grammars to graph cuts and perfect matchings.

Part II

Markov networks

57

Chapter 5

Markov networks

Markov networks are extensively used to model complex sequential, spatial, and relational
interactions in prediction problems arising in many ﬁelds. These problems involve labeling
a set of related objects that exhibit local consistency. In sequential labeling problems (such
as handwriting recognition), the labels (letters) of adjacent inputs (images) are highly corre-
lated. Sequential prediction problems arise in natural language processing (part-of-speech
tagging, speech recognition, information extraction [Manning & Sch¨utze, 1999]), compu-
tational biology (gene ﬁnding, protein structure prediction, sequence alignment [Durbin
et al., 1998]), and many other ﬁelds. In image processing, neighboring pixels exhibit spa-
tial label coherence in denoising, segmentation and stereo correspondence [Besag, 1986;
Boykov et al., 1999a]. In hypertext or bibliographic classiﬁcation, labels of linked and
co-cited documents tend to be similar [Chakrabarti et al., 1998; Taskar et al., 2002]. In
proteomic analysis, location and function of proteins that interact are often highly corre-
lated [Vazquez et al., 2003]. Markov networks compactly represent complex joint distribu-
tions of the label variables by modeling their local interactions. Such models are encoded
by a graph, whose nodes represent the different object labels, and whose edges represent
and quantify direct dependencies between them. For example, a Markov network for the
hypertext domain would include a node for each webpage, encoding its label, and an edge
between any pair of webpages whose labels are directly correlated (e.g., because one links
to the other).

We address the problem of max-margin estimation the parameters of Markov networks

58

5.1. MAXIMUMLIKELIHOODESTIMATION

59

for such structured classiﬁcation problems. We show a compact convex formulation that
seamlessly integrates kernels with graphical models. We analyze the theoretical general-
ization properties of max-margin estimation and derive a novel margin-based bound for
structured classiﬁcation.

We are given a labeled training sample S = {(x(i), y(i))}m

i=1, drawn from a ﬁxed dis-
tribution D over X × Y. We assume the structure of the network is given: we have a
mapping from an input x to the corresponding Markov network graph G(x) = {V,E}
where the nodes V map to the variables in y. We abbreviate G(x(i)) as G(i) below. In hand-
writing recognition, this mapping depends on the segmentation algorithm that determines
how many letters the sample image contains and splits the image into individual images
for each letter. It also depends on the basis functions we use to model the dependencies of
the problem, for example, ﬁrst-order Markov chain or a higher-order models. Note that the
topology and size of the graph G(i), might be different for each example i. For instance, the
training sequences might have different lengths.

We focus on conditional Markov networks (or CRFs [Lafferty et al., 2001]), which
represent P (y | x) instead of generative models P (x, y). The log-linear representation we
have described in Sec. 3.3.1 is deﬁned via a vector of n basis functions f (x, y):

log Pw(y | x) = w(cid:62)f (x, y) − log Zw(x),

(cid:80)
y exp{w(cid:62)f (x, y)} and w ∈ IRn. Before we present the maximum

where Zw(x) =
margin estimation, we review the standard maximum likelihood method.

5.1 Maximum likelihood estimation

The regularized maximum likelihood approach of learning the weights w of a Markov net-
work is similar to logistic regression we described in Sec. 2.2. The objective is to minimize
the training log-loss with an additional regularization term, usually the squared-norm of the
weights w [Lafferty et al., 2001]:

(cid:88)

i

log Zw(x(i)) − w(cid:62)fi(y(i)),

(cid:88)

i

||w||2 − C

1
2

log Pw(y(i) | x(i)) =

||w||2 + C

1
2

60

CHAPTER5. MARKOVNETWORKS

where fi(y) = f (x(i), y).

This objective function is convex in the parameters w, so we have an unconstrained

convex optimization problem. The gradient with respect to w is given by:

w + C

Ei,w[fi(y)] − fi(y(i))

= w − C

Ei,w[∆fi(y)],

(cid:164)

(cid:88)

i

(cid:163)

(cid:88)
(cid:80)

i

y∈Y fi(y)Pw(y | x(i)) is the expectation under the conditional dis-
where Ei,w[fi(y)] =
tribution Pw(y | x(i)) and ∆fi(y) = f (x(i), y(i))− f (x(i), y), as before. To compute the ex-
pectations, we can use inference in the Markov network to calculate marginals Pw(yc | x(i))
for each clique c in the network Sec. 3.3.2. Since the basis functions decompose over the
cliques of the network, the expectation decomposes as well:

Ei,w[fi(y)] =

fi,c(yc)Pw(yc | x(i)).

(cid:88)

(cid:88)

c∈C(i)

yc∈Y (i)

c

Second order methods for solving unconstrained convex optimization problems, such
as Newton’s method, require the second derivatives as well as the gradient. Let δfi(y) =
fi(y) − Ei,w[fi(y)]. The Hessian of the objective depends on the covariances of the basis
functions:

(cid:88)

(cid:163)

δfi(y)δfi(y)(cid:62)(cid:164)

,

I + C

Ei,w

i

where I is a n × n identity matrix. Computing the Hessian is more expensive than the
gradient, since we need to calculate joint marginals of every pair of cliques c and c(cid:48),
Pw(yc∪c(cid:48) | xi) as well as covariances of all basis functions, which is quadratic in the num-
ber of cliques and the number of functions. A standard approach is to use an approximate
second order method that does not need to compute the Hessian, but uses only the gradient
information [Nocedal & Wright, 1999; Boyd & Vandenberghe, 2004]. Conjugate Gradients
or L-BFGS methods have been shown to work very well on large estimation problems [Sha
& Pereira, 2003; Pinto et al., 2003], even with millions of parameters w.

5.2. MAXIMUMMARGINESTIMATION

61

5.2 Maximum margin estimation

For maximum-margin estimation, we begin with the min-max formulation from Sec. 4.1:

(cid:88)

||w||2 + C

1
2

min
s.t. w(cid:62)fi(y(i)) + ξi ≥ max

ξi

i

[w(cid:62)fi(y) + (cid:96)i(y)], ∀i.

(5.1)

y

We know from Sec. 3.3.3 how to express maxy w(cid:62)fi(y) as an LP, but the important differ-
ence is the loss function (cid:96)i. The simplest loss is the 0/1 loss (cid:96)i(y) ≡ 1I(y(i) (cid:54)= y). In fact
this loss for sequence models was used by Collins [2001] and Altun et al. [2003]. However,
in structured problems, where we are predicting multiple labels, the loss is often not just
the simple 0/1 loss, but may depend on the number of labels and type of labels predicted
incorrectly or perhaps the number of cliques of labels predicted incorrectly. In general, we
assume that the loss, like the basis functions, decomposes over the cliques of labels.

Assumption 5.2.1 The loss function (cid:96)i(y) is decomposable:

(cid:88)

(cid:88)

(cid:96)i(y) =

(cid:96)(x(i)

c , y(i)

c , yc) =

(cid:96)i,c(yc).

c∈C(G(i))

c∈C(G(i))

We will focus on decomposable loss functions below. A natural choice that we use in our
experiments is the Hamming distance:

(cid:96)H(x(i), y(i), y) =

1I(y(i)
v

(cid:54)= yv).

(cid:88)

v∈V (i)

With this assumption, we can express this inference problem for a triangulated graph

as a linear program for each example i as in Sec. 3.3.3:

µi,c(yc)[w(cid:62)fi,c(yc) + (cid:96)i,c(yc)]

(5.2)

µi,c(yc) = 1, ∀i, ∀c ∈ C(i);

µi,c(yc) ≥ 0, ∀c ∈ C(i), ∀yc;

yc

µi,s(ys) =

µi,c(y(cid:48)
c),

∀s, c ∈ C(i), s ⊂ c, ∀ys,

(cid:88)

c∼ys
y(cid:48)

(cid:88)
(cid:88)

c,yc

max

s.t.

62

CHAPTER5. MARKOVNETWORKS

where C(i) = C(G(i)) are the cliques of the Markov network for example i.

As we showed before, the constraints ensure that the µi’s form a proper distribution. If
the most likely assignment is unique, then the distribution that maximizes the objective puts
all its weight on that assignment. (If the arg max is not unique, any convex combination of
the assignments is a valid solution). The dual of Eq. (5.2) is given by:

(cid:88)

min

λi,c

c

s.t. λi,c +

(cid:88)

s⊃c

(cid:88)

s⊂c, y(cid:48)

s∼yc

mi,s,c(yc) −

mi,c,s(y(cid:48)

s) ≥ w(cid:62)fi,c(yc) + (cid:96)i,c(yc), ∀c ∈ C(i),∀yc.

In this dual, the λi,c variables correspond to the normalization constraints, while mi,c,s(yc)
variables correspond to the agreement constraints in the primal in Eq. (5.2).

(5.3)

(5.4)

Plugging the dual into Eq. (5.1) for each example i and maximizing jointly over all the

variables (w, ξ, λ and m), we have:

(cid:88)

min

s.t.

||w||2 + C
1
ξi
2
w(cid:62)fi(y(i)) + ξi ≥

i

(cid:88)

i,c

λi,c, ∀i;

(cid:88)

s⊂c, y(cid:48)

s∼yc

(cid:88)

s⊃c

λi,c +

mi,s,c(yc) −

mi,c,s(y(cid:48)

s) ≥ w(cid:62)fi,c(yc) + (cid:96)i,c(yc), ∀c ∈ C(i),∀yc.

In order to gain some intuition about this formulation, we make a change of variables from
λi,c to ξi,c:

λi,c = w(cid:62)fi,c(y(i)

c ) + ξi,c, ∀i, ∀c ∈ C(i).

The reason for naming the new variables using the letter ξ will be clear in the following. For
readability, we also introduce variables that capture the effect of all the agreement variables
m:

(cid:88)

mi,c,s(y(cid:48)

s) −

mi,s,c(yc), ∀i, ∀c ∈ C(i), ∀yc.

Mi,c(yc) =

s⊂c, y(cid:48)

s∼yc

(cid:88)

s⊃c

63

(5.5)

5.2. MAXIMUMMARGINESTIMATION

With these new variables, we have:

(cid:88)

ξi

i

min

s.t.

||w||2 + C

(cid:88)

1
2
ξi ≥
w(cid:62)fi,c(y(i)
Mi,c(yc) =

c

(cid:80)
constraint ξi ≥(cid:80)

Note that ξi =

this set of variables:

ξi,c, ∀i;
(cid:88)
c ) + ξi,c ≥ w(cid:62)fi,c(yc) + (cid:96)i,c(yc) + Mi,c(yc), ∀i, ∀c ∈ C(i), ∀yc;

(cid:88)

mi,s,c(yc), ∀i, ∀c ∈ C(i), ∀yc.

mi,c,s(y(cid:48)

s) −

s⊂c, y(cid:48)

s∼yc

s⊃c

c ξi,c at the optimum, since the slack variable ξi only appears only in the
c ξi,c and the objective minimizes Cξi. Hence we can simply eliminate

(cid:88)
(cid:88)
c ) + ξi,c ≥ w(cid:62)fi,c(yc) + (cid:96)i,c(yc) + Mi,c(yc), ∀i, ∀c ∈ C(i), ∀yc;

(cid:88)

ξi,c

i,c

(5.6)

mi,c,s(y(cid:48)

s) −

mi,s,c(yc), ∀i, ∀c ∈ C(i), ∀yc.

||w||2 + C

1
2
w(cid:62)fi,c(y(i)
Mi,c(yc) =

s⊂c, y(cid:48)

s∼yc

s⊃c

min

s.t.

min

s.t.

Finally, we can write this in a form that resembles our original formulation Eq. (5.1), but
deﬁned at a local level, for each clique:

ξi,c

(cid:88)
(cid:88)
c ) + ξi,c ≥ max
mi,c,s(y(cid:48)

yc

i,c

s⊂c, y(cid:48)

s∼yc

||w||2 + C

1
2
w(cid:62)fi,c(y(i)

Mi,c(yc) =

(5.7)
[w(cid:62)fi,c(yc) + (cid:96)i,c(yc) + Mi,c(yc)], ∀i, ∀c ∈ C(i);
s) −

mi,s,c(yc), ∀i, ∀c ∈ C(i), ∀yc.

(cid:88)

s⊃c

Note that without Mi,c and mi,c,s variables, we essentially treat each clique as an indepen-
dent classiﬁcation problem: for each clique we have a hinge upper-bound on the local loss,
or a margin requirement. The mi,c,s(ys) variables correspond to a certain kind of messages
between cliques that distribute “credit” to cliques to fulﬁll this margin requirement from
other cliques which have sufﬁcient margin.

64

CHAPTER5. MARKOVNETWORKS

Figure 5.1: First-order chain shown as a set of cliques (nodes and edges). Also shown are
the corresponding local slack variables ξ for each clique and messages m between cliques.

As an example, consider the ﬁrst-order Markov chain in Fig. 5.1. The set of cliques
consists of the ﬁve nodes and the four edges. Suppose for the sake of this example that
our training data consists of only one training sample. The ﬁgure shows the local slack
variables ξ and messages m between cliques for this sample. For brevity of notion in this
example, we drop the dependence on the sample index i in the indexing of the variables
(we also used y(∗)
j below). For concreteness, below we use the Hamming
loss (cid:96)H, which decomposes into local terms (cid:96)j(yj) = 1I(yj (cid:54)= y(∗)
j ) for each node and is
zero for the edges.

instead of y(i)

j

The constraints associated with the node cliques in this sequence are:

w(cid:62)f1(y(∗)
w(cid:62)f2(y(∗)
w(cid:62)f3(y(∗)
w(cid:62)f4(y(∗)
w(cid:62)f5(y(∗)

1 ) + ξ1 ≥ w(cid:62)f1(y1) + 1I(y1 (cid:54)= y(∗)
2 ) + ξ2 ≥ w(cid:62)f2(y2) + 1I(y2 (cid:54)= y(∗)
3 ) + ξ3 ≥ w(cid:62)f3(y3) + 1I(y3 (cid:54)= y(∗)
4 ) + ξ4 ≥ w(cid:62)f4(y4) + 1I(y4 (cid:54)= y(∗)
5 ) + ξ5 ≥ w(cid:62)f5(y5) + 1I(y5 (cid:54)= y(∗)

1 ) − m1,12(y1), ∀y1;
2 ) − m2,12(y2) − m2,23(y2), ∀y2;
3 ) − m3,23(y3) − m3,34(y3), ∀y3;
4 ) − m4,34(y4) − m4,45(y4), ∀y4;
5 ) − m5,45(y5), ∀y5.

5.3. M3NDUALANDKERNELS

65

The edge constraints are:

w(cid:62)f12(y(∗)
w(cid:62)f23(y(∗)
w(cid:62)f34(y(∗)
w(cid:62)f45(y(∗)

1 , y(∗)
2 , y(∗)
3 , y(∗)
4 , y(∗)

2 ) + ξ12 ≥ w(cid:62)f12(y1, y2) + m1,12(y1) + m2,12(y2), ∀y1, y2;
3 ) + ξ23 ≥ w(cid:62)f23(y2, y3) + m2,23(y2) + m3,23(y3), ∀y2, y3;
4 ) + ξ34 ≥ w(cid:62)f34(y3, y4) + m3,34(y3) + m4,34(y4), ∀y3, y4;
5 ) + ξ45 ≥ w(cid:62)f45(y4, y5) + m4,45(y4) + m5,45(y5), ∀y4, y5.

5.3 M3N dual and kernels

In the previous section, we showed a derivation of a compact formulation based on LP
inference. In this section, we develop an alternative dual derivation that provides a very
interesting interpretation of the problem and is a departure for special-purpose algorithms
we develop. We begin with the formulation as in Eq. (4.3):

min

s.t.

||w||2 + C
1
2
w(cid:62)∆fi(y) ≥ (cid:96)i(y) − ξi, ∀i, y,

ξi

i

where ∆fi(y) ≡ f (x(i), y(i)) − f (x(i), y). The dual is given by:

(cid:88)

(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)(cid:88)
(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)

i,y

(5.8)

(5.9)

(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)2

(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)

(cid:88)
(cid:88)

i,y

max

s.t.

αi(y)(cid:96)i(y) − 1
2
αi(y) = C, ∀i;

αi(y)∆fi(y)

αi(y) ≥ 0, ∀i, y.

y

In the dual, the exponential number of αi(y) variables correspond to the exponential num-
ber of constraints in the primal. We make two small transformations to the dual that do not
change the problem: we normalize α’s by C (by letting αi(y) = Cα(cid:48)
i(y)), so that they sum

As in multi-class SVMs, the solution to the dual α gives the solution to the primal as a
weighted combination: w∗ = C

i (y)∆fi(y).

i,y α∗

Our main insight is that the variables αi(y) in the dual formulation Eq. (5.10) can be

interpreted as a kind of distribution over y, since they lie in the simplex

αi(y) = 1; αi(y) ≥ 0, ∀y.

(cid:88)
(cid:88)

i,y

y

(cid:88)

y

(cid:80)

(cid:88)

y(cid:48)∼yc

66

CHAPTER5. MARKOVNETWORKS

to 1 and divide the objective by C. The resulting dual is given by:

(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)
(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)(cid:88)

i,y

(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)
(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)2

(5.10)

max

s.t.

C

αi(y)(cid:96)i(y) − 1
2
αi(y) = 1, ∀i;

αi(y)∆fi(y)

αi(y) ≥ 0, ∀i, y.

(cid:80)

This dual distribution does not represent the probability that the model assigns to an instan-
tiation, but the importance of the constraint associated with the instantiation to the solution.
The dual objective is a function of expectations of (cid:96)i(y) and ∆fi(y) with respect to αi(y).
Since (cid:96)i(y) =
c ∆fi,c(yc) decompose over the cliques of the
Markov network, we only need clique marginals of the distribution αi(y) to compute their
expectations. We deﬁne the marginal dual variables as follows:

c (cid:96)i,c(yc) and ∆fi(y) =

(cid:80)

µi,c(yc) =

αi(y(cid:48)),

∀i, ∀c ∈ C(i), ∀yc,

(5.11)

where y(cid:48) ∼ yc denotes whether the partial assignment yc is consistent with the full assign-
ment y(cid:48). Note that the number of µi,c(yc) variables is small (polynomial) compared to the
number of αi(y) variables (exponential) if the size of the largest clique is constant with
respect to the size of the network.

Now we can reformulate our entire QP (5.10) in terms of these marginal dual variables.

Consider, for example, the ﬁrst term in the objective function (ﬁxing a particular i):

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

y(cid:48)∼yc

(cid:88)

c,yc

αi(y(cid:48)) =

µi,c(yc)(cid:96)i,c(yc).

αi(y)(cid:96)i(y) =

αi(y)

(cid:96)i,c(yc) =

(cid:96)i,c(yc)

y

y

c

c,yc

5.3. M3NDUALANDKERNELS

67

The decomposition of the second term in the objective is analogous.

(cid:88)

(cid:88)

αi(y)∆fi(y) =

∆fi,c(yc)

y

c,yc

(cid:88)

y(cid:48)∼yc

(cid:88)

c,yc

αi(y(cid:48)) =

µi,c(yc)∆fi,c(yc).

Let us denote the the objective of Eq. (5.10) as Q(α). Note that it only depends on
αi(y) through its marginals µi,c(yc), that is, Q(α) = Q(cid:48)(M(α)), where M denotes the
marginalization operator deﬁned by Eq. (5.11) . The domain of this operator, D[M], is
the product of simplices for all the m examples. What is its range, R[M], the set of legal
marginals? Characterizing this set (also known as marginal polytope) compactly will allow
us to work in the space of µ’s:

max
α∈D[M]

Q(α) ⇔ max
µ∈R[M]

Q(cid:48)(µ).

Hence we must ensure that µi corresponds to some distribution αi, which is exactly
what the constraints in the LP for MAP inference enforce (see discussion of Lemma 3.3.5).
Therefore, when all G(i) are triangulated, the following structured dual QP has the same
primal solution (w∗) as the original exponential dual QP in Eq. (5.10):

(cid:88)
(cid:88)

i,c,yc

max

s.t.

yc

µi,s(ys) =

(cid:88)

c∼ys
y(cid:48)

µi,c(yc)(cid:96)i,c(yc) − 1
2

C

µi,c(yc)∆fi,c(yc)

(5.12)

µi,c(yc) = 1, ∀i, ∀c ∈ C(i);

µi,c(yc) ≥ 0, ∀i, ∀c ∈ C(i), ∀yc;

µi,c(y(cid:48)
c),

∀i, ∀s, c ∈ C(i), s ⊂ c, ∀ys.

(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)
(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)2

(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)
(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)(cid:88)

i,c,yc

(cid:88)

The solution to the structured dual µ∗ gives us the primal solution:

w∗ = C

µ∗
i,c(yc)∆fi,c(yc).

i,c,yc

In this structured dual, we only enforce that there exists an αi consistent with µi, but do
not make a commitment about what it is. In general, the α distribution is not unique, but
there is a continuum of distributions consistent with a set of marginals. The objective of

68

CHAPTER5. MARKOVNETWORKS

the QP Eq. (5.10) does not distinguish between these distributions, since it only depends on
their marginals. The maximum-entropy distribution αi consistent with a set of marginals
µi, however, is unique for a triangulated model and can be computed using the junction tree
T (i) for the network [Cowell et al., 1999].

Speciﬁcally, associated with each edge (c, c(cid:48)) in the tree T (i) is a set of variables called
the separator s = c ∩ c(cid:48). Note that each separator s and complement of a separator c \ s is
also a clique of the original graph, since it is a subclique of a larger clique. We denote the
set of separators as S (i). Now we can deﬁne the maximum-entropy distribution αi(y) as
follows:

.

(5.13)

(cid:81)
(cid:81)

c∈T (i) µi,c(yc)
s∈S(i) µi,s(ys)

αi(y) =

Again, by convention 0/0 ≡ 0.

Kernels

Note that the solution is a weighted combination of local basis functions and the objective
of Eq. (5.12) can be expressed in terms of dot products between local basis functions

∆fi,c(yc)(cid:62)∆fj,¯c(y¯c) = [f (x(i)

c , y(i)

c ) − f (x(i)

c , yc)](cid:62)[f (x(j)

¯c , y(j)

¯c ) − f (x(j)

¯c , y¯c)].

Hence, we can locally kernelize our models and solve Eq. (5.12) efﬁciently. Kernels are
typically deﬁned on the input, e.g. k(x(i)
In our handwriting example, we use a
polynomial kernel on the pixel values for the node cliques. We usually extend the kernel
over the input space to the joint input and output space by simply deﬁning

c , x(j)

¯c ).

f (xc, yc)(cid:62)f (x¯c, y¯c) ≡ 1I(yc = y¯c)k(xc, x¯c).

Of course, other deﬁnitions are possible and may be useful when the assignments in each
clique yc have interesting structure. In Sec. 6.2 we experiment with several kernels for
the handwriting example. As in SVMs, the solutions to the max-margin QP are typically
sparse in the µ variables. Hence, each log-potential in the network “remembers” only a
small proportion of the relevant training data inputs.

5.4. UNTRIANGULATEDMODELS

69

Figure 5.2: Diamond Markov network (added triangulation edge is dashed and three-node
marginals are in dashed rectangles).

5.4 Untriangulated models

If the underlying Markov net is not chordal, we must address the problem by triangulating
the graph, that is, adding ﬁll-in edges to ensure triangulation. For example, if our graph is
a 4-cycle Y1—Y2—Y3—Y4—Y1 as in Fig. 5.2, we can triangulate the graph by adding an
arc Y1—Y3. This will introduce new cliques Y1, Y2, Y3 and Y1, Y3, Y4 and the corresponding
marginals, µ123(y1, y2, y3) and µ134(y1, y3, y4). We can then use this new graph to produce
the constraints on the marginals:

y1

(cid:88)
(cid:88)
(cid:88)
(cid:88)

y3

y1

µ123(y1, y2, y3) = µ23(y2, y3),

µ123(y1, y2, y3) = µ12(y1, y2),

µ134(y1, y3, y4) = µ34(y3, y4),

∀y2, y3;

∀y1, y2;

∀y3, y4;

∀y1, y3.

µ134(y1, y3, y4) = µ13(y1, y3),

y3

The new marginal variables appear only in the constraints; they do not add any new basis
functions nor change the objective function.

70

CHAPTER5. MARKOVNETWORKS

In general, the number of constraints introduced is exponential in the number of vari-
ables in the new cliques — the tree-width of the graph. Unfortunately, even sparsely con-
nected networks, for example 2D grids often used in image analysis, have large tree-width.
However, we can still solve the QP in the structured primal Eq. (5.6) or the structured
dual Eq. (5.12) deﬁned by an untriangulated graph. Such a formulation, which enforces
only local consistency of marginals, optimizes our objective only over a relaxation of the
marginal polytope. However, the learned parameters produce very accurate approximate
models in practice, as experiments in Ch. 8 demonstrate.

Note that we could also strengthen the untriangulated relaxation without introducing
an exponential number of constraints. For example, we can add positive semideﬁnite con-
straints on the marginals µ used by Wainwright and Jordan [2003], which tend to improve
the approximation of the marginal polytope. Although this and other more complex relax-
ations are a very interesting area of future development, they are often much more expen-
sive.

The approximate QP does not guarantee that the learned model using exact inference
minimizes the true objective: (upper-bound on) empirical risk plus regularization. But do
we really need these optimal parameters if we cannot perform exact inference? A more
useful goal is to make sure that training error is minimized using the approximate infer-
ence procedure via the untriangulated LP. We conjecture that the parameters learned by
the approximate QP in fact do that to some degree. For instance, consider the separable
case, where 100% accuracy is achievable on the training data by some parameter setting w
such that approximate inference (using the untriangulated LP) produces integral solutions.
Solving the problem as C → ∞ will ﬁnd this solution even though it may not be optimal
(in terms of the norm of the w) using exact inference. For C in intermediate range, the
formulation trades off fractionality of the untriangulated LP solutions with complexity of
the weights ||w||2.

5.5 Generalization bound

In this section, we show a generalization bound for the task of structured classiﬁcation that
allows us to relate the error rate on the training set to the generalization error. To the best

5.5. GENERALIZATIONBOUND

71

of our knowledge, this bound is the ﬁrst to deal with structured error, such as the Hamming
distance. Our analysis of Hamming loss allows to prove a signiﬁcantly stronger result than
previous bounds for the 0/1 loss, as we detail below.

Our goal in structured classiﬁcation is often to minimize the number of misclassiﬁed
labels, or the Hamming distance between y and h(x). An appropriate error function is the
average per-label loss

L(w, x, y) =

1
L

(cid:96)H(y, arg max

y(cid:48)

w(cid:62)f (x, y(cid:48))),

where L is the number of label variables in y. As in other generalization bounds for margin-
based classiﬁers, we relate the generalization error to the margin of the classiﬁer. Consider
an upper bound on the above loss:

L(w, x, y) ≤ L(w, x, y) =

max

y(cid:48): w(cid:62)f (y)≤w(cid:62)f (y(cid:48))

(cid:96)H(y, y(cid:48)).

1
L

This upper bound is tight if y = arg maxy(cid:48) w(cid:62)f (x, y(cid:48)), Otherwise, it is adversarial: it
picks from all y(cid:48) which are better (w(cid:62)f (y) ≤ w(cid:62)f (y(cid:48))), one that maximizes the Hamming
distance from y. We can now deﬁne a γ-margin per-label loss:

L(w, x, y) ≤ L(w, x, y) ≤ Lγ(w, x, y) =

y(cid:48): w(cid:62)f (y)≤w(cid:62)f (y(cid:48))+γ(cid:96)H (y,y(cid:48))

max

(cid:96)H(y, y(cid:48)).

1
L

it is tight if y = arg maxy(cid:48)[w(cid:62)f (x, y(cid:48)) +
This upper bound is even more adversarial:
(cid:96)H(y, y(cid:48))], otherwise, it picks from all y(cid:48) which are better when helped by γ(cid:96)H(y, y(cid:48)), one
that maximizes the Hamming distance from y. Note that the loss we minimize in the max-
margin formulation is very closely related (although not identical to) this upper bound.

We can now prove that the generalization accuracy of any hypothesis w is bounded by
its empirical γ-margin per-label loss, plus a term that grows inversely with the margin.To
state the bound, we need to deﬁne several other factors it depends upon. Let Nc be the
maximum number of cliques in G(x), Vc be the maximum number of values in a clique
|Yc|, q be the maximum number of cliques that have a variable in common, and Rc be
an upper-bound on the 2-norm of clique basis functions. Consider a ﬁrst-order sequence

72

CHAPTER5. MARKOVNETWORKS

model as an example, with L as the maximum length, and V the number of values a variable
takes. Then Nc = 2L − 1 since we have L node cliques and L − 1 edge cliques; Vc = V 2
because of the edge cliques; and q = 3 since nodes in the middle of the sequence participate
in 3 cliques: previous-current edge clique, node clique, and current-next edge clique.

Theorem 5.5.1 For the family of hypotheses parameterized by w, and any δ > 0, there
exists a constant K such that for any γ > 0 per-label margin, and m > 1 samples, the
expected per-label loss is bounded by:

(cid:115)

(cid:183)

ED[L(w, x, y)] ≤ ES[Lγ(w, x, y)] +

K
m

with probability at least 1 − δ.

c||w||2q2
R2

γ2

[ln m + ln Nc + ln Vc] + ln

1
δ

,

(cid:184)

Proof: See Appendix A.1 for the proof details and the exact value of the constant K.

The ﬁrst term upper bounds the training error of w. Low loss ES[Lγ(w, x, y)] at high
margin γ quantiﬁes the conﬁdence of the prediction model. The second term depends on
||w||/γ, which corresponds to the complexity of the classiﬁer (normalized by the margin
level). Thus, the result provides a bound to the generalization error that trades off the
effective complexity of the hypothesis space with the training error.

The proof uses a covering number argument analogous to previous results in SVMs [Zhang,

2002]. However we propose a novel method for covering the space of structured prediction
models by using a cover of the individual clique basis function differences ∆fi,c(yc). This
new type of cover is polynomial in the number of cliques, yielding signiﬁcant improve-
ments in the bound. Speciﬁcally, our bound has a logarithmic dependence on the number
of cliques (ln Nc) and depends only on the 2-norm of the basis functions per-clique (Rc).
This is a signiﬁcant gain over the previous result of Collins [2001] for 0/1 loss, which has
linear dependence (inside the square root) on the number of nodes (L), and depends on
the joint 2-norm of all of the basis functions for an example (which is ∼ NcRc). Such a
result was, until now, an open problem for margin-based sequence classiﬁcation [Collins,
m = O(1) (for example, in OCR, if the number
2001]. Finally, for sequences, note that if L
of instances is at least a constant times the length of a word), then our bound is independent
of the number of labels L.

5.6. RELATEDWORK

73

5.6 Related work

The application of margin-based estimation methods to parsing and sequence modeling was
pioneered by Collins [2001] using the Voted-Perceptron algorithm [Freund & Schapire,
1998]. He provides generalization guarantees (for 0/1 loss) that hold for separable case and
depend on the number of mistakes the perceptron makes before convergence. Remarkably,
the bound does not explicitly depend on the length of the sequence, although undoubtedly
the number of mistakes does.

Collins [2004] also suggested an SVM-like formulation (with exponentially many con-
straints) and a constraint generation method for solving it. His generalization bound (for
0/1 loss) based on the SVM-like margin, however, has linear dependence (inside the square
root) on the number of nodes (L). It also depends on the joint 2-norm of all of the basis
functions for an example (which is ∼ NcRc). By considering the more natural Hamming
loss, we achieve a much tighter analysis.

Altun et al. [2003] have applied the exponential-size formulation with constraint gen-
eration we described in Sec. 4.2.1 to problems natural language processing. In a follow-up
paper, Tsochantaridis et al. [2004] show that only a polynomial number of constraints are
needed to be generated to guarantee a ﬁxed level of precision of the solution. However,
the number of constraints in many important cases is several orders higher (in L) than in
the the approach we present. In addition, the corresponding problem needs to be resolved
(or at least approximately resolved) after each additional constraint is added, which is pro-
hibitively expensive for large number of examples and label variables.

The work of Guestrin et al. [2003] presents LP decompositions based on graphical
model structure for the value function approximation problem in factored MDPs (Markov
decision processes with structure). Describing the exact setting is beyond our scope, but it
sufﬁces to say that our original decomposition of the max-margin QP was inspired by the
proposed technique to transform an exponential set of constraints into a polynomial one
using a triangulated graph.

There has been a recent explosion of work in maximum conditional likelihood estima-
tion of Markov networks. The work of Lafferty et al. [2001] has inspired many applications
in natural language, computational biology, computer vision and relational modeling [Sha

74

CHAPTER5. MARKOVNETWORKS

& Pereira, 2003; Pinto et al., 2003; Kumar & Hebert, 2003; Sutton et al., 2004; Taskar
et al., 2002; Taskar et al., 2003b]. As in the case of logistic regression, maximum condi-
tional likelihood estimation for Markov networks can also be kernelized [Altun et al., 2004;
Lafferty et al., 2004]. However, the solutions are non-sparse and the proposed algorithms
are forced to use greedy selection of support vectors or heuristic pruning methods.

5.7 Conclusion

We use graph decomposition to derive an exact, compact, convex max-margin formulation
for Markov networks with sequence and other low-treewidth structure. Our formulation
avoids the exponential blow-up in the number of constraints in the max-margin QP that
plagued previous approaches. The seamless integration of kernels with graphical models
allows us to create very rich models that leverage the immense amount of research in kernel
design and graphical model decompositions. We also use approximate graph decomposi-
tion to derive a compact approximate formulation for Markov networks in which inference
is intractable.

We provide theoretical guarantees on the average per-label generalization error of our
models in terms of the training set margin. Our generalization bound signiﬁcantly tightens
previous results of Collins [Collins, 2001] and suggests possibilities for analyzing per-label
generalization properties of graphical models.

In the next chapter, we present an efﬁcient algorithm that exploits graphical model
inference and show experiments on a large handwriting recognition task that utilize the
powerful representational capability of kernels.

Chapter 6

M3N algorithms and experiments

Although the number of variables and constraints in the structured dual in Eq. (5.12) is
polynomial in the size of the data, unfortunately, for standard QP solvers, the problem is
often too large even for small training sets. Instead, we use a coordinate dual ascent method
analogous to the sequential minimal optimization (SMO) used for SVMs [Platt, 1999].

We apply our M3N framework and structured SMO algorithm to a handwriting recogni-
tion task. We show that our models signiﬁcantly outperform other approaches by incorpo-
rating high-dimensional decision boundaries of polynomial kernels over character images
while capturing correlations between consecutive characters.

6.1 Solving the M3N QP

Let us begin by considering the primal and dual QPs for multi-class SVMs:

(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)

(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)

(cid:88)

i,y

(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)

(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)2

αi(y)(cid:96)i(y) − 1
2 C

αi(y)∆fi(y)

min

||w||2 + C

1
2

(cid:88)

ξi

i

(cid:88)
(cid:88)

i,y

max

s.t.

s.t. w(cid:62)∆fi(y) ≥ (cid:96)(y) − ξi, ∀i, y.

αi(y) = 1, ∀i; αi(y) ≥ 0, ∀i, y.

y

The KKT conditions [Bertsekas, 1999; Boyd & Vandenberghe, 2004] provide sufﬁcient
and necessary criteria for optimality of a dual solution α. As we describe below, these
conditions have certain locality with respect to each example i, which allows us to perform

75

76

CHAPTER6. M3NALGORITHMSANDEXPERIMENTS

the search for optimal α by repeatedly considering one example at a time.

A feasible dual solution α and a primal solution deﬁned by:

(cid:88)

w = C

i,y
ξi = max

y

αi(y)∆fi(y)
[(cid:96)i(y) − w∆fi(y)] = max

(6.1)

[(cid:96)i(y) + w(cid:62)fi(y)] − w(cid:62)fi(y(i)),

y

are optimal if they satisfy the following two types of constraints:

αi(y) = 0 ⇒ w(cid:62)∆fi(y) > (cid:96)i(y) − ξi;
αi(y) > 0 ⇒ w(cid:62)∆fi(y) = (cid:96)i(y) − ξi.

(KKT1)

(KKT2),

We can express these conditions as

αi(y) = 0 ⇒ w(cid:62)fi(y) + (cid:96)i(y) < max
y(cid:48)
αi(y) > 0 ⇒ w(cid:62)fi(y) + (cid:96)i(y) = max
y(cid:48)

[w(cid:62)fi(y(cid:48)) + (cid:96)i(y(cid:48))];
[w(cid:62)fi(y(cid:48)) + (cid:96)i(y(cid:48))].

(KKT1)

(KKT2)

To simplify the notation, we deﬁne

vi(y) = w(cid:62)fi(y) + (cid:96)i(y);

vi(y) = max
y(cid:48)(cid:54)=y

[w(cid:62)fi(y(cid:48)) + (cid:96)i(y(cid:48))].

With these deﬁnitions, we have

αi(y) = 0 ⇒ vi(y) < vi(y);

(KKT1)

αi(y) > 0 ⇒ vi(y) ≥ vi(y);

(KKT2).

In practice, however, we will enforce KKT conditions up to a given tolerance 0 <  (cid:191) 1.

αi(y) = 0 ⇒ vi(y) ≤ vi(y) + ;

αi(y) > 0 ⇒ vi(y) ≥ vi(y) − .

(6.2)

Essentially, αi(y) can be zero only if vi(y) is at most  larger than the all others. Con-
versely, αi(y) can be non-zero only if vi(y) is at most  smaller than the all others.

Note that the normalization constraints on the dual variables α are local to each exam-
ple i. This allows us to perform dual block-coordinate ascent where a block corresponds to

6.1. SOLVINGTHEM3NQP

77

1. Initialize: αi(y) = 1I(y = y(i)), ∀ i, y.
2. Set violation = 0,
3. For each i,
4.
5.
6.
7. If violation = 1 goto 2.

Set violation = 1,
Find feasible α(cid:48)

If αi violates (KKT1) or (KKT2),

i such that Q(α(cid:48)

i, α−i) > Q(αi, α−i) and set αi = α(cid:48)
i.

Figure 6.1: Block-coordinate dual ascent.

the vector of dual variables αi for a single example i. The general form of block-coordinate
ascent algorithm as shown in Fig. 6.1 is essentially coordinate ascent on blocks αi, main-
taining the feasibility of the dual. When optimizing with respect to a single block i, the
objective function can be split into two terms:

Q(α) = Q(α−i) + Q(αi, α−i),

where α−i denotes all dual αk variables for k other than i. Only the second part of the
objective Q(αi, α−i) matters for optimizing with respect to αi. The algorithm starts with
a feasible dual solution α and improves the objective block-wise until all KKT condi-
tions are satisﬁed. Checking the constraints requires computing w and ξ from α according
to Eq. (6.1).

As long as the local ascent step over αi is guaranteed to improve the objective when
KKT conditions are violated, the algorithm will converge to the global maximum in a ﬁnite
number of steps (within the precision). This allows us to focus on efﬁcient updates to a
single block of αi at a time.

i(y) = αi(y) + λ(y). Note that

feasible. We can write the objective Q(α−i) + Q(α(cid:48)

y λ(y) = 0 and αi(y) + λ(y) ≥ 0 so that α(cid:48)

i is

i, α−i) in terms of λ and α:

Let α(cid:48)

(cid:88)

(cid:88)

(cid:80)

(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)(cid:88)
(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)

y

αj(y)(cid:96)j(y) +

j,y

y

λ(y)(cid:96)i(y) − 1
2

C

λ(y)∆fi(y) +

αj(y)∆fj(y)

.

(cid:88)

j,y

(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)

(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)2

78

CHAPTER6. M3NALGORITHMSANDEXPERIMENTS

(cid:80)

(cid:88)

(cid:195)(cid:88)

(cid:33)

(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)
(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)(cid:88)

y

− 1
2

C

(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)

(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)2

.

By dropping all terms that do not involve λ, and making the substitution
w = C

j,y αj(y)∆fj(y), we get:

(cid:80)

Since

λ(y)(cid:96)i(y) − w(cid:62)

λ(y)∆fi(y)

λ(y)∆fi(y)

y

y

y λ(y) = 0,(cid:88)

λ(y)∆fi(y) =

y

(cid:88)

y

λ(y)fi(y(i)) −

(cid:88)

y

λ(y)fi(y) = −

(cid:88)

y

λ(y)fi(y).

Below we also make the substitution vi(y) = w(cid:62)fi(y) + (cid:96)i(y) to get the optimization
problem for λ:

(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)
(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)(cid:88)

y

(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)
(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)2

max

s.t.

λ(y)vi(y) − 1
2

C

λ(y)fi(y)

λ(y) = 0; αi(y) + λ(y) ≥ 0, ∀y.

(cid:88)
(cid:88)

y

y

6.1.1 SMO

We do not need to solve the optimization subproblem above at each pass through the data.
All that is required is an ascent step, not a full optimization. Sequential Minimal Opti-
mization (SMO) approach takes an ascent step that modiﬁes the least number of variables.
In our case, we have the simplex constraint, so we must change at least two variables in
order to respect the normalization constraint (by moving weight from one dual variable to
another). We address a strategy for selecting the two variables in the next section, but for
now assume we have picked λ(y(cid:48)) and λ(y(cid:48)(cid:48)). Then we have δ = λ(y(cid:48)) = −λ(y(cid:48)(cid:48)) in order
to sum to 1. The optimization problem becomes a single variable quadratic program in δ:

max

s.t.

[vi(y(cid:48)) − vi(y(cid:48)(cid:48))]δ − 1
2
αi(y(cid:48)(cid:48)) − δ ≥ 0.
αi(y(cid:48)) + δ ≥ 0;

C||fi(y(cid:48)) − fi(y(cid:48)(cid:48))||2δ2

(6.3)

6.1. SOLVINGTHEM3NQP

79

Figure 6.2: Representative examples of the SMO subproblem. Horizonal axis represents δ
with two vertical lines depicting the upper and lower bounds c and d. Vertical axis repre-
sents the objective. Optimum either occurs at the maximum of the parabola if it is feasible
or the upper or lower bound otherwise.

With a = vi(y(cid:48)) − vi(y(cid:48)(cid:48)), b = C||fi(y(cid:48)) − fi(y(cid:48)(cid:48))||2, c = −αi(y(cid:48)), d = αi(y(cid:48)(cid:48)), we have:

max [aδ − b
2

δ2] s.t. c ≤ δ ≤ d,

(6.4)

where the optimum is achieved at the maximum of the parabola a/b if c ≤ a/b ≤ d or at
the boundary c or d (see Fig. 6.1.1). Hence the solution is given by simply clipping a/b:

δ∗ = max(c, min(d, a/b)).

The key advantage of SMO is the simplicity of this update. Computing the coefﬁcients
involves dot products (or kernel evaluations) to compute w(cid:62)fi(y(cid:48)) and w(cid:62)fi(y(cid:48)(cid:48)) as well as
(fi(y(cid:48)) − fi(y(cid:48)(cid:48)))(cid:62)(fi(y(cid:48)) − fi(y(cid:48)(cid:48))).

6.1.2 Selecting SMO pairs

How do we actually select such a pair to guarantee that we make progress in optimizing
the objective? Note that at least one of the assignments y must violate (KKT1) or (KKT2),

−0.5−0.4−0.3−0.2−0.100.10.20.30.40.5−2−1.5−1−0.500.580

CHAPTER6. M3NALGORITHMSANDEXPERIMENTS

1. Set violation = 0.
2. For each y,
3. KKT1: If αi(y) = 0 and vi(y) > vi(y) + ,
Set y(cid:48) = y and violation = 1 and goto 7.
4.
5. KKT2: If αi(y) > 0 and vi(y) < vi(y) − ,
Set y(cid:48) = y and violation = 2 and goto 7.
6.
7. If violation > 0,
8. For each y (cid:54)= y(cid:48),
9.
10.
11.
12.
13. Return y(cid:48) and y(cid:48)(cid:48).

If violation = 1 and αi(y) > 0,
Set y(cid:48)(cid:48) = y and goto 13.
If violation = 2 and vi(y) > vi(y(cid:48)),
Set y(cid:48)(cid:48) = y and goto 13.

Figure 6.3: SMO pair selection.

because otherwise αi is optimal with respect to the current α−i. The selection algorithm is
outlined in Fig. 6.3.

The ﬁrst variable in the pair, y(cid:48), corresponds to a violated condition, while the second
variable, y(cid:48)(cid:48), is chosen to guarantee that solving Eq. (6.3) will result in improving the ob-
jective. There are two cases, corresponding to violation of KKT1 and violation of KKT2.
Case KKT1. αi(y(cid:48)) = 0 but vi(y(cid:48)) > vi(y(cid:48)) + . This is the case where i, y(cid:48) is a not
support vector but should be. We would like to increase αi(y(cid:48)), so we need αi(y(cid:48)(cid:48)) > 0
y αi(y) = 1 and αi(y(cid:48)) = 0.
to borrow from. There will always be a such a y(cid:48)(cid:48) since
Since vi(y(cid:48)) > vi(y(cid:48)) + , vi(y(cid:48)) > vi(y(cid:48)(cid:48)) + , so the linear coefﬁcient in Eq. (6.4) is
a = vi(y(cid:48)) − vi(y(cid:48)(cid:48)) > . Hence the unconstrained maximum is positive a/b > 0. Since the
upper-bound d = αi(y(cid:48)(cid:48)) > 0, we have enough freedom to improve the objective.

(cid:80)

Case KKT2. αi(y(cid:48)) > 0 but vi(y(cid:48)) < vi(y(cid:48))− . This is the case where i, y(cid:48) is a support
vector but should not be. We would like to decrease αi(y(cid:48)), so we need vi(y(cid:48)(cid:48)) > vi(y(cid:48))
so that a/b < 0. There will always be a such a y(cid:48)(cid:48) since vi(y(cid:48)) < vi(y(cid:48)) − . Since the

6.1. SOLVINGTHEM3NQP

81

lower-bound c = −αi(y(cid:48)) < 0, again we have enough freedom to improve the objective.

Since at each iteration we are guaranteed to improve the objective if the KKT conditions
are violated and the objective is bounded, we can use the SMO in the block-coordinate
ascent algorithm to converge in a ﬁnite number of steps. To the best of our knowledge,
there are no upper bounds on the speed of convergence of SMO, but experimental evidence
has shown it a very effective algorithm for SVMs [Platt, 1999]. Of course, we can improve
the speed of convergence by adding heuristics in the selection of the pair, as long as we
guarantee that improvement is possible when KKT conditions are violated.

6.1.3 Structured SMO

Clearly, we cannot perform the above SMO updates in the space of α directly for the
structured problems, since the number of α variables is exponential. The constraints on µ
variables are much more complicated, since each µ participates not only in non-negativity
and normalization constraints, but also clique-agreement constraints. We cannot limit our
ascent steps to changing only two µ variables at a time, because in order to make a change
in one clique and stay feasible, we need to modify variables in overlapping cliques. For-
tunately, we can perform SMO updates on α variables implicitly in terms of the marginal
dual variables µ.

The diagram in Fig. 6.1.3 shows the abstract outline of the algorithm. The key steps in
the SMO algorithm are checking for violations of the KKT conditions, selecting the pair y(cid:48)
and y(cid:48)(cid:48), computing the corresponding coefﬁcients a, b, c, d and updating the dual. We will
show how to do these operations by doing all the hard work in terms of the polynomially
many marginal µi variables and auxiliary “max-marginals” variables.

Structured KKT conditions

As before, we deﬁne vi(y) = w(cid:62)fi(y) + (cid:96)i(y). The KKT conditions are, for all y:

αi(y) = 0 ⇒ vi(y) ≤ vi(y);

αi(y) > 0 ⇒ vi(y) ≥ vi(y).

(6.5)

82

CHAPTER6. M3NALGORITHMSANDEXPERIMENTS

Figure 6.4: Structured SMO diagram. We use marginals µ to select an appropriate pair of
instantiations y(cid:48) and y(cid:48)(cid:48) and reconstruct their α values. We then perform the simple SMO
update and project the result back onto the marginals.

Of course, we cannot check these explicitly. Instead, we deﬁne max-marginals for each
clique in the junction tree c ∈ T (i) and its values yc, as:

(cid:98)vi,c(yc) = max
We also deﬁne(cid:98)vi,c(yc) = maxy(cid:48)
the marginals µi by using Eq. (5.13). Both(cid:98)vi,c(yc) and(cid:98)αi,c(yc) can be computed by using

c) = maxy(cid:54)∼yc [w(cid:62)fi(y) + (cid:96)i(y)]. Note that we
do not explicitly represent αi(y), but we can reconstruct the maximum-entropy one from

c(cid:54)=yc(cid:98)vi,c(y(cid:48)

(cid:98)αi,c(yc) = max

y∼yc

[w(cid:62)fi(y) + (cid:96)i(y)],

y∼yc

αi(y).

the Viterbi algorithm (one pass propagation towards the root and one outwards from the
root [Cowell et al., 1999]). We can now express the KKT conditions in terms of the max-
marginals for each clique c ∈ T (i) and its values yc:

(cid:98)αi,c(yc) = 0 ⇒(cid:98)vi,c(yc) ≤(cid:98)vi,c(yc);

(cid:98)αi,c(yc) > 0 ⇒(cid:98)vi,c(yc) ≥(cid:98)vi,c(yc).

(6.6)

Theorem 6.1.1 The KKT conditions in Eq. (6.5) and Eq. (6.6) are equivalent.

Proof:

Eq. (6.5) ⇒ Eq. (6.6). Assume Eq. (6.5). Suppose, we have a violation of KKT1: for

some c, yc, (cid:98)αi,c(yc) = 0, but(cid:98)vi,c(yc) > (cid:98)vi,c(yc). Since (cid:98)αi,c(yc) = maxy∼yc αi(y) = 0,

select& liftSMOupdateproject6.1. SOLVINGTHEM3NQP

83

then αi(y) = 0, ∀y ∼ yc. Hence, by Eq. (6.5), vi(y) ≤ vi(y), ∀y ∼ yc. But(cid:98)vi,c(yc) >
(cid:98)vi,c(yc) implies the opposite: there exists y ∼ yc such that vi(y) > (cid:98)vi,c(yc), which also
Now suppose we have a violation of KKT2: for some i, yc,(cid:98)αi,c(yc) > 0, but(cid:98)vi,c(yc) <
(cid:98)vi,c(yc). Then vi(y) < vi(y), ∀y ∼ yc. But(cid:98)αi,c(yc) > 0 implies there exists y ∼ yc such

implies vi(y) > vi(y), a contradiction.

that αi(y) > 0. For that y, by Eq. (6.5), vi(y) ≥ vi(y), a contradiction.

Eq. (6.6) ⇒ Eq. (6.5). Assume Eq. (6.6). Suppose we have a violation of KKT1:
for some y, αi(y) = 0, but vi(y) > vi(y). This means that y is the optimum of vi(·),

hence (cid:98)vi,c(yc) = vi(y) > vi(y) > (cid:98)vi,c(yc), ∀c ∈ T (i), yc ∼ y. But by Eq. (6.6), if
(cid:98)vi,c(yc) >(cid:98)vi,c(yc), then we cannot have(cid:98)αi,c(yc) = 0. Hence all the y-consistent αi max-
marginals are positive (cid:98)αi,c(yc) > 0, ∀c ∈ T (i), and it follows that all the y-consistent

marginals µi are positive as well µi,c(yc) > 0, ∀c ∈ T (i) (since sum upper-bounds max).
c∈T (i) µi,c(yc)
But αi(y) =
c∈S(i) µi,s(ys) , so if all the y-consistent marginals are positive, then αi(y) > 0,
a contradiction.

(cid:81)
(cid:81)

c),(cid:98)vi,c(y(cid:48)

Now suppose we have a violation of KKT2: for some y, αi(y) > 0, but vi(y) <
vi(y). Since αi(y) > 0, we know that all the y-consistent αi max-marginals are positive

(cid:98)αi,c(yc) > 0, ∀c ∈ T (i). By Eq. (6.6),(cid:98)vi,c(yc) ≥(cid:98)vi,c(yc), ∀c ∈ T (i). Note that trivially
maxy(cid:48) vi(y(cid:48)) = max((cid:98)vi,c(y(cid:48)
(cid:98)vi,c(yc) ≥(cid:98)vi,c(yc), ∀c ∈ T (i), then maxy(cid:48) vi(y(cid:48)) =(cid:98)vi,c(yc), , ∀c ∈ T (i). That is,(cid:98)vi,c(yc)
is the optimal value. We will show that vi(y) =(cid:98)vi,c(yc), a contradiction. To show that this,
show that(cid:98)vi,a∪b(ya∪b) =(cid:98)vi,a(ya) =(cid:98)vi,b(yb). By chaining this equality from the root of the
tree to all the leaves, we get vi(y) =(cid:98)vi,c(yc) for any c.

we consider any two adjacent nodes in the tree T (i), cliques a and b, with a separator s, and

c)) for any clique c and clique assignment y(cid:48)

c. Since

We need to introduce some more notation to deal with the two parts of the tree induced
by cutting the edge between a and b. Let {A, B} be a partition of the nodes T (i) (cliques
of C(i)) resulting from removing the edge between a and b such that a ∈ A and b ∈ B.
We denote the two subsets of an assignment y as yA and yB (with overlap at ys). The
value of an assignment vi(y) can be decomposed into two parts: vi(y) = vi,A(yA) +
vi,B(yB), where vi,A(yA) and vi,B(yB) only count the contributions of their constituent

cliques. Take any maximizer, y(a) ∼ ya with vi(y(a)) = (cid:98)vi,a(ya) ≥ (cid:98)vi,a(ya) and any
maximizer y(b) ∼ yb with vi(y(b)) =(cid:98)vi,b(yb) ≥(cid:98)vi,b(yb), which by deﬁnition agree with y

84

CHAPTER6. M3NALGORITHMSANDEXPERIMENTS

A )+vi(y(a)

B ) and vi(y(b)) = vi(y(b)

A )+vi(y(b)
A ∪ y(a)

on the intersection s. We decompose the two associated values into the corresponding parts:
vi(y(a)) = vi(y(a)
B ). We create a new assignment
that combines the best of the two: y(s) = y(b)
A ) +
vi(y(a)

B ) = (cid:98)vi,s(ys), since we essentially ﬁxed the intersection s and maximized over the
rest of the variables in A and B separately. Now(cid:98)vi,a(ya) =(cid:98)vi,b(yb) ≥(cid:98)vi,s(ys) since they
B ) ≥
B ). Now we
A ∪ y(b)
B . The
B ) = vi(y(a)) = vi(y(b)).

are optimal as we said above. Hence we have vi(y(a)
B ) ≥ vi(y(a)
A ) ≥ vi(y(b)
vi(y(b)
create another assignment that clamps the value of both a and b: y(a∪b) = y(a)
value of this assignment is optimal vi(y(a∪b)) = vi(y(a)

B . Note that vi(y(s)) = vi(y(b)

B ) which implies that vi(y(a)

A ) and vi(y(b)

B ) = vi(y(b)

A ) + vi(y(a)

A ) + vi(y(b)

A ) + vi(y(a)

A ) + vi(y(b)

Structured SMO pair selection and update
As in multi-class problems, we will select the ﬁrst variable in the pair, y(cid:48), corresponding to
a violated condition, while the second variable, y(cid:48)(cid:48), to guarantee that solving Eq. (6.3) will
result in improving the objective. Having selected y(cid:48) and y(cid:48)(cid:48), the coefﬁcients for the one-
variable QP in Eq. (6.4) are a = vi(y(cid:48))−vi(y(cid:48)(cid:48)), b = C||fi(y(cid:48))−fi(y(cid:48)(cid:48))||2, c = −αi(y(cid:48)), d =
αi(y(cid:48)(cid:48)). As before, we enforce approximate KKT conditions in the algorithm in Fig. 6.5.
We have two cases, corresponding to violation of KKT1 and violation of KKT2.

Case KKT1.(cid:98)αi,c(y(cid:48)
so vi(y(cid:48)) = (cid:98)vi,c(y(cid:48)
(cid:80)
y αi(y) = 1 and αi(y(cid:48)) = 0. We can ﬁnd one by choosing yc for which(cid:98)αi,c(yc) > 0,

c) +  > vi(y(cid:48)) +  and αi(y(cid:48)) = 0. This is the case where
i, y(cid:48) is a not support vector but should be. We would like to increase αi(y(cid:48)), so we need
αi(y(cid:48)(cid:48)) > 0 to borrow from. There will always be a such a y(cid:48)(cid:48) (with y(cid:48)(cid:48)
c) since

c) = 0 but(cid:98)vi,c(y(cid:48)

c) > (cid:98)vi,c(y(cid:48)

c) >(cid:98)vi,c(y(cid:48)

c = arg maxy∼yc αi(y), αi(y(cid:48)(cid:48)) > 0. Since vi(y(cid:48)) ≥ vi(y(cid:48)) + ,
which guarantees that for y(cid:48)(cid:48)
vi(y(cid:48)) ≥ vi(y(cid:48)(cid:48)) + , so the linear coefﬁcient in Eq. (6.4) is a = vi(y(cid:48)) − vi(y(cid:48)(cid:48)) > . Hence
the unconstrained maximum is positive a/b > 0. Since the upper-bound d = αi(y(cid:48)(cid:48)) > 0,
we have enough freedom to improve the objective.

c)+. We have set y(cid:48) = arg maxy∼yc vi(y),

(cid:54)= y(cid:48)

Case KKT2.(cid:98)αi,c(y(cid:48)
so αi(y(cid:48)) = (cid:98)αi,c(y(cid:48)

c) <(cid:98)vi,c(y(cid:48)
c) > 0 but(cid:98)vi,c(y(cid:48)
c) > 0 and vi(y(cid:48)) < (cid:98)vi,c(y(cid:48)

c) < (cid:98)vi,c(y(cid:48)

c) −  < vi(y(cid:48)) − . This is the
case where i, y(cid:48) is a support vector but should not be. We would like to decrease αi(y(cid:48)),
so we need vi(y(cid:48)(cid:48)) > vi(y(cid:48)) so that a/b < 0. There will always be a such a y(cid:48)(cid:48) since

c)−. We have set y(cid:48) = arg maxy∼yc αi(y),

c

6.2. EXPERIMENTS

85

1. Set violation = 0.
2. For each c ∈ T (i), yc

3. KKT1: If(cid:98)αi,c(yc) = 0, and(cid:98)vi,c(yc) >(cid:98)vi,c(yc) + ,
5. KKT2: If(cid:98)αi,c(yc) > 0, and(cid:98)vi,c(yc) <(cid:98)vi,c(yc) − ,

Set y(cid:48)

4.

c = yc, y(cid:48) = arg maxy∼yc vi(y) and violation = 1 and goto 7.

Set y(cid:48)

c = yc, y(cid:48) = arg maxy∼yc αi(y) and violation = 2 and goto 7.

6.
7. If violation > 0,
8. For each yc (cid:54)= y(cid:48)
c,
9.
10.
11.
12.
13. Return y(cid:48) and y(cid:48)(cid:48).

Set y(cid:48)(cid:48)

If violation = 1 and(cid:98)αi,c(yc) > 0,
If violation = 2 and(cid:98)vi,c(yc) >(cid:98)vi,c(y(cid:48)

c = arg maxy∼yc αi(y) and goto 13.

c),

Set y(cid:48)(cid:48) = arg maxy∼yc vi(y) and goto 13.

Figure 6.5: Structured SMO pair selection.

vi(y(cid:48)) < vi(y(cid:48)) − . We can ﬁnd one by choosing yc for which(cid:98)vi,c(yc) > (cid:98)vi,c(yc) − ,
c = arg maxy∼yc vi(y), vi(y(cid:48)(cid:48)) > vi(y(cid:48)) − , Since the lower-

which guarantees that for y(cid:48)(cid:48)
bound c = −αi(y(cid:48)) < 0, again we have enough freedom to improve the objective.

Having computed new values α(cid:48)

i(y(cid:48)(cid:48)) = αi(y(cid:48)) − δ, we need
to project this change onto the marginal dual variables µi. The only marginal affected are
the ones consistent with y(cid:48) and/or y(cid:48)(cid:48), and the change is very simple:

i(y(cid:48)) = αi(y(cid:48)) + δ and α(cid:48)

i,c(yc) = µi,c(yc) + δ1I(yc ∼ y(cid:48)) − δ1I(yc ∼ y(cid:48)(cid:48)).
µ(cid:48)

6.2 Experiments

We selected a subset of ∼ 6100 handwritten words, with average length of ∼ 8 characters,
from 150 human subjects, from the data set collected by Kassel [1995]. Each word was
divided into characters, each character was rasterized into an image of 16 by 8 binary

86

CHAPTER6. M3NALGORITHMSANDEXPERIMENTS

(a)

(b)

(a) 3 example words from the OCR data set;

Figure 6.6:
(b) OCR: Average per-
character test error for logistic regression, CRFs, multiclass SVMs, and M3Ns, using linear,
quadratic, and cubic kernels.

pixels. (See Fig. 6.6(a).) In our framework, the image for each word corresponds to x, a
label of an individual character to Yj, and a labeling for a complete word to Y. Each label
Yj takes values from one of 26 classes {a, . . . , z}.

The data set is divided into 10 folds of ∼ 600 training and ∼ 5500 testing examples.
The accuracy results, summarized in Fig. 6.6(b), are averages over the 10 folds. We im-
plemented a selection of state-of-the-art classiﬁcation algorithms: independent label ap-
proaches, which do not consider the correlation between neighboring characters — lo-
gistic regression, multi-class SVMs as described in Eq. (2.9), and one-against-all SVMs
(whose performance was slightly lower than multi-class SVMs); and sequence approaches
— CRFs, and our proposed M3 networks. Logistic regression and CRFs are both trained by
maximizing the conditional likelihood of the labels given the features, using a zero-mean
diagonal Gaussian prior over the parameters, with a standard deviation between 0.1 and
1. The other methods are trained by margin maximization. Our features for each label
Yj are the corresponding image of ith character. For the sequence approaches (CRFs and
M3), we used an indicator basis function to represent the correlation between Yj and Yi+1.

00.050.10.150.20.250.30.35Log-RegCRFmSVMM^3NTest error (average per-character)linearquadraticcubic6.3. RELATEDWORK

87

For margin-based methods (SVMs and M3), we were able to use kernels (both quadratic
and cubic were evaluated) to increase the dimensionality of the feature space. We used
the structured SMO algorithm with about 30-40 iterations through the data. Using these
high-dimensional feature spaces in CRFs is not feasible because of the enormous number
of parameters.

Fig. 6.6(b) shows two types of gains in accuracy: First, by using kernels, margin-based
methods achieve a very signiﬁcant gain over the respective likelihood maximizing methods.
Second, by using sequences, we obtain another signiﬁcant gain in accuracy. Interestingly,
the error rate of our method using linear features is 16% lower than that of CRFs, and
about the same as multi-class SVMs with cubic kernels. Once we use cubic kernels our
error rate is 45% lower than CRFs and about 33% lower than the best previous approach.
For comparison, the previously published results, although using a different setup (e.g., a
larger training set), are about comparable to those of multiclass SVMs.

6.3 Related work

The kernel-adatron [Friess et al., 1998] and voted-perceptron algorithms [Freund & Schapire,
1998] for large-margin classiﬁers have a similar online optimization scheme. Collins
[2001] have applied voted-perceptron to structured problems in natural language. Although
head-to-head comparisons have not been performed, it seems that, empirically, less passes
(about 30-40) are needed for our algorithm than in the perceptron literature.

Recently, the Exponentiated Gradient [Kivinen & Warmuth, 1997] algorithm has been
adopted to solve our structured QP for max-margin estimation [Bartlett et al., 2004]. Al-
though the EG algorithm has attractive convergence properties, it has yet to be shown to
learn faster than Structured SMO, particularly in the early iterations through the dataset.

6.4 Conclusion

In this chapter, we address the large (though polynomial) size of our quadratic program
using an effective optimization procedure inspired by SMO. In our experiments with the
OCR task, our sequence model signiﬁcantly outperforms other approaches by incorporating

88

CHAPTER6. M3NALGORITHMSANDEXPERIMENTS

high-dimensional decision boundaries of polynomial kernels over character images while
capturing correlations between consecutive characters. Overall, we believe that M3 net-
works will signiﬁcantly further the applicability of high accuracy margin-based methods to
real-world structured data. In the next two chapters, we apply this framework to important
classes of Markov networks for spatial and relational data.

Chapter 7

Associative Markov networks

In the previous chapter, we considered applications of sequence-structured Markov net-
works, which allow very efﬁcient inference and learning. The chief computational bottle-
neck in applying Markov networks for other large-scale prediction problems is inference,
which is NP-hard in general networks suitable in a broad range of practical Markov network
structures, including grid-topology networks [Besag, 1986].

One can address the tractability issue by limiting the structure of the underlying net-
work. In some cases, such as the quad-tree model used for image segmentation [Bouman &
Shapiro, 1994], a tractable structure is determined in advance. In other cases (e.g., [Bach &
Jordan, 2001]), the network structure is learned, subject to the constraint that inference on
these networks is tractable. In many cases, however, the topology of the Markov network
does not allow tractable inference. For example, in hypertext, the network structure can
mirror the hyperlink graph, which is usually highly interconnected, leading to computa-
tionally intractable networks.

In this chapter, we show that optimal learning is feasible for an important subclass of
Markov networks — networks with attractive potentials. This subclass, called associa-
tive Markov networks (AMNs), contains networks of discrete variables with K labels and
arbitrary-size clique potentials with K parameters that favor the same labels for all vari-
ables in the clique. Such positive interactions capture the “guilt by association” pattern of
reasoning present in many domains, in which connected (“associated”) variables tend to
have the same label. AMNs are a natural ﬁt object recognition and segmentation, webpage

89

90

CHAPTER7. ASSOCIATIVEMARKOVNETWORKS

classiﬁcation, and many other applications.

In the max-margin estimation framework, the inference subtask is one of ﬁnding the
best joint (MAP) assignment to all of the variables in a Markov network. By contrast, other
learning tasks (e.g., maximizing the conditional likelihood of the target labels given the
features) require that we compute the posterior probabilities of different label assignments,
rather than just the MAP.

The MAP problem can naturally be expressed as an integer programming problem. We
use a linear program relaxation of this integer program in the min-max formulation. We
show that, for associative Markov networks of over binary variables (K = 2), this linear
program provides exact answers. To our knowledge, our method is the ﬁrst to allow training
Markov networks of arbitrary connectivity and topology. For the non-binary case (K > 2),
the approximate linear program is not guaranteed to be optimal but we can bound its relative
error. Our empirical results suggest that the solutions of the resulting approximate max-
margin formulation work well in practice.

We present an AMN-based method for object segmentation of complex from 3D range
data. By constraining the class of Markov networks to AMNs, our models can be learned
efﬁciently and at run-time, scale up to tens of millions of nodes and edges. The proposed
learning formulation effectively and directly learns to exploit a large set of complex surface
and volumetric features, while balancing the spatial coherence modeled by the AMN.

7.1 Associative networks

Associative interactions arise naturally in the context of image processing, where nearby
pixels are likely to have the same label [Besag, 1986; Boykov et al., 1999b]. In this setting,
a common approach is to use a generalized Potts model [Potts, 1952], which penalizes
assignments that do not have the same label across the edge: φij(k, l) = λij, ∀k (cid:54)= l and
φij(k, k) = 1, where λij ≤ 1.

For binary-valued Potts models, Greig et al. [1989] show that the MAP problem can be
formulated as a min-cut in an appropriately constructed graph. Thus, the MAP problem can
be solved exactly for this class of models in polynomial time. For L > 2, the MAP problem

7.2. LPINFERENCE

91

is NP-hard, but a procedure based on a relaxed linear program guarantees a factor 2 approx-
imation of the optimal solution [Boykov et al., 1999b; Kleinberg & Tardos, 1999]. Our
associative potentials extend the Potts model in several ways. Importantly, AMNs allow
different labels to have different attraction strength: φij(k, k) = λij(k), where λij(k) ≥ 1,
and φij(k, l) = 1, ∀k (cid:54)= l. This additional ﬂexibility is important in many domains, as
different labels can have very diverse afﬁnities. For example, foreground pixels tend to
have locally coherent values while background is much more varied.

In a second important extension, AMNs admit non-pairwise interactions between vari-
ables, with potentials over cliques involving m variables φ(µi1, . . . , µim). In this case, the
clique potentials are constrained to have the same type of structure as the edge potentials:
There are K parameters φc(k, . . . , k) = λc(k) ≥ 1 and the rest of the entries are set to 1.
In particular, using this additional expressive power, AMNs allow us to encode the pattern
of (soft) transitivity present in many domains. For example, consider the problem of pre-
dicting whether two proteins interact [Vazquez et al., 2003]; this probability may increase
if they both interact with another protein. This type of transitivity could be modeled by a
ternary clique that has high λ for the assignment with all interactions present.
More formally, we deﬁne associative functions and potentials as follows.

Deﬁnition 7.1.1 A function g : Y (cid:55)→ IR is associative for a graph G over K-ary variables if
it can be written as:

(cid:88)

K(cid:88)

v∈V

k=1

(cid:88)

K(cid:88)

c∈C\V

k=1

g(y) =

gv(k)1I(yv = k) +

gc(k)1I(yc = k, . . . , k);

gc(k) ≥ 0, ∀c ∈ C\V,

where V are the nodes and C are the cliques of the graph G. A set of potentials φ(y) is
associative if φ(y) = eg(y) and g(y) is associative.

7.2 LP Inference

We can write an integer linear program for the problem of ﬁnding the maximum of an
associative function g(y), where we have a “marginal” variable µv(k) for each node v ∈ V
and each label k, which indicates whether node v has value k, and µc(k) for each clique c

92

CHAPTER7. ASSOCIATIVEMARKOVNETWORKS

(containing more than one variable) and label k, which represents the event that all nodes
in the clique c have label k:

(cid:88)

K(cid:88)

(cid:88)

K(cid:88)

max

s.t.

µv(k)gv(k) +

µc(k)gc(k)

(7.1)

k=1

k=1

v∈V
c∈C\V
µc(k) ∈ {0, 1}, ∀c ∈ C, k;
µc(k) ≤ µv(k),

∀c ∈ C \ V, v ∈ c, k.

µv(k) = 1, ∀v ∈ V;

K(cid:88)
(cid:86)

k=1

Note that we substitute the constraint µc(k) =

v∈c µv(k) by linear inequality con-
straints µc(k) ≤ µv(k). This works because the coefﬁcient gc(k) is non-negative and we
are maximizing the objective function. Hence at the optimum, µc(k) = minv µv(k) , which
is equivalent to µc(k) =

v∈c µv(k), when µv(k) are binary.

(cid:86)

It can be shown that in the binary case, the linear relaxation of Eq. (7.1), (where the
constraints µc(k) ∈ {0, 1} are replaced by µc(k) ≥ 0), is guaranteed to produce an integer
solution when a unique solution exists.

Theorem 7.2.1 If K = 2, for any associative function g, the linear relaxation of Eq. (7.1)
has an integral optimal solution.

See Appendix A.2.1 for the proof. This result states that the MAP problem in binary AMNs
is tractable, regardless of network topology or clique size. In the non-binary case (L > 2),
these LPs can produce fractional solutions and we use a rounding procedure to get an
integral solution.

Theorem 7.2.2 If K > 2, for any associative function g, the linear relaxation of Eq. (7.1)
has a solution that is larger than the solution of the integer program by at most the number
of variables in the largest clique.

In the appendix, we also show that the approximation ratio of the rounding procedure is the
inverse of the size of the largest clique (e.g., 1
2 for pairwise networks). Although artiﬁcial
examples with fractional solutions can be easily constructed by using symmetry, it seems
that in real data such symmetries are often broken. In fact, in all our experiments with
L > 2 on real data, we never encountered fractional solutions.

(cid:88)

v∈V

(cid:88)

v∈V

(cid:88)

uv∈E

(cid:88)

uv∈E

7.3. MIN-CUTINFERENCE

93

7.3 Min-cut inference

We can also use efﬁcient min-cut algorithms to perform exact inference on the learned
models for K = 2 and approximate inference for K > 2. For simplicity, we focus on the
pairwise AMN case. We ﬁrst consider the case of binary AMNs, and later show how to use
the local search algorithm developed by Boykov et al. [1999a] to perform (approximate)
inference in the general multi-class case. For pairwise, binary AMNs, the objective of the
integer program in Eq. (7.1) is:

max

[µv(1)gv(1) + µv(2)gv(2)] +

[µuv(1)guv(1) + µuv(2)guv(2)].

(7.2)

7.3.1 Graph construction

We construct a graph in which the min-cut will correspond to the optimal MAP labeling
for the above objective. First, we recast the objective as minimization by simply reversing
the signs on the value of each θ.

min −

[µv(1)gv(1) + µv(2)gv(2)] −

[µuv(1)guv(1) + µuv(2)guv(2)].

(7.3)

The graph will consist of a vertex for each node in the AMN, along with the 1 and 2
terminals. In the ﬁnal (V1,V2) cut, the V1 set will correspond to label 1, and the V2 set will
correspond to label 2. We will show how to deal with the node terms (those depending only
on a single variable) and the edge terms (those depending on a pair of variables), and then
how to combine the two.

Node terms
Consider a node term −µv(1)gv(1) − µv(2)gv(2). Such a term corresponds to the node po-
tential contribution to our objective function for node v. For each node term corresponding
to node v we add a vertex v to the min-cut graph. We then look at ∆v = gv(1) − gv(2),
and create an edge of weight |∆v| from v to either 1 or 2, depending on the sign of ∆v.
The reason for that is that the ﬁnal min-cut graph must consist of only positive weights. An

94

CHAPTER7. ASSOCIATIVEMARKOVNETWORKS

Figure 7.1: Min-cut graph construction of node (left) and edge (right) terms.

example is presented in Fig. 7.3.1.

From Fig. 7.3.1, we see that if the AMN consisted of only node potentials, the graph
construction above would add an edge from each node to its more likely label. Thus if we
run min-cut, we would simply get a cut with cost 0, since for each introduced vertex we
have only one edge of positive weight to either 1 or 2, and we would always choose not to
cut any edges.

Edge Terms
Now consider an edge term of the form −µuv(1)guv(1) − µuv(2)guv(2). To construct a
min-cut graph for the edge term we will introduce two vertices u and v. We will connect
vertex u to 1 with an edge of weight guv(1), connect v to 2 with an edge of weight guv(2)
and connect u to v with an edge of weight guv(1) + guv(2). Fig. 7.3.1 shows an example.
Observe what happens when both nodes are on the V2 side of the cut: the value of the
min-cut is guv(1), which must be less than guv(2) or the min-cut would have placed them
both on the 1 side. When looking at edge terms in isolation, a cut that places each node
in different sets will not occur, but when we combine the graphs for node terms and edge
terms, such cuts will be possible.

We can take the individual graphs we created for node and edge terms and merge them

12v12v12uv7.3. MIN-CUTINFERENCE

95

by adding edge weights together (and treating missing edges as edges with weight 0). It
can be shown that the resulting graph will represent the same objective (in the sense that
running min-cut on it will optimize the same objective) as the sum of the objectives of each
graph. Since our MAP-inference objective is simply a sum of node and edge terms, merging
the node and edge term graphs will result in a graph in which min-cut will correspond to
the MAP labeling.

7.3.2 Multi-class case

The graph construction above ﬁnds the best MAP labeling for the binary case, but in prac-
tice we would often like to handle multiple classes in AMNs. One of the most effective
algorithms for minimizing energy functions like ours is the α-expansion algorithm pro-
posed by Boykov et al. [1999a]. The algorithm performs a series of “expansion” moves
each of which involves optimization over two labels, and it can be shown that it converges
to within a factor of 2 of the global minimum.

Expansion Algorithm
Consider a current labeling µ and a particular label k ∈ 1, . . . , K. Another labeling µ(cid:48) is
v (cid:54)= k implies
called an “α-expansion” move (following Boykov et al. [1999a]) from µ if µ(cid:48)
µ(cid:48)
v = µv (where µv is the label of the node v in the AMN.) In other words, a k-expansion
from a current labeling allows each label to either stay the same, or change to k.

The α-expansion algorithm cycles through all labels k in either a ﬁxed or random order,
and ﬁnds the new labeling whose objective has the lowest value. It terminates when there
is no α-expansion move for any label k that has a lower objective than the current labeling
(Fig. 7.2).

The key part of the algorithm is computing the best α-expansion labeling for a ﬁxed
k and a ﬁxed current labeling µ. The min-cut construction from earlier allows us to do
exactly that since an α-expansion move essentially minimizes a MAP-objective over two
labels: it either allows a node to retain its current label, or switch to the label α. In this
new binary problem we will let label 1 represent a node keeping its current label and label
2 will denote a node taking on the new label k. In order to construct the right coefﬁcients

96

CHAPTER7. ASSOCIATIVEMARKOVNETWORKS

1. Begin with arbitrary labeling µ

2. Set success := 0
3. For each label k ∈ {1, . . . K}

3.1 Compute ˆµ = arg min−g(µ(cid:48)) among µ(cid:48) within one α-expansion of µ.
3.2 If E(ˆµ) < E(µ), set µ := ˆµ and success := 1

4. If success = 1 goto 2.

5. Return µ

Figure 7.2: α-expansion algorithm

for the new binary objective we need to consider several factors. Below, let θ(cid:48)k
denote the node and edge coefﬁcients associated with the new binary objective:

(cid:48)k,k
i and θ
ij

i = θyi

i , and θ(cid:48)1

i = θα

◦ Node Potentials For each node i in the current labeling whose current label is not α,
we let θ(cid:48)0
i , where yi denotes the current label of node i, and θyi
denotes the coefﬁcient in the multiclass AMN MAP objective. Note that we ignore
nodes with label α altogether since an α-expansion move cannot change their label.
◦ Edge Potentials For each edge (i, j) ∈ E whose nodes have labels different from α,
. If the two nodes of the edge
, and if the two nodes currently have
ij = 0. For each edge (i, j) ∈ E in which exactly one of the
i of the

we add a new edge potential, with weights θ(cid:48)1
currently have the same label, we set θ(cid:48)0
ij = θyi,yj
different labels we let θ(cid:48)0
nodes has label α in the current labeling, we add θα,α
ij
node whose label is different from α.

, to the node potential θ(cid:48)1

ij = θα,α

ij

ij

After we have constructed the new binary MAP objective as above, we can apply the
min-cut construction from before to get the optimal labeling within one α-expansion from
the current one. Veksler [1999] shows that the α-expansion algorithm converges in O(N )
iterations where N is the number of nodes. As noted in Boykov et al. [1999a] and as we
have observed in our experiments, the algorithm terminates only after a few iterations with
most of the improvement occurring in the ﬁrst 2-3 expansion moves.

7.4. MAX-MARGINESTIMATION

97

7.4 Max-margin estimation

The potentials of the AMN are once again log-linear combinations of basis functions. We
will need the following assumption to ensure that w(cid:62)f (x, y) is associative:
Assumption 7.4.1 Basis functions f are component-wise associative for G(x) for any (x, y).

Recall that this implies that for cliques larger than one, all basis functions evaluate to 0
for assignments where the values of the nodes are not equal and are non-negative for the
assignments where the values of the nodes are equal. To ensure that w(cid:62)f (x, y) is associa-
tive, it is useful to separate the basis functions with support only on nodes from those with
support on larger cliques.

Deﬁnition 7.4.2 Let ˙f be the subset of basis functions f with support only on singleton
cliques:

˙f = {f ∈ f : ∀ x ∈ X , y ∈ Y, c ∈ C(G(x)), |c| > 1, fc(xc, yc) = 0}.

Let ¨f = f \ ˙f be the rest of the basis functions. Let { ˙w, ¨w} = w be the corresponding
subsets of parameters.

It is easy to verify that any non-negative combination of associative functions is asso-
ciative, and any combination of basis functions with support only on singleton cliques is
also associative, so we have:
Lemma 7.4.3 w(cid:62)f (x, y) is associative for G(x) for any (x, y) whenever Assumption 7.4.1
holds and ¨w ≥ 0.

We must make similar associative assumption on the loss function in order to guarantee

that the LP inference can handle it.
Assumption 7.4.4 The loss function (cid:96)(x(i), y(i), y) is associative for G(i) for all i.

In practice, this restriction is fairly mild, and the Hamming loss, which we use in general-
ization bounds and experiments, is associative.

98

CHAPTER7. ASSOCIATIVEMARKOVNETWORKS

Using the above Assumptions 7.4.1 and 7.4.4 and some algebra (see Appendix A.2.3

for derivation), we have the following max-margin QP for AMNs:

min

||w||2 + C

1
2

s.t. w(cid:62)∆fi,v(k) −

(cid:88)
(cid:88)
(cid:88)

c⊃v

i,v∈V (i)

ξi,v

(7.4)

mi,c,v(k) ≥ (cid:96)i,v(k) − ξi,v,
mi,c,v(k) ≥ (cid:96)i,c(k),

∀i, v ∈ V (i), k;

∀i, c ∈ C(i) \ V (i), k;
∀i, c ∈ C(i) \ V (i), v ∈ c, k;

¨w(cid:62)∆¨fi,c(k) +
mi,c,v(k) ≥ − ¨w(cid:62)¨fi,c(y(i)
¨w ≥ 0;

v∈c

c )/|c|,

where fi,c(k) = fi,c(k, . . . , k) and (cid:96)i,c(k) = (cid:96)i,c(k, . . . , k).

While this primal is more complex than the regular M3N factored primal in Eq. (5.4),
the basic structure of the ﬁrst two sets of constraints remains the same: we have local
margin requirements and “credit” passed around through messages mi,c,v(k). The extra
constraints are due to the associativity constraints on the resulting model.

The dual of Eq. (7.4) (see derivation in Sec. A.2.3) is given by:

(cid:88)

(cid:88)

(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)
(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)

(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)

(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)2

− C
2

(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)

(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)¨ν +

(cid:88)

(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)
(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)2

max

s.t.

µi,c(k)(cid:96)i,c(k) − C
2

i,v∈V (i), k

i,c∈C(i), k
µi,c(k) ≥ 0, ∀i, ∀c ∈ C(i), k;
µi,c(k) ≤ µi,v(k),
¨ν ≥ 0.

K(cid:88)

k=1

∀i, ∀c ∈ C(i) \ V (i), v ∈ c, k;

µi,v(k)∆˙fi,v(k)

µi,c(k)∆¨fi,c(k)

i,c∈C(i), k

µi,v(k) = 1, ∀i, ∀v ∈ V (i);

In the dual, there are marginals µ for each node and clique, for each value k, similar
to Eq. (5.12). However, the constraints are different, and not surprisingly, are essentially
the constraints from the inference LP relaxation in Eq. (7.1).

7.5. EXPERIMENTS

99

µi,v(k)∆˙fi,v(k);

¨w = ¨ν +

µi,c(k)∆¨fi,c(k).

(cid:88)

i,c∈C(i), k

(cid:80)

The dual and primal solutions are related by

(cid:88)

˙w =

i,v∈V (i), k

The ¨ν variables simply ensure that ¨w are positive (if any component
is negative, maximizing the objective will force the corresponding component of ¨ν to cancel
it out). Note that the objective can be written in terms of dot products of node basis func-
tions ∆˙fi,v(k)(cid:62)∆˙fj,¯v(¯k), so they can be kernelized. Unfortunately, the edge basis functions
cannot be kernelized because of the non-negativity constraint.

i,c∈C(i), k µi,c(k)∆¨fi,c(k)

For K = 2, the LP inference is exact, so that Eq. (7.4) learns exact max-margin weights
for Markov networks of arbitrary topology. For K > 2, the linear relaxation leads to a
strengthening of the constraints on w by potentially adding constraints corresponding to
fractional assignments as in the case of untriangualated networks. Thus, the optimal choice
w, ξ for the original QP may no longer be feasible, leading to a different choice of weights.
However, as our experiments show, these weights tend to do well in practice.

7.5 Experiments

We applied associative Markov networks to the task of terrain classiﬁcation. Terrain clas-
siﬁcation is very useful for autonomous mobile robots in real-world environments for path
planning, target detection, and as a pre-processing step for other perceptual tasks. The
Stanford Segbot Project1 has provided us with a laser range maps of the Stanford campus
collected by a moving robot equipped with SICK2 laser sensors Fig. 7.5. The data consists
of around 35 million points, represented as 3D coordinates in an absolute frame of refer-
ence Fig. 7.5. Thus, the only available information is the location of points. Each reading
was a point in 3D space, represented by its (x, y, z) coordinates in an absolute frame of
reference. Thus, the only available information is the location of points, which was fairly
noisy because of localization errors.

Our task is to classify the laser range points into four classes: ground, building, tree,

1Many thanks to Michael Montemerlo and Sebastian Thrun for sharing the data.

100

CHAPTER7. ASSOCIATIVEMARKOVNETWORKS

Figure 7.3: Segbot: roving robot equipped with SICK2 laser sensors.

and shrubbery. Since classifying ground points is trivial given their absolute z-coordinate
(height), we classify them deterministically by thresholding the z coordinate at a value
close to 0. After we do that, we are left with approximately 20 million non-ground points.
Each point is represented simply as a location in an absolute 3D coordinate system. The
features we use require pre-processing to infer properties of the local neighborhood of a
point, such as how planar the neighborhood is, or how much of the neighbors are close to
the ground. The features we use are invariant to rotation in the x-y plane, as well as the
density of the range scan, since scans tend to be sparser in regions farther from the robot.
Our ﬁrst type of feature is based on the principal plane around it. For each point we
sample 100 points in a cube of radius 0.5 meters. We run PCA on these points to get the
plane of maximum variance (spanned by the ﬁrst two principal components). We then par-
tition the cube into 3 × 3 × 3 bins around the point, oriented with respect to the principal
plane, and compute the percentage of points lying in the various sub-cubes. We use a num-
ber of features derived from the cube such as the percentage of points in the central column,
the outside corners, the central plane, etc. These features capture the local distribution well
and are especially useful in ﬁnding planes. Our second type of feature is based on a column

7.5. EXPERIMENTS

101

Figure 7.4: 3D laser scan range map of the Stanford Quad.

around each point. We take a cylinder of radius 0.25 meters, which extends vertically to
include all the points in a “column”. We then compute what percentage of the points lie in
various segments of this vertical column (e.g., between 2m and 2.5m). Finally, we also use
an indicator feature of whether or not a point lies within 2m of the ground. This feature is
especially useful in classifying shrubbery.

For training we select roughly 30 thousand points that represent the classes well: a
segment of a wall, a tree, some bushes. We considered three different models: SVM,
Voted-SVM and AMNs. All methods use the same set of features, augmented with a
quadratic kernel.

The ﬁrst model is a multi-class SVM with a quadratic kernel over the above features.
This model (Fig. 7.5, right panel and Fig. 7.7, top panel) achieves reasonable performance

102

CHAPTER7. ASSOCIATIVEMARKOVNETWORKS

Figure 7.5: Terrain classiﬁcation results showing Stanford Memorial Church obtained
with SVM, Voted-SVM and AMN models.
(Color legend: buildings/red, trees/green,
shrubs/blue, ground/gray).

in many places, but fails to enforce local consistency of the classiﬁcation predictions. For
example arches on buildings and other less planar regions are consistently confused for
trees, even though they are surrounded entirely by buildings.

We improved upon the SVM by smoothing its predictions using voting. For each point
we took its local neighborhood (we varied the radius to get the best possible results) and
assigned the point the label of the majority of its 100 neighbors. The Voted-SVM model
(Fig. 7.5, middle panel and Fig. 7.7, middle panel) performs slightly better than SVM: for
example, it smooths out trees and some parts of the buildings. Yet it still fails in areas like
arches of buildings where the SVM classiﬁer has a locally consistent wrong prediction.

The ﬁnal model is a pairwise AMN over laser scan points, with associative potentials
to ensure smoothness. Each point is connected to 6 of its neighbors: 3 of them are sampled
randomly from the local neighborhood in a sphere of radius 0.5m, and the other 3 are
sampled at random from the vertical cylinder column of radius 0.25m. It is important to
ensure vertical consistency since the SVM classiﬁer is wrong in areas that are higher off the

7.5. EXPERIMENTS

103

Figure 7.6: The running time (in seconds) of the min-cut-based inference algorithm for
different problem sizes. The problem size is the sum of the number of nodes and the
number of edges. Note the near linear performance of the algorithm and its efﬁciency even
for large models.

ground (due to the decrease in point density) or because objects tend to look different as we
vary their z-coordinate (for example, tree trunks and tree crowns look different). While we
experimented with a variety of edge features including various distances between points,
we found that even using only a constant feature performs well.

We trained the AMN model using CPLEX to solve the quadratic program; the train-
ing took about an hour on a Pentium 3 desktop. The inference over each segment was
performed using min-cut with α-expansion moves as described above. We used a pub-
licly available implementation of the min-cut algorithm, which uses bidirectional search
trees for augmenting paths (see Boykov and Kolmogorov [2004]). The implementation is
largely dominated by I/O time, with the actual min-cut taking less than two minutes even
for the largest segment. The performance is summarized in Fig. 7.6, and as we can see, it
is roughly linear in the size of the problem (number of nodes and number of edges).

We can see that the predictions of the AMN (Fig. 7.5, left panel and Fig. 7.7, bot-
tom panel) are much smoother: for example building arches and tree trunks are predicted

00.511.522.5x 107050100150200250Problem size (nodes and edges)Running time (seconds)Mincut inference performance104

CHAPTER7. ASSOCIATIVEMARKOVNETWORKS

correctly. We also hand-labeled around 180 thousand points of the test set (Fig. 7.8) and
computed accuracies of the predictions shown in Fig. 7.9 (excluding ground, which was
classiﬁed by pre-processing). The differences are dramatic: SVM: 68%, Voted-SVM: 73%
and AMN: 93%. See more results, including a ﬂy-through movie of the data, at
http://ai.stanford.edu/˜btaskar/3Dmap/.

7.6 Related work

Several authors have considered extensions to the Potts model. Kleinberg and Tardos
[1999] extend the multi-class Potts model to have more general edge potentials, under the
constraints that negative log of the edge potentials form a metric on the set of labels. They
also provide a solution based on a relaxed LP that has certain approximation guarantees.

More recently, Kolmogorov and Zabih [2002] showed how to optimize energy func-
tions containing binary and ternary interactions using graph cuts, as long as the parameters
satisfy a certain regularity condition. Our deﬁnition of associative potentials below also
satisﬁes the Kolmogorov and Zabih regularity condition for K = 2. However, the structure
of our potentials is simpler to describe and extend for the multi-class case. In fact, we can
extend our max-margin framework to estimate their more general potentials by expressing
inference as a linear program.

Our terrain classiﬁcation approach is most closely related to work in vision applying
conditional random ﬁelds (CRFs) to 2D images. Kumar and Hebert [2003] train CRFs
using a pseudo-likelihood approximation to the distribution P (Y | X) since estimating
the true conditional distribution is intractable. Unlike their work, our learning formulation
provides an exact and tractable optimization algorithm, as well as formal guarantees for
binary classiﬁcation problems. Moreover, unlike their work, our approach can also handle
multi-class problems in a straightforward manner.

7.7 Conclusion

In this chapter, we provide an algorithm for max-margin training of associative Markov
networks, a subclass of Markov networks that allows only positive interactions between

7.7. CONCLUSION

105

related variables. Our approach relies on a linear programming relaxation of the MAP
problem, which is the key component in the quadratic program associated with the max-
margin formulation. We thus provide a polynomial time algorithm which approximately
solves the maximum margin estimation problem for any associative Markov network. Im-
portantly, our method is guaranteed to ﬁnd the optimal (margin-maximizing) solution for all
binary-valued AMNs, regardless of the clique size or the connectivity. To our knowledge,
this algorithm is the ﬁrst to provide an effective learning procedure for Markov networks
of such general structure.

Our results in the binary case rely on the fact that the LP relaxation of the MAP problem
provides exact solutions. In the non-binary case, we are not guaranteed exact solutions, but
we can prove constant-factor approximation bounds on the MAP solution returned by the
relaxed LP. It would be interesting to see whether these bounds provide us with guarantees
on the quality (e.g., the margin) of our learned model.

We present large-scale experiments with terrain segmentation and classiﬁcation from
3D range data involving AMNs with tens of millions of nodes and edges. The class of
associative Markov networks appears to cover a large number of interesting applications.
We have explored only a computer vision application in this chapter, and consider another
one (hypertext classiﬁcation) in the next. It would be very interesting to consider other
applications, such as extracting protein complexes from protein-protein interaction data, or
predicting links in relational data. The min-cut based inference is able to handle very large
networks, and it is an interesting challenge to apply the algorithm to even larger models
and develop efﬁcient distributed implementations.

However, despite the prevalence of fully associative Markov networks, it is clear that
many applications call for repulsive potentials. While clearly we cannot introduce fully
general potentials into AMNs without running against the NP-hardness of the general prob-
lem, it would be interesting to see whether we can extend the class of networks we can learn
effectively.

106

CHAPTER7. ASSOCIATIVEMARKOVNETWORKS

Figure 7.7: Results from the SVM, Voted-SVM and AMN models.

7.7. CONCLUSION

107

Figure 7.8: Labeled part of the test set: ground truth (top) and SVM predictions (bottom).

108

CHAPTER7. ASSOCIATIVEMARKOVNETWORKS

Figure 7.9: Predictions of the Voted-SVM (top) and AMN (bottom) models.

Chapter 8

Relational Markov networks

In the previous chapters, we have seen how sequential and spatial correlation between
labels can be exploited for tremendous accuracy gains. In many other supervised learning
tasks, the entities to be labeled are related with each other in very complex ways, not just
sequentially or spatially. For example, in hypertext classiﬁcation, the labels of linked pages
are highly correlated. A standard approach is to classify each entity independently, ignoring
the correlations between them.
In this chapter, we present a framework that builds on
Markov networks and provides a ﬂexible language for modeling rich interaction patterns in
structured data. We provide experimental results on a webpage classiﬁcation task, showing
that accuracy can be signiﬁcantly improved by modeling relational dependencies.

Many real-world data sets are innately relational: hyperlinked webpages, cross-citations
in patents and scientiﬁc papers, social networks, medical records, and more. Such data con-
sist of entities of different types, where each entity type is characterized by a different set
of attributes. Entities are related to each other via different types of links, and the link
structure is an important source of information.

Consider a collection of hypertext documents that we want to classify using some set
of labels. Most naively, we can use a bag of words model, classifying each webpage solely
using the words that appear on the page. However, hypertext has a very rich structure that
this approach loses entirely. One document has hyperlinks to others, typically indicating
that their topics are related. Each document also has internal structure, such as a partition
into sections; hyperlinks that emanate from the same section of the document are even

109

110

CHAPTER8. RELATIONALMARKOVNETWORKS

more likely to point to similar documents. When classifying a collection of documents,
these are important cues, that can potentially help us achieve better classiﬁcation accuracy.
Therefore, rather than classifying each document separately, we want to provide a form of
collective classiﬁcation, where we simultaneously decide on the class labels of all of the
entities together, and thereby can explicitly take advantage of the correlations between the
labels of related entities.

We propose the use of a joint probabilistic model for an entire collection of related enti-
ties. We introduce the framework of relational Markov networks (RMNs), which compactly
deﬁnes a Markov network over a relational data set. The graphical structure of an RMN is
based on the relational structure of the domain, and can easily model complex patterns over
related entities. For example, we can represent a pattern where two linked documents are
likely to have the same topic. We can also capture patterns that involve groups of links: for
example, consecutive links in a document tend to refer to documents with the same label.
As we show, the use of an undirected graphical model avoids the difﬁculties of deﬁning
a coherent generative model for graph structures in directed models. It thereby allows us
tremendous ﬂexibility in representing complex patterns.

8.1 Relational classiﬁcation

Consider hypertext as a simple example of a relational domain. A relational domain is
deﬁned by a schema, which describes entities, their attributes and relations between them.
In our domain, there are two entity types: Doc and Link. If a webpage is represented as a
bag of words, Doc would have a set of boolean attributes Doc.HasWordk indicating whether
the word k occurs on the page. It would also have the label attribute Doc.Label, indicating
the topic of the page, which takes on a set of categorical values. The Link entity type has
two attributes: Link.From and Link.To, both of which refer to Doc entities.

In general, a schema speciﬁes of a set of entity types E = {E1, . . . , En}. Each type E is
associated with three sets of attributes: content attributes E.X (for example, Doc.HasWordk),
label attributes E.Y (for example, Doc.Label), and reference attributes E.R (for example,
Link.To). For simplicity, we restrict label and content attributes to take on categorical val-
ues. Reference attributes include a special unique key attribute E.K that identiﬁes each

8.1. RELATIONALCLASSIFICATION

111

entity. Other reference attributes E.R refer to entities of a single type E(cid:48) = Range(E.R)
and take values in Domain(E(cid:48).K).

An instantiation I of a schema E speciﬁes the set of entities I(E) of each entity type
E ∈ E and the values of all attributes for all of the entities. For example, an instantiation
of the hypertext schema is a collection of webpages, specifying their labels, words they
contain and links between them. We will use I.X, I.Y and I.R to denote the content,
label and reference attributes in the instantiation I; I.x, I.y and I.r to denote the values
of those attributes. The component I.r, which we call an instantiation skeleton or instan-
tiation graph, speciﬁes the set of entities (nodes) and their reference attributes (edges). A
hypertext instantiation graph speciﬁes a set of webpages and links between them, but not
their words or labels. Taskar et al. [2001] suggest the use of probabilistic relational mod-
els (PRMs) for the collective classiﬁcation task. PRMs [Koller & Pfeffer, 1998; Friedman
et al., 1999; Getoor et al., 2002] are a relational extension of Bayesian networks [Pearl,
1988]. A PRM speciﬁes a probability distribution over instantiations consistent with a
given instantiation graph by specifying a Bayesian-network-like template-level probabilis-
tic model for each entity type. Given a particular instantiation graph, the PRM induces
a large Bayesian network over that instantiation that speciﬁes a joint probability distribu-
tion over all attributes of all of the entities. This network reﬂects the interactions between
related instances by allowing us to represent correlations between their attributes.

In our hypertext example, a PRM might use a naive Bayes model for words, with a di-
rected edge between Doc.Label and each attribute Doc.HadWordk; each of these attributes
would have a conditional probability distribution P (Doc.HasWordk | Doc.Label) associ-
ated with it, indicating the probability that word k appears in the document given each of
the possible topic labels. More importantly, a PRM can represent the inter-dependencies
between topics of linked documents by introducing an edge from Doc.Label to Doc.Label
of two documents if there is a link between them. Given a particular instantiation graph
containing some set of documents and links, the PRM speciﬁes a Bayesian network over all
of the documents in the collection. We would have a probabilistic dependency from each
document’s label to the words on the document, and a dependency from each document’s
label to the labels of all of the documents to which it points. Taskar et al. show that this
approach works well for classifying scientiﬁc documents, using both the words in the title

112

CHAPTER8. RELATIONALMARKOVNETWORKS

and abstract and the citation-link structure.

However the application of this idea to other domains, such as webpages, is problematic
since there are many cycles in the link graph, leading to cycles in the induced “Bayesian
network”, which is therefore not a coherent probabilistic model. Getoor et al. [2001] sug-
gest an approach where we do not include direct dependencies between the labels of linked
webpages, but rather treat links themselves as random variables. Each two pages have a
“potential link”, which may or may not exist in the data. The model deﬁnes the probability
of the link existence as a function of the labels of the two endpoints. In this link exis-
tence model, labels have no incoming edges from other labels, and the cyclicity problem
disappears. This model, however, has other fundamental limitations. In particular, the re-
sulting Bayesian network has a random variable for each potential link — N 2 variables for
collections containing N pages. This quadratic blowup occurs even when the actual link
graph is very sparse. When N is large (e.g., the set of all webpages), a quadratic growth is
intractable. Even more problematic are the inherent limitations on the expressive power im-
posed by the constraint that the directed graph must represent a coherent generative model
over graph structures. The link existence model assumes that the presence of different
edges is a conditionally independent event. Representing more complex patterns involving
correlations between multiple edges is very difﬁcult. For example, if two pages point to the
same page, it is more likely that they point to each other as well. Such interactions between
many overlapping triples of links do not ﬁt well into the generative framework.

Furthermore, directed models such as Bayesian networks and PRMs are usually trained
to optimize the joint probability of the labels and other attributes, while the goal of clas-
siﬁcation is a discriminative model of labels given the other attributes. The advantage
of training a model only to discriminate between labels is that it does not have to trade
off between classiﬁcation accuracy and modeling the joint distribution over non-label at-
tributes. In many cases, discriminatively trained models are more robust to violations of
independence assumptions and achieve higher classiﬁcation accuracy than their generative
counterparts.

8.2. RELATIONALMARKOVNETWORKS

113

Figure 8.1: An unrolled Markov net over linked documents. The links follow a common
pattern: documents with the same label tend to link to each other more often.

8.2 Relational Markov networks

We now extend the framework of Markov networks to the relational setting. A relational
Markov network (RMN) speciﬁes a conditional distribution over all of the labels of all
of the entities in an instantiation given the relational structure and the content attributes.
(We provide the deﬁnitions directly for the conditional case, as the unconditional case is a
special case where the set of content attributes is empty.) Roughly speaking, it speciﬁes the
cliques and potentials between attributes of related entities at a template level, so a single
model provides a coherent distribution for any collection of instances from the schema.

For example, suppose that pages with the same label tend to link to each other, as
in Fig. 8.1. We can capture this correlation between labels by introducing, for each link, a
clique between the labels of the source and the target page. The potential on the clique will
have higher values for assignments that give a common label to the linked pages.

To specify what cliques should be constructed in an instantiation, we will deﬁne a no-
tion of a relational clique template. A relational clique template speciﬁes tuples of variables
in the instantiation by using a relational query language. For our link example, we can write
the template as a kind of SQL query:

SELECT doc1.Category, doc2.Category

Label 1Label 2Label 3114

CHAPTER8. RELATIONALMARKOVNETWORKS

FROM Doc doc1, Doc doc2, Link link
WHERE link.From = doc1.Key and link.To = doc2.Key

Note the three clauses that deﬁne a query: the FROM clause speciﬁes the cross prod-
uct of entities to be ﬁltered by the WHERE clause and the SELECT clause picks out the
attributes of interest. Our deﬁnition of clique templates contains the corresponding three
parts.

A relational clique template C = (F, W, S) consists of three components:
◦ F = {Fi} — a set of entity variables, where an entity variable Fi is of type E(Fi).
◦ W(F.R) — a boolean formula using conditions of the form Fi.Rj = Fk.Rl.
◦ F.S ⊆ F.X ∪ F.Y — a selected subset of content and label attributes in F.

For the clique template corresponding to the SQL query above, F consists of doc1, doc2
and link of types Doc, Doc and Link, respectively. W(F.R) is link.F rom = doc1.Key ∧
link.T o = doc2.Key and F.S is doc1.Category and doc2.Category.
A clique template speciﬁes a set of cliques in an instantiation I:

C(I) ≡ {c = f .S : f ∈ I(F) ∧ W(f .r)},

where f is a tuple of entities {fi} in which each fi is of type E(Fi); I(F) = I(E(F1)) ×
. . .×I(E(Fn)) denotes the cross-product of entities in the instantiation; the clause W(f .r)
ensures that the entities are related to each other in speciﬁed ways; and ﬁnally, f .S selects
the appropriate attributes of the entities. Note that the clique template does not specify the
nature of the interaction between the attributes; that is determined by the clique potentials,
which will be associated with the template.

This deﬁnition of a clique template is very ﬂexible, as the WHERE clause of a tem-
plate can be an arbitrary predicate. It allows modeling complex relational patterns on the
instantiation graphs. To continue our webpage example, consider another common pattern
in hypertext: links in a webpage tend to point to pages of the same category. This pattern
can be expressed by the following template:

SELECT doc1.Category, doc2.Category

8.2. RELATIONALMARKOVNETWORKS

115

FROM Doc doc1, Doc doc2, Link link1, Link link2
WHERE link1.From = link2.From and link1.To = doc1.Key

and link2.To = doc2.Key and not doc1.Key = doc2.Key

Depending on the expressive power of our template deﬁnition language, we may be able
to construct very complex templates that select entire subgraph structures of an instantia-
tion. We can easily represent patterns involving three (or more) interconnected documents
without worrying about the acyclicity constraint imposed by directed models. Since the
clique templates do not explicitly depend on the identities of entities, the same template can
select subgraphs whose structure is fairly different. The RMN allows us to associate the
same clique potential parameters with all of the subgraphs satisfying the template, thereby
allowing generalization over a wide range of different structures.

A Relational Markov network (RMN) M = (C, Φ) speciﬁes a set of clique templates

C and corresponding potentials Φ = {φC}C∈C to deﬁne a conditional distribution:

P (I.y | I.x,I.r)
Z(I.x,I.r)

=

1

(cid:89)

(cid:89)

C∈C

c∈C(I)

φC(I.xc,I.yc)

where Z(I.x,I.r) is the normalizing partition function:

Z(I.x,I.r) =

φC(I.xc,I.y(cid:48)
c)

(cid:88)

(cid:89)

(cid:89)

I.y(cid:48)

C∈C

c∈C(I)

.

Using the log-linear representation of potentials, φC(VC) = exp{w(cid:62)

C fC(VC)}, we can

write

where

log P (I.y | I.x,I.r) = w(cid:62)f (I.x,I.y,I.r) − log Z(I.x,I.r)

fC(I.x,I.y,I.r) =

fC(I.xc,I.yc)

(cid:88)

c∈C(I)

is the sum over all appearances of the template C(I) in the instantiation, and f is the vector

116

CHAPTER8. RELATIONALMARKOVNETWORKS

of all fC.

Given a particular instantiation I of the schema, the RMN M produces an unrolled
Markov network over the attributes of entities in I. The cliques in the unrolled network
are determined by the clique templates C. We have one clique for each c ∈ C(I), and
all of these cliques are associated with the same clique potential φC.
In our webpage
example, an RMN with the link basis function described above would deﬁne a Markov net
in which, for every link between two pages, there is an edge between the labels of these
pages. Fig. 8.1 illustrates a simple instance of this unrolled Markov network.

8.3 Approximate inference and learning

Applying both maximum likelihood and maximum margin learning in the relational setting
is requires inference in very large and complicated networks, where exact inference is
typically intractable. We therefore resort to approximate methods.

Maximum likelihood estimation

For maximum likelihood learning, we need to compute basis function expectations, not
just the most likely assignment. There is a wide variety of approximation schemes for this
problem, including MCMC and variational methods. We chose to use belief propagation
for its simplicity and relative efﬁciency and accuracy. Belief Propagation (BP) is a local
message passing algorithm introduced by Pearl [1988]. It is guaranteed to converge to the
correct marginal probabilities for each node only for singly connected Markov networks.
However, recent analysis [Yedidia et al., 2000] provides some theoretical justiﬁcation. Em-
pirical results [Murphy et al., 1999] show that it often converges in general networks, and
when it does, the marginals are a good approximation to the correct posteriors. As our
results in Sec. 8.4 show, this approach works well in our domain. We refer the reader to
Yedidia et al. for a detailed description of the BP algorithm.

We provide a brief outline of one variant of BP, referring to [Murphy et al., 1999]
for more details. For simplicity, we assume a pairwise network where all potentials are
associated only with nodes and edges given by:

8.3. APPROXIMATEINFERENCEANDLEARNING

117

(cid:89)

ij

1
Z

(cid:89)

i

ψi(Yi)

ψij(Yi, Yj)

P (Y1, . . . , Yn) =

where ij ranges over the edges of the network and ψij(Yi, Yj) = φ(xij, Yi, Yj), ψi(Yi) =
φ(xi, Yi).

The belief propagation algorithm is very simple. At each iteration, each node Yi sends

the following messages to all its neighbors N (i):

(cid:88)

yi

(cid:89)

k∈N (i)−j

mij(Yj) ← α

ψij(yi, Yj)ψi(yi)

mki(Yi)

where α is a (different) normalizing constant. This process is repeated until the messages
converge. At any point in the algorithm, the marginal distribution of any node Yi is approx-
imated by

bi(Yi) = αψi(Yi)

mki(Yi)

and the marginal distribution of a pair of nodes connected by an edge is approximated by

(cid:89)

k∈N (i)

(cid:89)

(cid:89)

bij(Yi, Yj) = αψij(Yi, Yj)ψi(Yi)ψj(Yj)

mki(Yi)

mlj(Yj)

k∈N (i)−j

l∈N (j)−i

These approximate marginals are precisely what we need for the computation of the
basis function expectations and performing classiﬁcation. Computing the expected basis
function expectations involves summing their expected values for each clique using the
approximate marginals bi(Yi) and bij(Yi, Yj). Similarly, we use maxyi bi(Yi) at prediction
time. Note that we can also max − product variant of loopy BP, with

mij(Yj) ← α max

yi

ψij(yi, Yj)ψi(yi)

mki(Yi)

k∈N (i)−j

(cid:89)

to compute approximate posterior “max”-marginals and use those for prediction. In our
experiments, this results in less accurate classiﬁcation, so we use posterior marginal pre-
diction.

118

CHAPTER8. RELATIONALMARKOVNETWORKS

Maximum margin estimation

For maximum margin estimation, we used approximate LP inference inside the max-margin
QP, using commercial Ilog CPLEX software to solve it. For networks with general poten-
tials, we used the untriangulated LP we described in Sec. 5.4. The untriangulated LP
produced fractional solutions for inference on the test data in several settings, which we
rounded independently for each label. For networks with attractive potentials (AMNs), we
used the LP in Sec. 7.2, which always produced integral solutions on test data.

8.4 Experiments

We tried out our framework on the WebKB dataset [Craven et al., 1998], which is an in-
stance of our hypertext example. The data set contains webpages from four different Com-
puter Science departments: Cornell, Texas, Washington and Wisconsin. Each page has a
label attribute, representing the type of webpage which is one of course, faculty, student,
project or other. The data set is problematic in that the category other is a grab-bag of
pages of many different types. The number of pages classiﬁed as other is quite large,
so that a baseline algorithm that simply always selected other as the label would get an
average accuracy of 75%. We could restrict attention to just the pages with the four other
labels, but in a relational classiﬁcation setting, the deleted webpages might be useful in
terms of their interactions with other webpages. Hence, we compromised by eliminating
all other pages with fewer than three outlinks, making the number of other pages com-
mensurate with the other categories. The resulting category distribution is: course (237),
faculty (148), other (332), research-project (82) and student (542). The number of remain-
ing pages for each school are: Cornell (280), Texas (292), Washington (315) and Wisconsin
(454). The number of links for each school are: Cornell (574), Texas (574), Washington
(728) and Wisconsin (1614).

For each page, we have access to the entire html of the page and the links to other
pages. Our goal is to collectively classify webpages into one of these ﬁve categories. In all
of our experiments, we learn a model from three schools and test the performance of the
learned model on the remaining school, thus evaluating the generalization performance of

8.4. EXPERIMENTS

119

the different models. We used C ∈ [0.1, 10] and took the best setting for all models.

Unfortunately, we cannot directly compare our accuracy results with previous work
because different papers use different subsets of the data and different training/test splits.
However, we compare to standard text classiﬁers such as Naive Bayes, Logistic Regression,
and Support Vector Machines, which have been demonstrated to be successful on this data
set [Joachims, 1999].

8.4.1 Flat models

The simplest approach we tried predicts the categories based on just the text content on
the webpage. The text of the webpage is represented using a set of binary attributes that
indicate the presence of different words on the page. We found that stemming and feature
selection did not provide much beneﬁt and simply pruned words that appeared in fewer
than three documents in each of the three schools in the training data. We also experi-
mented with incorporating meta-data: words appearing in the title of the page, in anchors
of links to the page and in the last header before a link to the page [Yang et al., 2002].
Note that meta-data, although mostly originating from pages linking into the considered
page, are easily incorporated as features, i.e.
the resulting classiﬁcation task is still ﬂat
feature-based classiﬁcation. Our ﬁrst experimental setup compares three well-known text
classiﬁers — Naive Bayes, linear support vector machines (Svm), and logistic regression
(Logistic) — using words and meta-words. The results, shown in Fig. 8.2, show that the
two discriminative approaches outperform Naive Bayes. Logistic and Svm give very sim-
ilar results. The average error over the 4 schools was reduced by around 4% by introducing
the meta-data attributes.

Incorporating meta-data gives a signiﬁcant improvement, but we can take additional
advantage of the correlation in labels of related pages by classifying them collectively. We
want to capture these correlations in our model and use them for transmitting informa-
tion between linked pages to provide more accurate classiﬁcation. We experimented with
several relational models.

120

CHAPTER8. RELATIONALMARKOVNETWORKS

Figure 8.2: Comparison of Naive Bayes, Svm, and Logistic on WebKB, with and without
meta-data features. (Only averages over the 4 schools are shown here.)

8.4.2 Link model

Our ﬁrst model captures direct correlations between labels of linked pages. These corre-
lations are very common in our data: courses and research projects almost never link to
each other; faculty rarely link to each other; students have links to all categories but mostly
courses. The Link model, shown in Fig. 8.1, captures this correlation through links: in
addition to the local bag of words and meta-data attributes, we introduce a relational clique
template over the labels of two pages that are linked.We train this model using maximum
conditional likelihood (labels given the words and the links) and maximum margin.

We also compare to a directed graphical model to contrast discriminative and genera-
tive models of relational structure. The Exists-ML model is a (partially) generative model
proposed by Getoor et al.
[2001]. For each page, a logistic regression model predicts
the page label given the words and meta-features. Then a simple generative model speci-
ﬁes a probability distribution over the existence of links between pages conditioned on both
pages’ labels. Concretely, we learn the probability of existence of a link between two pages
given their labels. Note that this model does not require inference during learning. Max-
imum likelihood estimation (with regularization) of the generative component is closed

00.050.10.150.20.250.30.35Naïve BayesSvmLogisticTest ErrorWordsWords+Meta8.4. EXPERIMENTS

121

Figure 8.3: Comparison of ﬂat versus collective classiﬁcation on WebKB: SVM, Exists
model with logistic regression and the Link model estimated using the maximum likelihood
(ML) and the maximum margin (MM) criteria.

form given appropriate co-occurrence counts of linked pages’ labels. However, the predic-
tion phase is much more expensive, since the resulting graphical model includes edges not
only for the existing hyperlinks, but also those that do not exist. Intuitively, observing the
link structure directly correlates all page labels in a website, linked or not. By contrast,
the Link model avoids this problem by only modeling the conditional distribution given the
existing links.

Fig. 8.3 shows a gain in accuracy from SVMs to the Link model by using the corre-
lations between labels of linked web pages. There is also very signiﬁcant additional gain
by using maximum margin training: the error rate of Link-MM is 40% lower than that of
Link-ML, and 51% lower than multi-class SVMs. The Exists model doesn’t perform very
well in comparison. This can be attributed to the simplicity of the generative model and the
difﬁculty of the resulting inference problem.

8.4.3 Cocite model

The second relational model uses the insight that a webpage often has internal structure
that allows it to be broken up into sections. For example, a faculty webpage might have

0%5%10%15%20%25%30%CorTexWasWisAverage ErrorExists-MLSVMLink-MLLink-MM122

CHAPTER8. RELATIONALMARKOVNETWORKS

Figure 8.4: Comparison of Naive Bayes, Svm, and Logistic on WebKB, with and without
meta-data features. (Only averages over the 4 schools are shown here.)

one section that discusses research, with a list of links to all of the projects of the faculty
member, a second section might contain links to the courses taught by the faculty member,
and a third to his advisees. We can view a section of a webpage as a ﬁne-grained version of
Kleinberg’s hub [Kleinberg, 1999] (a page that contains a lot of links to pages of particular
category). Intuitively, if two pages are cocited, or linked to from the same section, they are
likely to be on similar topics. Note that we expect the correlation between the labels in this
case to be positive, so we can use AMN-type potentials in the max-margin estimation. The
Cocite model captures this type of correlation.

To take advantage of this trend, we need to enrich our schema by adding the attribute
Section to Link to refer to the section number it appears in. We deﬁned a section as a
sequence of three or more links that have the same path to the root in the html parse tree.
In the RMN, we have a relational clique template deﬁned by:

SELECT doc1.Category, doc2.Category
FROM Doc doc1, Doc doc2, Link link1, Link link2
WHERE link1.From = link2.From and link1.Section = link2.Section and

link1.To = doc1.Key and link2.To = doc2.Key and not doc1.Key = doc2.Key

We compared the performance of SVM, Cocite-ML and Cocite-MM. The results,

0%5%10%15%20%25%CorTexWasWisAverage ErrorSVMCocite-MLCocite-MM8.5. RELATEDWORK

123

shown in Fig. 8.4, also demonstrate signiﬁcant improvements of the relational models over
the SVM. The improvement is present when testing on each of the schools. Again, maxi-
mum likelihood trained model Cocite-ML achieves a worse test error than maximum mar-
gin Cocite-MM model, which shows a 30% relative reduction in test error over SVM.
We note that, in our experiments, the learned Cocite-MM weights never produced frac-
tional solutions when used for inference, which suggests that the optimization successfully
avoided problematic parameterizations of the network, even in the case of the non-optimal
multi-class relaxation.

8.5 Related work

Our RMN representation is most closely related to the work on PRMs [Koller & Pfeffer,
1998]. Later work showed how to efﬁciently learn model parameters and structure (equiv-
alent of clique selection in Markov networks) from data [Friedman et al., 1999]. Getoor
et al. [2002] propose several generative models of relational structure. Their approach
easily captures the dependence of link existence on attributes of entities. However there
are many patterns that we are difﬁcult to model in PRMs, in particular those that involve
several links at a time. We give some examples here.

One useful type of pattern type is a similarity template, where objects that share a cer-
tain graph-based property are more likely to have the same label. Consider, for example,
a professor X and two other entities Y and Z. If X’s webpage mentions Y and Z in the
same context, it is likely that the X-Y relation and the Y-Z relation are of the same type; for
example, if Y is Professor X’s advisee, then probably so is Z. Our framework accommo-
dates these patterns easily, by introducing pairwise cliques between the appropriate relation
variables.

Another useful type of subgraph template involves transitivity patterns, where the pres-
ence of an A-B link and of a B-C link increases (or decreases) the likelihood of an A-C link.
For example, students often assist in courses taught by their advisor. Note that this type
of interaction cannot be accounted for just using pairwise cliques. By introducing cliques
over triples of relations, we can capture such patterns as well. We can incorporate even
more complicated patterns, but of course we are limited by the ability of belief propagation

124

CHAPTER8. RELATIONALMARKOVNETWORKS

to scale up as we introduce larger cliques and tighter loops in the Markov network.

We describe and exploit these patterns in our work on RMNs using maximum likelihood
estimation [Taskar et al., 2003b]. Attempts to model such pattern in PRMs run into the
constraint that the probabilistic dependency graph (Bayesian network) must be a directed
acyclic graph. For example, for the transitivity pattern, we might consider simply directing
the correlation edges between link existence variables arbitrarily. However, it is not clear
how to parameterize a link existence variable for a link that is involved in multiple triangles.
The structure of the relational graph has been used extensively to infer importance in
scientiﬁc publications [Egghe & Rousseau, 1990] and hypertext [Kleinberg, 1999]. Sev-
eral recent papers have proposed algorithms that use the link graph to aid classiﬁcation.
Chakrabarti et al. [1998] use system-predicted labels of linked documents to iteratively
re-label each document in the test set, achieving a signiﬁcant improvement compared to a
baseline of using the text in each document alone. A similar approach was used by Neville
and Jensen [2000] in a different domain. Slattery and Mitchell [2000] tried to identify di-
rectory (or hub) pages that commonly list pages of the same topic, and used these pages to
improve classiﬁcation of university webpages. However, none of these approaches provide
a coherent model for the correlations between linked webpages, applying combinations of
classiﬁers in a procedural way, with no formal justiﬁcation.

8.6 Conclusion

In this chapter, we propose a new approach for classiﬁcation in relational domains. Our ap-
proach provides a coherent foundation for the process of collective classiﬁcation, where we
want to classify multiple entities, exploiting the interactions between their labels. We have
shown that we can exploit a very rich set of relational patterns in classiﬁcation, signiﬁcantly
improving the classiﬁcation accuracy over standard ﬂat classiﬁcation.

In some cases, we can incorporate relational features into standard ﬂat classiﬁcation.
For example, when classifying papers into topics, it is possible to simply view the presence
of particular citations as atomic features. However, this approach is limited in cases where
some or even all of the relational features that occur in the test data are not observed in
the training data. In our WebKB example, there is no overlap between the webpages in the

8.6. CONCLUSION

125

different schools, so we cannot learn anything from the training data about the signiﬁcance
of a hyperlink to/from a particular webpage in the test data. Incorporating basic features
(e.g., words) from the related entities can aid in classiﬁcation, but cannot exploit the strong
correlation between the labels of related entities that RMNs capture.

Hypertext is the most easily available source of structured data, however, RMNs are
generally applicable to any relational domain. The results in this chapter represent only
a subset of the domains we have worked on (see [Taskar et al., 2003b]). In particular,
social networks provide extensive information about interactions among people and orga-
nizations. RMNs offer a principled method for learning to predict communities of and
hierarchical structure between people and organizations based on both the local attributes
and the patterns of static and dynamic interaction. Given the wealth of possible patterns, it
is particularly interesting to explore the problem of inducing them automatically.

126

CHAPTER8. RELATIONALMARKOVNETWORKS

Part III

Broader applications: parsing,

matching, clustering

127

Chapter 9

Context free grammars

We present a novel discriminative approach to parsing using structured max-margin crite-
rion based on the decomposition properties of context free grammars. We show that this
framework allows high-accuracy parsing in cubic time by exploiting novel kinds of lexical
information. Our models can condition on arbitrary features of input sentences, thus incor-
porating an important kind of lexical information not usually used by conventional parsers.
We show experimental evidence of the model’s improved performance over a natural base-
line model and a lexicalized probabilistic context-free grammar.

9.1 Context free grammar model

CFGs are one of the primary formalisms for capturing the recursive structure of syntactic
constructions, although many others have also been proposed [Manning & Sch¨utze, 1999].
For clarity of presentation, we restrict our grammars to be in Chomsky normal form as
in Sec. 3.4. The non-terminal symbols correspond to syntactic categories such as noun
phrase (NP) or verbal phrase (VP). The terminal symbols are usually words of the sen-
tence. However, in the discriminative framework that we adopt, we are not concerned with
deﬁning a distribution over sequences of words (language model). Instead, we condition
on the words in a sentence to produce a model of the syntactic structure. Terminal sym-
bols for our purposes are part-of-speech tags like nouns (NN), verbs (VBD), determiners
(DT). For example, Fig. 9.1(a) shows a parse tree for the sentence The screen was a sea of

128

9.1. CONTEXTFREEGRAMMARMODEL

129

red. The set of symbols we use is based on the Penn Treebank [Marcus et al., 1993]. The
non-terminal symbols with bars (for example, DT, NN, VBD) are added to conform to the
CNF restrictions. For convenience, we repeat our deﬁnition of a CFG from Sec. 3.4 here:
Deﬁnition 9.1.1 (CFG) A CFG G consists of:

◦ A set of non-terminal symbols, N
◦ A designated set of start symbols, NS ⊆ N
◦ A set of terminal symbols, T
◦ A set of productions, P = {PB,PU}, divided into

(cid:46) Binary productions, PB = {A → B C : A, B, C ∈ N} and
(cid:46) Unary productions, PU = {A → D : A ∈ N , D ∈ T }.

A CFG deﬁnes a set of valid parse trees in a natural manner:

Deﬁnition 9.1.2 (CFG tree) A CFG tree is a labeled directed tree, where the set of valid
labels of the internal nodes other than the root is N and the set of valid labels for the leaves
is T . The root’s label set is NS. Additionally, each pre-leaf node has a single child and
this pair of nodes can be labeled as A and D, respectively, if and only if there is a unary
production A → D ∈ PU . All other internal nodes have two children, left and right, and
this triple of nodes can be labeled as A, B and C, respectively, if and only if there is a
binary production A → B C ∈ PB.

In general, there are exponentially many parse trees that produce a sentence of length n.

This tree representation seems quite different from the graphical models we have been
considering thus far. However, we can use an equivalent representation that essentially
encodes a tree as an assignment to a set of appropriate variables. For each span starting
with s and an ending with e, we introduce a variable Ys,e taking values in N ∪⊥ to represent
the label of the subtree that exactly covers, or dominates, the words of the sentence from
s to e. The value ⊥ is assigned if no subtree dominates the span. Indices s and e refer to
positions between words, rather than to words themselves, hence 0 ≤ s < e ≤ n for a
sentence of length n. The “top” symbol Y0,n is constrained to be in NS, since it represents

130

CHAPTER9. CONTEXTFREEGRAMMARS

(a)

(b)

Figure 9.1: Two representations of a binary parse tree: (a) nested tree structure, and (b)
grid of labeled spans. The row and column number are the beginning and end of the span,
respectively. Empty squares correspond to non-constituent spans. The gray squares on the
diagonal represent part-of-speech tags.

the starting symbol of the sentence. We also introduce variables Ys,s taking values in T to
represent the terminal symbol (part-of-speech) between s and s + 1. If Ys,e (cid:54)= ⊥, it is often
called a constituent. Fig. 9.1(b) shows the representation of the tree in Fig. 9.1(a) as a grid
where each square corresponds to Ys,e. The row and column number in the grid correspond
to the beginning and end of the span, respectively. Empty squares correspond to ⊥ values.
The gray squares on the diagonal represent the terminal variables. For example, the ﬁgure
shows Y0,0 = DT, Y6,6 = NN, Y3,5 = NP and Y1,4 = ⊥.

While any parse tree corresponds to an assignment to this set of variables in a straight-
forward manner, the converse is not true: there are assignments that do not correspond
to valid parse trees. In order to characterize the set of valid assignments Y, consider the

9.1. CONTEXTFREEGRAMMARMODEL

131

constraints that hold for a valid assignment y:

1I(ys,e = A) =

1I(ys,m,e = (A, B, C)),

1I(ys,e = A) =

1I(ys(cid:48),s,e = (B, A, C))

A→B C∈PB

s<m<e

(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)

B→A C∈PB
0≤s(cid:48)<s

+
B→C A∈PB
e<e(cid:48)≤n

A→D∈PU

A→D∈PU

1I(ys,e,e(cid:48) = (B, C, A)),

1I(ys,s+1 = A) =

1I(ys,s,s+1 = (A, D)),

1I(ys,s = D) =

1I(ys,s,s+1 = (A, D)),

0 ≤ s < e ≤ n, ∀A ∈ N ;

(9.1)

0 ≤ s < e ≤ n, ∀A ∈ N ;

0 ≤ s < n, ∀A ∈ N ;

0 ≤ s < n, ∀D ∈ T .

(9.2)

(9.3)

(9.4)

The notation ys,m,e = (A, B, C) abbreviates ys,e = A ∧ ys,m = B ∧ ym,e = C and
ys,s,s+1 = (A, D) abbreviates ys,s+1 = A ∧ ys,s = D. The ﬁrst set of constraints (9.1)
holds because if the span from s to e is dominated by a subtree starting with A (that is,
ys,e = A), then there must be a unique production starting with A and some split point m,
s < m < e, that produces that subtree. Conversely, if ys,e (cid:54)= A, no productions start with
A and cover s to e. The second set of constraints (9.2) holds because that if the span from
s to e is dominated by a subtree starting with A (ys,e = A), then there must be a (unique)
production that generated it: either starting before s or after e. Similarly, the third and
fourth set of constraints (9.3 and 9.4) hold since the terminals are generated using valid
unary productions. We denote the set of assignments y satisfying (9.1-9.4) as Y. In fact
the converse is true as well:
Theorem 9.1.3 If y ∈ Y, then y represents a valid CFG tree.
Proof sketch: It is straightforward to construct a parse tree from y ∈ Y in a top-down
manner. Starting from the root symbol, y0,n, the ﬁrst set of constraints (9.1) ensures that a
unique production spans 0 to n, say splitting at m and specifying the values for y0,m and
ym,n. The second set of constraints (9.2) ensures that all other spans y0,m(cid:48) and ym(cid:48),n, for
m(cid:48) (cid:54)= m are labeled by ⊥. Recursing on the two subtrees, y0,m and ym,n, will produce the
rest of the tree down to the pre-terminals. The last two sets of constraints (9.3 and 9.4)

132

CHAPTER9. CONTEXTFREEGRAMMARS

ensure that the terminals are generated by an appropriate unary productions from the pre-
terminals.

9.2 Context free parsing

A standard approach to parsing is to use a CFG to deﬁne a probability distribution over
parse trees. This can be done simply by assigning a probability to each production and
making sure that the sum of probabilities of all productions starting with each symbol is 1:

(cid:88)

(cid:88)

P (A → B C) = 1,

P (A → D) = 1,

∀A ∈ N .

B,C:A→B C∈PB

D:A→D∈PU

The probability of a tree is simply the product of probabilities of the productions used in
the tree. More generally, a weighted CFG assigns a score to each production (this score
may depend on the position of the production s, m, e) such that the total score of a tree is
the sum of the score of all the productions used:

(cid:88)

0≤s<m<e≤n

(cid:88)

0≤s<n

S(y) =

Ss,m,e(ys,m,e) +

Ss,s+1(ys,s+1),

where Ss,m,e(ys,m,e) = 0 if (ys,e = ⊥ ∨ ys,m = ⊥ ∨ ym,e = ⊥). If the production scores
are production log probabilities, then the tree score is the tree log probability. However,
weighted CFGs do not have the local normalization constraints Eq. (9.5).

We can use a Viterbi-style dynamic programming algorithm called CKY to compute
the highest score parse tree in O(|P|n3) time [Younger, 1967; Manning & Sch¨utze, 1999].
The algorithm computes the highest score of any subtree starting with a symbol over each
span 0 ≤ s < e ≤ n recursively:

S∗
s,s+1(A) = max
S∗
s,e(A) = max
s<m<e

A→B C∈PB

A→D∈PU

Ss,s+1(A, D),
Ss,m,e(A, B, C) + S∗

0 ≤ s < n, ∀A ∈ N ;

s,m(B) + S∗

m,e(C),

(9.5)
0 ≤ s < e ≤ n, ∀A ∈ N .

The highest scoring tree has score maxA∈NS S∗

0,n(A). Using the arg max’s of the max’s in

9.3. DISCRIMINATIVEPARSINGMODELS

133

the computation of S∗, we can back-trace the highest scoring tree itself. We assume that
score ties are broken in a predetermined way, say according to some lexicographic order of
the symbols.

9.3 Discriminative parsing models

We cast parsing as a structured classiﬁcation task, where we want to learn a function h :
X (cid:55)→ Y, where X is a set of sentences, and Y is a set of valid parse trees according to a
ﬁxed CFG grammar.

The functions we consider take the following linear discriminant form:

hw(x) = arg max

y

w(cid:62)f (x, y),

where w ∈ IRd and f is a basis function representation of a sentence and parse tree pair
f : X × Y → IRd. We assume that the basis functions decompose with the CFG structure:

(cid:88)

(cid:88)

f (x, y) =

f (xs,e, ys,e) +

f (xs,m,e, ys,m,e),

0≤s≤e≤n

0≤s≤m<e≤n

where n is the length of the sentence x and xs,e and xs,m,e are the relevant subsets of
the sentence the basis functions depend on. To simplify notation, we introduce the set of
indices, C, which includes both spans and span triplets:

C = {(s, m) : 0 ≤ s ≤ e ≤ n} ∪ {(s, m, e) : 0 ≤ s ≤ m < e ≤ n}.

(cid:80)

Hence, f (x, y) =

c∈C f (xc, yc).

Note that this class of discriminants includes PCFG models, where the basis func-
tions consist of the counts of the productions used in the parse, and the parameters w are
the log-probabilities of those productions. For example, f could include functions which
identify the production used together with features of the words at positions s, m, e, and
neighboring positions in the sentence x (e.g. f (xs,m,e, ys,m,e) = 1I(ys,m,e = S, NP, VP) ∧
mthword(x) = was)). We could also include functions that identify the label of the span

134

CHAPTER9. CONTEXTFREEGRAMMARS

from s to e together with features of the word (e.g. f (xs,m, ys,m) = 1I(ys,m = NP) ∧
sthword(x) = the)).

9.3.1 Maximum likelihood estimation

The traditional method of estimating the parameters of PCFGs assumes a generative model
that deﬁnes P (x, y) by assigning normalized probabilities to CFG productions. We then
maximize the joint log-likelihood
i log P (x(i), y(i)) (with some regularization). We com-
pare to such a generative grammar of Collins [1999] in our experiments.

(cid:80)

A alternative probabilistic approach is to estimate the parameters discriminatively by
maximizing conditional log-likelihood. For example, the maximum entropy approach [John-
son, 2001] deﬁnes a conditional log-linear model:

Pw(y | x) =

1

exp{w(cid:62)f (x, y)},

Zw(x)

(cid:80)

(cid:80)
y exp{w(cid:62)f (x, y)}, and maximizes the conditional log-likelihood of
where Zw(x) =
i log P (y(i) | y(i)), (with some regularization). The same assumption that
the sample,
the basis functions decompose as sums of local functions over spans and productions is
typically made in such models. Hence, as in Markov networks, the gradient depends
on the expectations of the basis functions, which can be computed in O(|P|n3) time by
dynamic programming algorithm called inside-outside, which is similar to the CKY al-
gorithm. However, computing the expectations over trees is actually more expensive in
practice than ﬁnding the best tree for several reasons. CKY works entirely in the log-space,
while inside-outside needs to compute actual probabilities. Branch-and-prune techniques,
which save a lot of useless computation, are only applicable in CKY.

A typical method for ﬁnding the parameters is to use Conjugate Gradients or L-BFGS
methods [Nocedal & Wright, 1999; Boyd & Vandenberghe, 2004], which repeatedly com-
pute these expectations to calculate the gradient. Clark and Curran [2004] report experi-
ments involving 479 iterations of training for one model, and 1550 iterations for another
using similar methods.

9.3. DISCRIMINATIVEPARSINGMODELS

135

9.3.2 Maximum margin estimation

We assume that loss function also decomposes with the CFG structure:

(cid:88)

(cid:88)

(cid:96)(x, y, ˆy) =

(cid:96)(xs,e, ys,e, ˆys,e) +

(cid:96)(xs,m,e, ys,m,e, ˆys,m,e) =

0≤s≤e≤n

0≤s≤m<e≤n

(cid:88)

c∈C

(cid:96)(xc, yc, ˆyc).

One approach would be to deﬁne (cid:96)(xs,e, ys,e, ˆys,e) = 1I(ys,e (cid:54)= ˆys,e). This would lead to
(cid:96)(x, y, ˆy) tracking the number of “constituent errors” in ˆy. Another, more strict deﬁnition
would be to deﬁne (cid:96)(xs,m,e, ys,m,e, ˆys,m,e) = 1I(ys,m,e (cid:54)= ˆys,m,e). This deﬁnition would lead
to (cid:96)(x, y, ˆy) being the number of productions in ˆy which are not seen in y. The constituent
loss function does not exactly correspond to the standard scoring metrics, such as F1 or
crossing brackets, but shares the sensitivity to the number of differences between trees. We
have not thoroughly investigated the exact interplay between the various loss choices and
the various parsing metrics. We used the constituent loss in our experiments.

As in the max-margin estimation for Markov networks, we can formulate an exponen-

tial size QP:

min

s.t.

(cid:88)

||w||2 + C
1
2
w(cid:62)∆fi(y) ≥ (cid:96)i(y) − ξi ∀i, y,

ξi

i

where ∆fi(y) = f (x(i), y(i)) − f (x(i), y), and (cid:96)i(y) = (cid:96)(x(i), y(i), y).

The dual of Eq. (9.6) (after normalizing by C) is given by:

(9.6)

(9.7)

(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)

(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)(cid:88)

(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)
(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)2

max

s.t.

C

αi(y)(cid:96)i(y) − 1
2
∀i; αi(y) ≥ 0, ∀i, y.

αi(y)∆fi(y)

αi(y) = 1,

i,y

(cid:88)
(cid:88)

i,y

y

Both of the above formulations are exponential (in the number of variables or con-
straints) in the lengths (ni’s) of the sentences. But we can exploit the context-free structure
of the basis functions and the loss to deﬁne a polynomial-size dual formulation in terms of

136

CHAPTER9. CONTEXTFREEGRAMMARS

marginal variables µi(y):

(cid:88)
(cid:88)

y:ys,e=A

µi,s,e(A) ≡

µi,s,s(D) ≡

αi(y),

0 ≤ s ≤ e ≤ n, ∀A ∈ N ;

αi(y),

0 ≤ s ≤ e ≤ n, ∀D ∈ T ;

y:ys,s=D

µi,s,m,e(A, B, C) ≡

µi,s,s,s+1(A, D) ≡

(cid:88)
(cid:88)

y:ys,m,e=(A,B,C)

y:ys,s,s+1=(A,D)

αi(y),

0 ≤ s < m < e ≤ n, ∀A → B C ∈ PB,

αi(y),

0 ≤ s < n, ∀A → D ∈ PU .

i + |PU|ni) such variables for each sentence of length ni, instead of
There are O(|PB|n3
exponentially many αi variables. We can now express the objective function in terms of
the marginals. Using these variables, the ﬁrst set of terms in the objective becomes:

(cid:88)

(cid:88)

(cid:88)

(cid:88)

(cid:88)

c∈C(i)

(cid:88)

c∈C(i)

(cid:88)

(cid:88)

i,c∈C(i),yc

i,c∈C(i),yc

αi(y)(cid:96)i(y) =

αi(y)

(cid:96)i,c(yc) =

µi,c(yc)(cid:96)i,c(yc).

i,y

i,y

Similarly, the second set of terms (inside the 2-norm) becomes:

αi(y)∆fi(y) =

αi(y)

∆fi,c(yc) =

µi,c(yc)∆fi,c(yc).

i,y

i,y

As in M3Ns, we must characterize the set of marginals µ that corresponds to valid
α. The constraints on µ are essentially based on the those that deﬁne Y in (9.1-9.4). In
addition, we require that the marginals over the root nodes, µi,0,ni(y0,ni), sums to 1 over the
possible start symbols NS.

137

(9.8)

9.3. DISCRIMINATIVEPARSINGMODELS

Putting the pieces together, the factored dual is:

(cid:88)

(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)

(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)

(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)
(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)2

max

s.t.

µi,c(yc)(cid:96)i,c(yc) + C

µi,c(yc)∆fi,c(yc)

µi,0,ni(A) = 1, ∀i;

i,c∈C(i)
µi,c(yc) ≥ 0; ∀i, ∀c ∈ C(i);

µi,s,m,e(A, B, C),

∀i, 0 ≤ s < e ≤ ni, ∀A ∈ N ;

(cid:88)
(cid:88)

i,c∈C(i)

A∈NS
µi,s,e(A) =

A→B C∈PB

s<m<e

(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)

B→A C∈PB
0≤s(cid:48)<s

+
B→C A∈PB
e<e(cid:48)≤ni

A→D∈PU

A→D∈PU

µi,s,e(A) =

µi,s(cid:48),s,e(B, A, C)

µi,s,e,e(cid:48)(B, C, A), ∀i, 0 ≤ s < e ≤ ni,∀A ∈ N ;

µi,s,s+1(A) =

µi,s,s,s+1(A, D),

µi,s,s(D) =

µi,s,s,s+1(A, D),

∀i, 0 ≤ s < ni, ∀A ∈ N ;

∀i, 0 ≤ s < ni, ∀D ∈ T .

The constraints on µ is necessary, since they must correspond to marginals of a distri-

bution over trees. They are also sufﬁcient:

Theorem 9.3.1 A set of marginals µi(y) satisfying the constraints in Eq. (9.8) corresponds
to a valid distribution over the legal parse trees y ∈ Y (i). A consistent distribution αi(y)
is given by

(cid:89)

αi(y) = µi,0,ni(y0,ni)

where 0/0 = 0 by convention.

µi,s,m,e(ys,m,e)

µi,s,e(ys,e)

,

0≤s≤m<e≤ni

Proof sketch: The proof follows from inside-outside probability relations [Manning &
Sch¨utze, 1999]. The ﬁrst term is a valid distribution of starting symbols. Each µi,s,m,e(ys,m,e)
term for m > s corresponds to a conditional distribution over binary productions (ys,e →
ys,m ym,e) that are guaranteed to sum to 1 over split points m and possible productions.
Similarly, each µi,s,s,s+1(ys,s,s+1)
term for corresponds to a conditional distribution over
µi,s,s+1(ys,s+1)

µi,s,e(ys,e)

138

CHAPTER9. CONTEXTFREEGRAMMARS

unary productions (ys,s+1 → ys,s) that are guaranteed to sum to 1 over possible produc-
tions. Hence, we have deﬁned a kind of PCFG (where production probabilities depend on
the location of the symbol), which induces a valid distribution αi over trees. It straightfor-
ward to verify that this distribution has marginals µi.

9.4 Structured SMO for CFGs

We trained our max-margin models using the Structured SMO algorithm with block-coordinate
descent adopted from graphical models (see Sec. 6.1). The CKY algorithm computes sim-
ilar max-marginals in the course of computing the best tree as does Viterbi in Markov
networks.

(cid:98)vi,c(yc) = max
We also deﬁne(cid:98)vi,c(yc) = maxy(cid:48)

y∼yc

[w(cid:62)fi(y) + (cid:96)i(y)],

c(cid:54)=yc(cid:98)vi,c(y(cid:48)

(cid:98)αi,c(yc) = max

y∼yc

αi(y).

c) = maxy(cid:54)∼yc [w(cid:62)fi(y) + (cid:96)i(y)]. Note that we
do not explicitly represent αi(y), but we can reconstruct the maximum-entropy one from
the marginals µi as in Theorem 9.3.1.

We again express the KKT conditions in terms of the max-marginals for each span and

span triple c ∈ C(i) and its values yc:

(cid:98)αi,c(yc) = 0 ⇒(cid:98)vi,c(yc) ≤(cid:98)vi,c(yc);

(cid:98)αi,c(yc) > 0 ⇒(cid:98)vi,c(yc) ≥(cid:98)vi,c(yc).

(9.9)

The algorithm cycles through the training sentences, runs CKY to compute the max-
marginals and performs an SMO update on the violated constraints. We typically ﬁnd that
20-40 iterations through the data are sufﬁcient for convergence in terms of the objective
function improvements.

9.5 Experiments

We used the Penn English Treebank for all of our experiments. We report results here for
each model and setting trained and tested on only the sentences of length ≤ 15 words. Aside

9.5. EXPERIMENTS

139

from the length restriction, we used the standard splits: sections 2-21 for training (9753
sentences), 22 for development (603 sentences), and 23 for ﬁnal testing (421 sentences).

As a baseline, we trained a CNF transformation of the unlexicalized model of Klein and
Manning [2003] on this data. The resulting grammar had 3975 non-terminal symbols and
contained two kinds of productions: binary non-terminal rewrites and tag-word rewrites.
Unary rewrites were compiled into a single compound symbol, so for example a subject-
gapped sentence would have label like S+VP. These symbols were expanded back into
their source unary chain before parses were evaluated. The scores for the binary rewrites
were estimated using unsmoothed relative frequency estimators. The tagging rewrites were
estimated with a smoothed model of P (w|t), also using the model from Klein and Manning
[2003]. In particular, Table 9.2 shows the performance of this model (GENERATIVE): 87.99
F1 on the test set.

For the BASIC max-margin model, we used exactly the same set of allowed rewrites
(and therefore the same set of candidate parses) as in the generative case, but estimated
their weights using the max-margin formulation with a loss that counts the number of
wrong spans. Tag-word production weights were ﬁxed to be the log of the generative
P (w|t) model. That is, the only change between GENERATIVE and BASIC is the use of the
discriminative maximum-margin criterion in place of the generative maximum likelihood
one for learning production weights. This change alone results in a small improvement
(88.20 vs. 87.99 F1).

On top of the basic model, we ﬁrst added lexical features of each span; this gave a

LEXICAL model. For a span (cid:104)s, e(cid:105) of a sentence x, the base lexical features were:

◦ xs, the ﬁrst word in the span
◦ xs−1, the preceding adjacent word
◦ xe−1, the last word in the span
◦ xe, the following adjacent word
◦ (cid:104)xs−1, xs(cid:105)
◦ (cid:104)xe−1, xe(cid:105)
◦ xs+1 for spans of length 3

140

CHAPTER9. CONTEXTFREEGRAMMARS

P

R

Model
87.70 88.06
GENERATIVE
87.51 88.44
BASIC
LEXICAL
88.15 88.62
LEXICAL+AUX 89.74 90.22

F1

87.88
87.98
88.39
89.98

Table 9.1: Development set results of the various models when trained and tested on Penn
treebank sentences of length ≤ 15.

R

F1

P

Model
GENERATIVE
BASIC
LEXICAL
LEXICAL+AUX 89.14
89.18
COLLINS 99

88.25 87.73
88.08 88.31
88.55 88.34

87.99
88.20
88.44
89.10 89.12
88.20 88.69

Table 9.2: Test set results of the various models when trained and tested on Penn treebank
sentences of length ≤ 15.

These base features were conjoined with the span length for spans of length 3 and below,
since short spans have highly distinct behaviors (see the examples below). The features are
lexical in the sense than they allow speciﬁc words and word pairs to inﬂuence the parse
scores, but are distinct from traditional lexical features in several ways. First, there is no
notion of headword here, nor is there any modeling of word-to-word attachment. Rather,
these features pick up on lexical trends in constituent boundaries, for example the trend
that in the sentence The screen was a sea of red., the (length 2) span between the word was
and the word of is unlikely to be a constituent. These non-head lexical features capture a
potentially very different source of constraint on tree structures than head-argument pairs,
one having to do more with linear syntactic preferences than lexical selection. Regardless
of the relative merit of the two kinds of information, one clear advantage of the present
approach is that inference in the resulting model remains cubic (as opposed to O(n5)),
since the dynamic program need not track items with distinguished headwords. With the
addition of these features, the accuracy moved past the generative baseline, to 88.44.

9.5. EXPERIMENTS

141

As a concrete (and particularly clean) example of how these features can sway a de-
cision, consider the sentence The Egyptian president said he would visit Libya today to
resume the talks. The generative model incorrectly considers Libya today to be a base NP.
However, this analysis is counter to the trend of today to be a one-word constituent. Two
features relevant to this trend are: (CONSTITUENT ∧ ﬁrst-word = today ∧ length = 1) and
(CONSTITUENT ∧ last-word = today ∧ length = 1). These features represent the preference
of the word today for being the ﬁrst and last word in constituent spans of length 1.1 In the
LEXICAL model, these features have quite large positive weights: 0.62 each. As a result,
this model makes this parse decision correctly.

Another kind of feature that can usefully be incorporated into the classiﬁcation process
is the output of other, auxiliary classiﬁers. For this kind of feature, one must take care
that its reliability on the training not be vastly greater than its reliability on the test set.
Otherwise, its weight will be artiﬁcially (and detrimentally) high. To ensure that such
features are as noisy on the training data as the test data, we split the training into two
folds. We then trained the auxiliary classiﬁers on each fold, and using their predictions as
features on the other fold. The auxiliary classiﬁers were then retrained on the entire training
set, and their predictions used as features on the development and test sets.

We used two such auxiliary classiﬁers, giving a prediction feature for each span (these
classiﬁers predicted only the presence or absence of a bracket over that span, not bracket
labels). The ﬁrst feature was the prediction of the generative baseline; this feature added
little information, but made the learning phase faster. The second feature was the output
of a ﬂat classiﬁer which was trained to predict whether single spans, in isolation, were
constituents or not, based on a bundle of features including the list above, but also the
following:
the preceding, ﬁrst, last, and following tag in the span, pairs of tags such as
preceding-ﬁrst, last-following, preceding-following, ﬁrst-last, and the entire tag sequence.

Tag features on the test sets were taken from a pretagging of the sentence by the tagger
described in [Toutanova et al., 2003].While the ﬂat classiﬁer alone was quite poor (P 78.77
/ R 63.94 / F1 70.58), the resulting max-margin model (LEXICAL+AUX) scored 89.12 F1.
To situate these numbers with respect to other models, the parser in [Collins, 1999],which

1In this length 1 case, these are the same feature. Note also that the features are conjoined with only one

generic label class “constituent” rather than speciﬁc constituent types.

142

CHAPTER9. CONTEXTFREEGRAMMARS

is generative, lexicalized, and intricately smoothed scores 88.69 over the same train/test
conﬁguration.

9.6 Related work

A number of recent papers have considered discriminative approaches for natural language
parsing [Johnson et al., 1999; Collins, 2000; Johnson, 2001; Geman & Johnson, 2002;
Miyao & Tsujii, 2002; Clark & Curran, 2004; Kaplan et al., 2004; Collins, 2004]. Broadly
speaking, these approaches fall into two categories, reranking and dynamic programming
approaches. In reranking methods [Johnson et al., 1999; Collins, 2000; Shen et al., 2003],
an initial parser is used to generate a number of candidate parses. A discriminative model
is then used to choose between these candidates. In dynamic programming methods, a
large number of candidate parse trees are represented compactly in a parse tree forest or
chart. Given sufﬁciently “local” features, the decoding and parameter estimation problems
can be solved using dynamic programming algorithms. For example, several approaches
[Johnson, 2001; Geman & Johnson, 2002; Miyao & Tsujii, 2002; Clark & Curran, 2004;
Kaplan et al., 2004] are based on conditional log-linear (maximum entropy) models, where
variants of the inside-outside algorithm can be used to efﬁciently calculate gradients of the
log-likelihood function, despite the exponential number of trees represented by the parse
forest.

The method we presented has several compelling advantages. Unlike reranking meth-
ods, which consider only a pre-pruned selection of “good” parses, our method is an end-
to-end discriminative model over the full space of parses. This distinction can be very
signiﬁcant, as the set of n-best parses often does not contain the true parse. For example,
in the work of Collins [2000], 41% of the correct parses were not in the candidate pool of
∼30-best parses. Unlike previous dynamic programming approaches, which were based on
maximum entropy estimation, our method incorporates an articulated loss function which
penalizes larger tree discrepancies more severely than smaller ones.

Moreover, the structured SMO we use requires only the calculation of Viterbi trees,
rather than expectations over all trees (for example using the inside-outside algorithm).

9.7. CONCLUSION

143

This allows a range of optimizations that prune the space of parses (without making ap-
proximations) not possible for maximum likelihood approaches which must extract basis
function expectations from the entire set of parses. In our experiments, 20-40 iterations
were generally required for convergence (except the BASIC model, which took about 100
iterations.)

9.7 Conclusion

We have presented a maximum-margin approach to parsing, which allows a discriminative
SVM-like objective to be applied to the parsing problem. Our framework permits the use
of a rich variety of input features, while still decomposing in a way that exploits the shared
substructure of parse trees in the standard way.

It is worth considering the cost of this kind of method. At training time, discriminative
methods are inherently expensive, since they all involve iteratively checking current model
performance on the training set, which means parsing the training set (usually many times).
Generative approaches are vastly cheaper to train, since they must only collect counts from
the training set.

On the other hand, the max-margin approach does have the potential to incorporate
many new kinds of features over the input, and the current feature set allows limited lexi-
calization in cubic time, unlike other lexicalized models (including the Collins model which
it outperforms in the present limited experiments). This trade-off between the complexity,
accuracy and efﬁciency of a parsing model is an important area of future research.

Chapter 10

Matchings

We address the problem of learning to match: given a set of input graphs and corresponding
matchings, ﬁnd a parameterized edge scoring function such that the correct matchings have
the highest score. Bipartite matchings are used in many ﬁelds, for example, to ﬁnd marker
correspondences in vision problems, to map words of a sentence in one language to another,
to identify functional genetic analogues in different organisms. We have shown a compact
max-margin formulation for bipartite matchings in Ch. 4. In this chapter, we focus on a
more complex problem of non-bipartite matchings. We motivate this problem using an
application in computational biology, disulﬁde connectivity prediction, but non-bipartite
matchings can be used for many other tasks.

Identifying disulﬁde bridges formed by cysteine residues is critical in determining the
structure of proteins. Recently proposed models have formulated this prediction task as a
maximum weight perfect matching problem in a graph containing cysteines as nodes with
edge weights measuring the attraction strength of the potential bridges. We exploit combi-
natorial properties of the perfect matching problem to deﬁne a compact, convex, quadratic
program. We use kernels to efﬁciently learn very rich (in-fact, inﬁnite-dimensional) mod-
els and present experiments on standard protein databases, showing that our framework
achieves state-of-the-art performance on the task.

Throughout this chapter, we use the problem of disulﬁde connectivity prediction as an

example. We provide some background on this problem.

144

10.1. DISULFIDECONNECTIVITYPREDICTION

145

10.1 Disulﬁde connectivity prediction

Proteins containing cysteine residues form intra-chain covalent bonds known as disulﬁde
bridges. Such bonds are a very important feature of protein structure since they enhance
conformational stability by reducing the number of conﬁgurational states and decreasing
the entropic cost of folding a protein into its native state [Matsumura et al., 1989]. They do
so mostly by imposing strict structural constraints due to the resulting links between distant
regions of the protein sequence [Harrison & Sternberg, 1994].

Knowledge of the exact disulﬁde bonding pattern in a protein provides information
about protein structure and possibly its function and evolution. Furthermore, since the
disulﬁde connectivity pattern imposes structure constraints, it can be used to reduce the
search space in both protein folding prediction as well as protein 3D structure prediction.
Thus, the development of efﬁcient, scalable and accurate methods for the prediction of
disulﬁde bonds has numerous practical applications.

Recently, there has been increased interest in applying computational techniques to
the task of predicting the intra-chain disulﬁde connectivity [Fariselli & Casadio, 2001;
Fariselli et al., 2002; Vullo & Frasconi, 2004; Klepeis & Floudas, 2003; Baldi et al., 2004].
Since a sequence may contain any number of cysteine residues, which may or may not
participate in disulﬁde bonds, the task of predicting the connectivity pattern is typically
decomposed into two subproblems: predicting the bonding state of each cysteine in the
sequence, and predicting the exact connectivity among bonded cysteines. Alternatively,
there are methods [Baldi et al., 2004] that predict the connectivity pattern without knowing
the bonding state of each cysteine1.

We predict the connectivity pattern by ﬁnding the maximum weighted matching in a
graph in which each vertex represents a cysteine residue, and each edge represents the
“attraction strength” between the cysteines it connects [Fariselli & Casadio, 2001]. We
parameterize the this attraction strength via a linear combination of features, which can
include the protein sequence around the two residues, evolutionary information in the form
of multiple alignment proﬁles, secondary structure or solvent accessibility information, etc.

1We thank Pierre Baldi and Jianlin Cheng for introducing us to the problem of disulﬁde connectivity
prediction and providing us with preliminary draft of their paper and results of their model, as well as the
protein datasets.

146

CHAPTER10. MATCHINGS

10.2 Learning to match

Formally, we seek a function h : X (cid:55)→ Y that maps inputs x ∈ X to output matchings
y ∈ Y, for example, X is the space of protein sequences and Y is the space of matchings
of their cysteines. The space of matchings Y is very large, in fact, superexponential in
the number of nodes in a graph. However, Y has interesting and complex combinatorial
structure which we exploit to learn h efﬁciently.

The training data consists of m examples S = {(x(i), y(i))}m

i=1 of input graphs and
output matchings. We assume that the input x deﬁnes the space of possible matchings
using some deterministic procedure. For example, given a protein sequence, we construct
a complete graph where each node corresponds to a cysteine. We represent each possible
edge between nodes j and k (j < k) in example i using a binary variable y(i)
jk . For simplicity,
we assume complete graphs, but very little needs to be changed to handle sparse graphs.
If example i has Li nodes, then there are Li(Li − 1)/2 edge variables, so y(i) is a
binary vector of dimension Li(Li − 1)/2. In a perfect matching, each node is connected
exactly one other node. In non-perfect matchings, each node is connected to at most one
other node. Let ni = Li/2, then for complete graphs with even number of vertices Li, the
number of possible perfect matchings is (2ni)!
2 )ni), super-exponential in
ni). For example, 1ANS protein in Fig. 10.1 has 6 cysteines (nodes), 15 potential bonds
(edges) and 15 possible perfect matchings.

2ni ni! (which is Ω(( ni

Our hypothesis class is maximum weight matchings:

(cid:88)

jk

hs(x) = arg max

y∈Y

sjk(x)yjk,

(10.1)

For disulﬁde connectivity prediction, this model was used by Fariselli and Casadio [2001].
Their model assigns an attraction strength sjk(x) to each pair of cysteines, calculated by
assuming that all residues in the local neighborhoods of the two cysteines make contact,
and summing contact potentials for pairs of residues. We consider a simple but very general
class of attraction scoring functions deﬁned by a weighted combination of features or basis
functions:

sjk(x) =

wdfd(xjk) = w(cid:62)f (xjk),

(10.2)

(cid:88)

d

10.2. LEARNINGTOMATCH

147

Figure 10.1: PDB protein 1ANS: amino acid sequence, 3D structure, and graph of potential
disulﬁde bonds. Actual disulﬁde connectivity is shown in yellow in the 3D model and the
graph of potential bonds.

where xjk is the portion of the input x that directly relates to nodes j and k, fd(xjk) is
a real-valued basis function and wd ∈ IR. For example, the basis functions can represent
arbitrary information about the two cysteine neighborhoods: the identity of the residues
at speciﬁc positions around the two cysteines, or the predicted secondary structure in the
neighborhood of each cysteine. We assume that the user provides the basis functions, and
that our goal is to learn the weights w, for the model:

(cid:88)

jk

w(cid:62)f (xjk)yjk.

(10.3)

hw(x) = arg max

Below, we will abbreviate w(cid:62)f (x, y) ≡(cid:80)

y∈Y

jk w(cid:62)f (xjk)yjk, and w(cid:62)fi(y) ≡ w(cid:62)f (x(i), y),
The naive formulation of the max-margin estimation, which enumerates all perfect

matchings for each example i, is:

min

1
2

||w||2

s.t. w(cid:62)fi(y(i)) ≥ w(cid:62)fi(y) + (cid:96)i(y), ∀i, ∀y ∈ Y (i).

(10.4)

The number of constraints in this formulation is super-exponential in the number of nodes
in each example.
In the following sections we present two max-margin formulations,
ﬁrst with an exponential set of constraints (Sec. 10.3), and then with a polynomial one
(Sec. 10.4).

123456123456RSCCPCYWGGCPWGQNCYPEGCSGPKV1     2         3                             4                 5                          6       148

CHAPTER10. MATCHINGS

10.3 Min-max formulation

Using the min-max formulation from Ch. 4, we have a single max constraint for each i:

min

||w||2

1
2

s.t. w(cid:62)fi(y(i)) ≥ max
y∈Y (i)

[w(cid:62)fi(y) + (cid:96)i(y)], ∀i.

(10.5)

The key to solving this problem efﬁciently is the loss-augmented inference
maxy∈Y (i)[w(cid:62)fi(y) + (cid:96)i(y)]. Under the assumption of Hamming distance loss (or any loss
function that can be written as a sum of terms corresponding to edges), this maximization
is equivalent (up to a constant term) to a maximum weighted matching problem. Note that
since the y variables are binary, the Hamming distance between y(i) and y can be written
as (1 − y)(cid:62)y(i) + (1 − y(i))(cid:62)y = 1(cid:62)y(i) + (1 − 2y(i))(cid:62)y. Hence, the maximum weight
matching where edge jk has weight w(cid:62)f (x(i)
jk ) (plus the constant 1(cid:62)y(i)) gives
the value of maxy∈Y (i)[w(cid:62)fi(y) + (cid:96)i(y)].

jk )+(1−2y(i)

This problem can be solved in O(L3) time [Gabow, 1973; Lawler, 1976]. It can also be
solved as a linear program, where we introduce continuous variables µi,jk instead of binary
variables y(i)
jk .

µi,jk ≤ 1
2

(|V | − 1), V ⊆ {1, . . . , Li}, |V | ≥ 3 and odd.

k µi,jk ≤ 1 require that the number of bonds incident on a node is less
The constraints
or equal to one. For perfect matchings, these constraints are changed to
k µi,jk = 1 to
ensure exactly one bond. The subset constraints (in the last line of Eq. (10.6)) ensure that
solutions to the LP are integral [Edmonds, 1965]. Note that we have an exponential number
of constraints (O(2(Li−1))), but this number is asymptotically smaller than the number of
possible matchings . It is an open problem to derive a polynomial sized LP formulation for
perfect matchings [Schrijver, 2003].

(cid:80)

max

s.t.

µi,jk[w(cid:62)f (x(i)

jk ) + (1 − 2y(i)
jk )]

µi,jk ≥ 0,

1 ≤ j < k ≤ Li;

(cid:88)

k

(10.6)

µi,jk ≤ 1,

1 ≤ j ≤ Li;

(cid:88)

jk

(cid:88)
(cid:80)

j,k∈V

10.3. MIN-MAXFORMULATION

149

We can write the loss-augmented inference problem in terms of the LP in Eq. (10.6):

max
y∈Y (i)

[w(cid:62)fi(y) + (cid:96)i(y)] = di + max
Aiµi≤bi
µi≥0

µ(cid:62)
i [Fiw + ci],

where: di = 1(cid:62)y(i); µi is a vector of length Li(Li − 1)/2 indexed by bond jk; Ai and bi
are the appropriate constraint coefﬁcient matrix and right hand side vector, respectively. Fi
is a matrix of basis function coefﬁcients such that the component jk of the vector Fiw is
jk ) and ci = (1 − 2y(i)). Note that the dependence on w is linear and occurs only
w(cid:62)f (x(i)
in the objective of the LP.

The dual of the LP in Eq. (10.6) is

min λ(cid:62)

i bi

s.t. A(cid:62)

i λi ≥ Fiw + ci; λi ≥ 0.

(10.7)

We plug it into Eq. (10.5) and combine the minimization over λ with minimization over w.

min

s.t.

||w||2
1
2
w(cid:62)fi(y(i)) ≥ di + λ(cid:62)
i λi ≥ Fiw + ci, ∀i;
A(cid:62)
λi ≥ 0, ∀i.

i bi, ∀i;

(10.8)

In case that our basis functions are not rich enough to predict the training data perfectly,
we can introduce a slack variable ξi for each example i to allow violations of the constraints
and minimize the sum of the violations:

(10.9)

(cid:88)

ξi

i

min

s.t.

||w||2 + C
1
2
w(cid:62)fi(y(i)) + ξi ≥ di + λ(cid:62)
i λi ≥ Fiw + ci, ∀i;
A(cid:62)
λi ≥ 0, ∀i;

ξi ≥ 0, ∀i.

i bi, ∀i;

The parameter C allows the user to trade off violations of the constraints with ﬁt to the

150

CHAPTER10. MATCHINGS

Figure 10.2: Log of the number of QP constraints (y-axis) vs. number of bonds (x-axis) in
the three formulations (perfect matching enumeration, min-max and certiﬁcate).

data.

Our formulation is a linearly-constrained quadratic program, albeit with an exponen-
tial number of constraints. In the next section, we develop an equivalent polynomial size
formulation.

10.4 Certiﬁcate formulation

Rather than solving the loss-augmented inference problem explicitly, we can focus on ﬁnd-
ing a compact certiﬁcate of optimality that guarantees that y(i) = arg maxy[w(cid:62)fi(y) +
(cid:96)i(y)]. We consider perfect matchings and then provide a reduction for the non-perfect
case. Let M be a perfect matching for a complete undirected graph G = (V, E). In an
alternating cycle/path in G with respect to M, the edges alternate between those that be-
long to M and those that do not. An alternating cycle is augmenting with respect to M if
the score of the edges in the matching M is smaller that the score of the edges not in the
matching M.

Theorem 10.4.1 [Edmonds, 1965] A perfect matching M is a maximum weight perfect
matching if and only if there are no augmenting alternating cycles.

051015202530234567891011121314151617181920Number of BondsLog-Number of ConstraintsPerfect MatchingsMin-max Certificate 10.4. CERTIFICATEFORMULATION

151

The number of alternating cycles is exponential in the number of vertices, so simply enu-
merating all of them will not do.
Instead, we can rule out such cycles by considering
shortest paths.

We begin by negating the score of those edges not in M. In the discussion below we
assume that each edge score sjk has been modiﬁed this way. We also refer to the score sjk
as the length of the edge jk. An alternating cycle is augmenting if and only if its length is
negative. A condition ruling out negative length alternating cycles can be stated succinctly
j, with j ∈ V ,
using a kind of distance function. Pick an arbitrary root node r. Let de
e ∈ {0, 1}, denote the length of the shortest distance alternating path from r to j, where
e = 1 if the last edge of the path is in M, 0 otherwise. These shortest distances are well-
deﬁned if and only if there are no negative alternating cycles. The following constraints
capture this distance function.

k − d1
j ,
k − d0
j ,

sjk ≥ d0
sjk ≥ d1

j − d1
k,
j − d0
k,
Theorem 10.4.2 There exists a distance function {de
j} satisfying the constraints in
Eq. (10.10) if and only if no augmenting alternating cycles exist.

∀ jk /∈ M ;
∀ jk ∈ M.

sjk ≥ d0
sjk ≥ d1

(10.10)

Proof.

j and d1

r = d1

j ≥ d1

(If) Suppose there are no augmenting alternating cycles. Since any alternating paths
from r to j can be shortened (or left the same length) by removing the cycles they contain,
the two shortest paths to j (one ending with M-edge and one not) contain no cycles. Then
let d0
r = 0). Then for
any jk (or kj) in M, the shortest path to j ending with an edge not in M plus the edge jk
(or kj) is an alternating path to k ending with an edge in M. This path is longer or same
j ≥ d1
k),
length as the shortest path to k ending with an edge in M: sjk + d0
so the constraint is satisﬁed. Similarly for jk, kj /∈ M.

j be the length of those paths, for all j (for j = r, set d0

k (or skj + d0

(Only if) Suppose a distance function {de

j} satisﬁes the constraints in Eq. (10.10). Con-
sider an alternating cycle C. We renumber the nodes such that the cycle passes through
nodes 1, 2, . . . , l and the ﬁrst edge, (1, 2), is in M. The length of the path is s(C) =
j. For
s1,l +

j=1 sj,j+1. For each odd j, the edge (j, j + 1) is in M, so sj,j+1 ≥ d1

(cid:80)l−1

j+1 − d0

152

CHAPTER10. MATCHINGS

even j, the edge (j, j + 1) is not in M, so sj,j+1 ≥ d0
is not in M, so s1,l ≥ d0

j+1 − d1
l−1(cid:88)
l . Summing the edges, we have:

l−1(cid:88)

1 − d1

s(C) ≥ d0

1 − d1

l +

j+1 − d0
[d1

j ] +

j. Finally, the last edge, (1, l),

j+1 − d1
[d0

j ] = 0.

Hence all alternating cycles have nonnegative length.

j=1,odd

j=2,even

In our learning formulation we have the loss-augmented edge weights s(i)

jk −
1)(w(cid:62)f (xjk)+1−2y(i)
j, Hi and Gi be matrices
of coefﬁcients and qi be a vector such that Hiw + Gidi ≥ qi represents the constraints
in Eq. (10.10) for example i. Then the following joint convex program in w and d computes
the max-margin parameters:

jk ). Let di be a vector of distance variables de

jk = (2y(i)

min

s.t.

||w||2
1
2
Hiw + Gidi ≥ qi,

∀i.

(10.11)

Once again, in case that our basis functions are not rich enough to predict the training data
perfectly, we can introduce a slack variable vector ξi to allow violations of the constraints.

The case of non-perfect matchings can be handled by a reduction to perfect matchings
as follows [Schrijver, 2003]. We create a new graph by making a copy of the nodes and
the edges and adding edges between each node and the corresponding node in the copy.
We extend the matching by replicating its edges in the copy and for each unmatched node,
introduce an edge to its copy. We deﬁne f (xjk) ≡ 0 for edges between the original and
the copy. Perfect matchings in this graph projected onto the original graph correspond to
non-perfect matchings in the original graph.

The comparison between the log-number of constraints for our three equivalent QP
formulations (enumeration of all perfect matchings, min-max and certiﬁcate) is shown
in Fig. 10.2. The x-axis is the number of edges in the matching (number of nodes divided
by two).

10.5. KERNELS

10.5 Kernels

153

Instead of directly optimizing the primal problem in Eq. (10.8), we can work with its dual.
Each training example i has Li(Li − 1)/2 dual variables, and α(i)
jk is the dual variable
associated with the features corresponding to the edge jk. Let α(i) be the vector of dual
variables for example i. The dual quadratic optimization problem has the form:

(cid:180)

Cy(i)

jk − α(i)

jk

f (x(i)
jk )

(10.12)

(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)

(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)
(cid:88)

i

(cid:88)

(cid:104)(cid:179)

jk∈E(i)

(cid:88)

i

max

s.t.

i α(i) − 1
c(cid:62)
2

Aiα(i) ≤ Cbi, ∀i.
α(i) ≥ 0, ∀i.

(cid:105)(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)
(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)2

(cid:180)

The only occurrence of feature vectors is in the expansion of the squared-norm term in the

objective: (cid:88)

(cid:88)

(cid:88)

(cid:179)

i,j

kl∈E(i)

mn∈E(j)

(cid:180)

(cid:179)

Cy(i)

jk − α(i)

jk

(cid:62)
f (x(i)
kl )

f (x(j)

mn)

Cy(j)

jk − α(j)

jk

(10.13)

(cid:62)
Therefore, we can apply the kernel trick and let f (x(i)
mn). Thus, we
kl )
can efﬁciently map the original features f (xjk) to a high-dimensional space. The primal
and dual solutions are related by:

mn) = K(x(i)

kl , x(j)

f (x(j)

w =

(Cy(i)

jk − α(i)

jk )f (x(i)
jk )

(10.14)

i

jk

Eq. (10.14) can be used to compute the attraction strength sjk(x) in a kernelized manner at
prediction time. The polynomial-sized representation in Eq. (10.11) is similarly kerneliz-
able.

(cid:88)

(cid:88)

154

CHAPTER10. MATCHINGS

10.6 Experiments

We assess the performance of our method on two datasets containing sequences with ex-
perimentally veriﬁed bonding patterns: DIPRO2 and SP39. The DIPRO2 dataset2 was
compiled and made publicly available by Baldi et al. [2004]. It consists of all proteins
from PDB [Berman et al., 2000], as of May 2004, which contain intra-chain disulﬁde
bonds. After redundance reduction there are a total of 1018 sequences. In addition, the
sequences are annotated with secondary structure and solvent accessibility information de-
rived from the DSSP database [Kabsch & Sander, 1983]. The SP39 dataset is extracted
from the Swiss-Prot database of proteins [Bairoch & Apweiler, 2000], release 39. It con-
tains only sequences with experimentally veriﬁed disulﬁde bridges, and has a total of 726
proteins. The same dataset was used in earlier work [Baldi et al., 2004; Vullo & Frasconi,
2004; Fariselli & Casadio, 2001], and we have followed the same procedure for extracting
sequences from the database.

Even though our method is applicable to both sequences with a high number of bonds
or sequences in which the bonding state of cysteine residues is unknown, we report results
for the case where the bonding state is known, and the number of bonds is between 2 and
5 (since the case of 1 bond is trivial). The DIPRO2 contains 567 such sequences, and only
53 sequences with a higher number of bonds, so we are able to perform learning on over
90% of all proteins. There are 430 proteins with 2 and 3 bonds and 137 with 4 and 5 bonds.
SP39 contains 446 sequences containing between 2 and 5 bonds.

In order to avoid biases during testing, we adopt the same dataset splitting procedure
as the one used in previous work [Fariselli & Casadio, 2001; Vullo & Frasconi, 2004;
Baldi et al., 2004]. We split SP39 into 4 different subsets, with the constraint that pro-
teins no proteins with sequence similarity of more than 30% belong to different subsets.
Sequence similarity was derived using an all-against-all rigorous Smith-Waterman local
pairwise alignment [Smith & Waterman, 1981] (with the BLOSUM65 scoring matrix, gap
penalty 12 and gap extension 4). Pairs of chains whose alignment is less than 30 residues
were considered unrelated. The DIPRO2 dataset was split similarly into 5 folds, although
the procedure had less effect due to the redundance reduction applied by the authors of the

2http://contact.ics.uci.edu/bridge.html

10.6. EXPERIMENTS

155

dataset.

Models

γ

(cid:107)xjk−xlm(cid:107)2

The experimental results we report use the dual formulation of Sec. 10.5 and an RBF kernel
), with γ ∈ [0.1, 10]. We use the exponential sized represen-
K(xjk, xlm) = exp(
tation of Sec. 10.3 since for the case of proteins containing between two and ﬁve bonds, it
is more efﬁcient due to the low constants in the exponential problem size. We used com-
mercial QP software (CPLEX) to train our models. Training time took around 70 minutes
for 450 examples, using a sequential optimization procedure which solves QP subproblems
associated with blocks of training examples. We are currently working on an implemen-
tation of the certiﬁcate formulation Sec. 10.4 to handle longer sequences and non-perfect
matchings (when bonding state is unknown). Below, we describe several models we used.

The features we experimented with were all based on the local regions around candidate
cysteine pairs. For each pair of candidate cysteines {j, k}, where j < k, we extract the
amino-acid sequence in windows of size n centered at j and k. As in Baldi et al. [2004],
we augment the features of each model with the number of residues between j and k. The
models below use windows of size n = 9.

The ﬁrst model, SEQUENCE, uses the features described above: for each window, the
actual sequence is expanded to a 20 × n binary vector, in which the entries denote whether
or not a particular amino acid occurs at the particular position. For example, the 21st entry
in the vector represents whether or not the amino-acid Alanine occurs at position 2 of the
local window, counting from the left end of the window. The ﬁnal set of features for each
{j, k} pair of cysteines is simply the two local windows concatenated together, augmented
with the linear distance between the cysteine residues.

The second model, PROFILE, is the same as SEQUENCE, except that instead of us-
ing the actual protein sequence, we use multiple sequence alignment proﬁle information.
Multiple alignments were computed by running PSI-BLAST using default settings to align
the sequence with all sequences in the NR database [Altschul et al., 1997]. Thus, the in-
put at each position of a local window is the frequency of occurrence of each of the 20
amino-acids in the alignments.

156

CHAPTER10. MATCHINGS

K
2
3
4
5

PROFILE DAG-RNN
0.75 / 0.75
0.74 / 0.74
0.61 / 0.51
0.60 / 0.48
0.46 / 0.24
0.44 / 0.27
0.43 / 0.16
0.41 / 0.11
(a)

K SEQUENCE
0.70 / 0.70
2
0.62 / 0.52
3
4
0.44 / 0.21
0.29 / 0.06
5

PROFILE
0.73 / 0.73
0.67 / 0.59
0.59 / 0.44
0.43 / 0.17

(b)

PROFILE-SS
0.79 / 0.79
0.74 / 0.69
0.70 / 0.56
0.62 / 0.27

Table 10.1: Numbers indicate Precision / Accuracy. (a) Performance of PROFILE model
on SP39 vs. preliminary results of the DAG-RNN model [Baldi et al., 2004] which repre-
sent the best currently published results. In each row, the best performance is in bold. (b)
Performance of SEQUENCE, PROFILE, PROFILE-SS models on the DIPRO2 dataset.

The third model, PROFILE-SS, augments the PROFILE model with secondary structure
and solvent-accessibility information. The DSSP program produces 8 types of secondary
structure, so we augment each local window of size n with an additional length 8 × n
binary vector, as well as a length n binary vector representing the solvent accessibility at
each position.

Results and discussion

We evaluate our algorithm using two metrics: accuracy and precision. The accuracy mea-
sure counts how many full connectivity patterns were predicted correctly, whereas preci-
sion measures the number of correctly predicted bonds as a fraction of the total number of
possible bonds.

The ﬁrst set of experiments compares our model to preliminary results reported in Baldi
et al. [2004], which represent the current top-performing system. We perform 4-fold cross-
validation on SP39 in order to replicate their setup. As Table 10.1 shows, the PROFILE
model achieves comparable results, with similar or better levels of precision for all bond
numbers, and slightly lower accuracies for the case of 2 and 3 bonds.

In another experiment, we show the performance gained by using multiple alignment
information by comparing the results of the SEQUENCE model with the PROFILE. As we
can see from Table 10.1(b), the evolutionary information captured by the amino-acid align-
ment frequencies plays an important role in increasing the performance of the algorithm.

10.7. RELATEDWORK

157

(a)

(b)

Figure 10.3: Performance of PROFILE model as training set size changes for proteins with
(a) 2 and 3 bonds (b) 4 and 5 bonds.

The same phenomenon is observed by Vullo and Frasconi [2004] in their comparison of
sequence and proﬁle-based models.

As a ﬁnal experiment, we examine the role that secondary structure and solvent-accessibility

information plays in the model PROFILE-SS. Table 10.1(b) shows that the gains are sig-
niﬁcant, especially for sequences with 3 and 4 bonds. This highlights the importance of
developing even richer features, perhaps through more complex kernels.

Fig. 10.3 shows the performance of the PROFILE model as training set size grows. We
can see that for sequences of all bond numbers, both accuracy and precision increase as the
amount of data grows. The trend is more pronounced for sequences with 4 and 5 bonds
because they are sparsely distributed in the dataset. Such behavior is very promising, since
it validates the applicability of our algorithm as the availability of high-quality disulﬁde
bridge annotations increases with time.

10.7 Related work

The problem of inverse perfect matching has been studied by Liu and Zhang [2003] in
the inverse combinatorial optimization framework we describe in Sec. 4.3: Given a set of
nominal weights w0 and a perfect matching M, which is not a maximum one with respect
to w0, ﬁnd a new weight vector w that makes M optimal and minimizes ||w0 − w||p
for p = 1,∞. They do not provide a compact optimization problem for this related but

2 and 3 bonds20%30%40%50%60%70%80%90%100%100150200250300350400450Training Set SizeAccuracy (2 Bonds)Precision (3 Bonds)Accuracy (3 Bonds)4 and 5 bonds5%15%25%35%45%55%65%75%85%100150200250300350400450Training Set SizePrecision (4 Bonds)Accuracy (4 Bonds)Precision (5 Bonds)Accuracy (5 Bonds)158

CHAPTER10. MATCHINGS

different task, relying instead on the ellipsoid method with constraint generation.

The problem of disulﬁde bond prediction ﬁrst received comprehensive computational
treatment in Fariselli and Casadio [2001]. They modeled the prediction problem as ﬁnding
a perfect matching in a weighted graph where vertices represent bonded cysteine residues,
and edge weights correspond to attraction strength. The problem of learning the edge
weights was addressed using a simulated annealing procedure. Their method is only ap-
plicable to the case when bonding state is known. In Fariselli et al. [2002], the authors
switch to using a neural network for learning edge weights and achieve better performance,
especially for the case of 2 and 3 disulﬁde bonds.

The method in Vullo and Frasconi [2004] takes a different approach to the problem. It
scores candidate connectivity patterns according to their similarity with respect to the cor-
rect pattern, and uses a recursive neural network architecture [Frasconi et al., 1998] to score
candidate patterns. At prediction time the pattern scores are used to perform an exhaustive
search on the space of all matchings. The method is computationally limited to sequences
of 2 to 5 bonds. It also uses multiple alignment proﬁle information and demonstrates its
beneﬁts over sequence information.

In Baldi et al. [2004], the authors achieve the current state-of-the-art performance on
the task. Their method uses Directed Acyclic Graph Recursive Neural Networks [Baldi
& Pollastri, 2003] to predict bonding probabilities between cysteine pairs. The prediction
problem is solved using a weighted graph matching based on these probabilities. Their
method performs better than the one in Vullo and Frasconi [2004] and is also the only
one which can cope with sequences with more than 5 bonds. It also improves on previous
methods by not assuming knowledge of bonding state.

A different approach to predicting disulﬁde bridges is reported in Klepeis and Floudas
[2003], where bond prediction occurs as part of predicting β-sheet topology in proteins.
Residue-to-residue contacts (which include disulphide bridges) are predicted by solving a
series of constrained integer programming problems. Interestingly, the approach can be
used to predict disulﬁde bonds with no knowledge of bonding state, but the results are not
comparable with those in other publications.

The task of predicting whether or not a cysteine is bonded has also been addressed using
a variety of machine learning techniques including neural networks, SVMs, and HMMs

10.8. CONCLUSION

159

[Fariselli et al., 1999; Fiser & Simon, 2000; Martelli et al., 2002; Frasconi et al., 2002;
Ceroni et al., 2003] Currently the top performing systems have accuracies around 85%.

10.8 Conclusion

In this chapter, we derive a compact convex quadratic program for the problem of learning
to match. Our approach learns a parameterized scoring function that reproduces the ob-
served matchings in a training set. We present two formulations: one which is based on a
linear programming approach to matching, requiring an exponential number of constraints,
and one which develops a certiﬁcate of matching optimality for a compact polynomial-sized
representation. We apply our framework to the task of disulﬁde connectivity prediction, for-
mulated as a weighted matching problem. Our experimental results show that the method
can achieve performance comparable to current top-performing systems. Furthermore, the
use of kernels makes it easy to incorporate rich sets of features such as secondary structure
information, or extended local neighborhoods of the protein sequence. In the future, it will
be worthwhile to examine how other kernels, such as convolution kernels for protein se-
quences, will affect performance. We also hope to explore the more challenging problem
of disulﬁde connectivity prediction when the bonding state of cysteines is unknown. While
we have developed the framework to handle that task, it remains to experimentally deter-
mine how well the method performs, especially in comparison to existing methods [Baldi
et al., 2004], which have already addressed the more challenging setting.

Chapter 11

Correlation clustering

Data can often be grouped in many different reasonable clusterings. For example, one user
may organize her email messages by project and time, another by sender and topic. Images
can be segmented by hue or object boundaries. For a given application, there might be
only one of these clusterings that is desirable. Learning to cluster considers the problem of
ﬁnding desirable clusterings on new data, given example desirable clusterings on training
data.

We focus on correlation clustering, a novel clustering method that has recently en-
joyed signiﬁcant attention from the theoretical computer science community [Bansal et al.,
2002; Demaine & Immorlica, 2003; Emanuel & Fiat, 2003]. It is formulated as a vertex
partitioning problem: Given a graph with real-valued edge scores (both positive and neg-
ative), partition the vertices into clusters to maximize the score of intra-cluster edges, and
minimize the weight of inter-cluster edges. Positive edge weights represent correlations be-
tween vertices, encouraging those vertices to belong to a common cluster; negative weights
encourage the vertices to belong to different clusters. Unlike most clustering formulations,
correlation clustering does not require the user to specify the number of clusters nor a dis-
tance threshold for clustering; both of these parameters are effectively chosen to be the best
possible by the problem deﬁnition. These properties make correlation clustering a promis-
ing approach to many clustering problems; in machine learning, it has been successfully
applied to coreference resolution for proper nouns [McCallum & Wellner, 2003].

Recently, several algorithms based on linear programming and positive-semideﬁnite

160

11.1. CLUSTERINGFORMULATION

161

programming relaxations have been proposed to approximately solve this problem. In this
chapter, we employ these relaxations to derive a max-margin formulation for learning the
edge scores for correlation clustering from clustered training data. We formulate the ap-
proximate learning problem as a compact convex program with quadratic objective and
linear or positive-semideﬁnite constraints. Experiments on synthetic and real-world data
show the ability of the algorithm to learn an appropriate clustering metric for a variety of
desired clusterings.

11.1 Clustering formulation
An instance of correlation clustering is speciﬁed by an undirected graph G = (V,E) with
N nodes and edge score sjk for each jk in E, (j < k). We assume that the graph is fully
connected (if it is not, we can make it fully connected by adding appropriate edges jk with
sjk = 0). We deﬁne binary variables yjk, one for each edge jk, that represent whether node
j and k belong to the same cluster. Let Y be the space of assignments y that deﬁne legal
partitions. For notational convenience, we introduce both yjk and ykj variables, which will
be constrained to have the same value. We also introduce yjj variables, and ﬁx them to
have value 1 and set sjj = 0.

Bansal et al. [2002] consider two related problems:

(cid:88)

sjkyjk −

(cid:88)
(cid:88)

sjk(1 − yjk);

(cid:88)

max
y∈Y

min
y∈Y

jk:sjk>0

jk:sjk<0

sjk(1 − yjk) −

jk:sjk>0

jk:sjk<0

(MAXAGREE)

sjkyjk;

(MINDISAGREE)

The motivation for the names of the two problems comes from separating the set of edges
into positive weight edges and negative weight edges. The best score is obviously achieved
by including all the positive and excluding all the negative edges, but this will not generally
produce a valid partition. In MAXAGREE, we maximize the “agreement” of the partition
with the positive/negative designations: the weight of the positive included edges minus
the weight of negative excluded edges. In MINDISAGREE, we minimize the disagreement:
the weight of positive excluded edges minus the weight of negative included edges. In

162

CHAPTER11. CORRELATIONCLUSTERING

(cid:88)

particular, let

s∗ = max
y∈Y

sjkyjk;

s− =

(cid:88)

(cid:88)

sjk.

sjk;

s+ =

jk:sjk<0

jk:sjk>0

Then the value of MAXAGREE is s∗ − s− and the value of MINDISAGREE s+ − s∗. The
optimal partition for the two problems is of course the same (if it is unique). Bansal
et al. [2002] show that both of these problems are NP-hard (but have different approxi-
mation hardness). We will concentrate on the maximization version, MAXAGREE. Several
approximation algorithms have been developed based on Linear and Semideﬁnite Program-
ming [Charikar et al., 2003; Demaine & Immorlica, 2003; Emanuel & Fiat, 2003], which
we consider in the next sections.

11.1.1 Linear programming relaxation

In order to insure that y deﬁnes a partition, it is sufﬁcient to enforce a kind of triangle
inequality for each triple of nodes j < k < l:

yjk + ykl ≤ yjl + 1;

yjk + yjl ≤ ykl + 1;

yjl + ykl ≤ yjk + 1.

(11.1)

The triangle inequality enforces transitivity: if j and k are in the same cluster (yjk = 1)
and k and l are in the same cluster (ykl = 1), then j and l will be forced to be in this
cluster (yjl = 1). The other two cases are similar. Any symmetric, transitive binary relation
induces a partition of the objects.

With these deﬁnitions, we can express the MAXAGREE problem as an integer linear

program (ignoring the constant −s−):

(cid:88)

sjkyjk

max

s.t.

jk

yjk + ykl ≤ ylj + 1, ∀j, k, l;

yjj = 1, ∀j;

(11.2)
yjk ∈ {0, 1}, ∀j, k.

Note that the constraints imply that yab = yba for any two nodes a and b. To see this,
consider the inequalities involving node a and b with j = a, k = b, l = b and j = b, k =

11.1. CLUSTERINGFORMULATION

163

a, l = a:

yab + ybb ≤ yba + 1;

yba + yaa ≤ yab + 1;

Since yaa = ybb = 1, we have yab = yba.

The LP relaxation is obtained by replacing the binary variables yjk ∈ {0, 1} in Eq. (11.2)

with continuous variables 0 ≤ µjk ≤ 1.

µjk + µkl ≤ µlj + 1, ∀j, k, l;

µjj = 1, ∀j;

µjk ≥ 0, ∀j, k.

(11.3)

Note that µjk ≤ 1 is implied since the triangle inequality with j = l gives µjk + µkj ≤
µjj + 1, and since µjj = 1 and µjk = µkj, we have µjk ≤ 1.

We are not guaranteed that this relaxation will produce integral solutions. The LP
solution, sLP , is an upper bound on the s∗. Charikar et al. [2003] show that the integrality
gap of this upper bound is at least 2/3:

s∗ − s−
sLP − s− <

2
3

.

11.1.2 Semideﬁnite programming relaxation

An alternative formulation [Charikar et al., 2003] is the SDP relaxation. Let mat(µ) denote
the variables µjk arranged into a matrix.

(cid:88)

max

s.t.

sjkµjk

(11.4)

jk

mat(µ) (cid:186) 0;

µjj = 1, ∀j;

µjk ≥ 0, ∀j, k.

In effect, we substituted the triangle inequalities by the semideﬁnite constraint. To motivate
this relaxation, consider any clustering solution. Choose a collection of orthogonal unit
vectors {v1, . . . , vK}, one for each cluster in the solution. Every vertex j in the cluster
If vertices j and k
is assigned the unit vector vj corresponding to the cluster it is in.
are in the same cluster, then v(cid:62)
j vk = 0. The score of the clustering

j vk = 1, if not, v(cid:62)

164

CHAPTER11. CORRELATIONCLUSTERING

j vjv(cid:62)
j .

solution can now be expressed in terms of the dot products v(cid:62)
j vk. In the SDP relaxation
in Eq. (11.4), we have mat(µ) (cid:186) 0, which can be decomposed into a sum of outer products
mat(µ) =

(cid:80)

The entries µjk correspond to inner products v(cid:62)

j vk. The vectors generating the inner
products are unit vectors by the requirement µjj = 1. However, they do not necessarily
form a set of orthogonal vectors.

The SDP solution, sSDP , is also an upper bound on the s∗ and Charikar et al. [2003]

show that the integrality gap of this upper bound is at least 0.82843:

s∗ − s−
sSDP − s− ≤ 0.82843.

11.2 Learning formulation

The score for an edge is commonly derived from the characteristics of the pair of nodes.
Speciﬁcally, we parameterize the score as a weighted combination of basis functions

sjk = w(cid:62)f (xjk),

w, f (xjk) ∈ IRn, where xjk is a set of features associated with nodes j and k. In document
clustering, the entries of fxjk might be the words shared by the documents j and k, while if
one is clustering points in IRn, features might be distances along different dimensions. We
assume f (xjj) = 0 so that sjj = 0. Hence we write

(cid:88)

jk

w(cid:62)f (x, y) =

yjkw(cid:62)f (xjk).

Furthermore, we assume that the loss function decomposes over the edges, into a sum

of edge losses (cid:96)i,jk(yjk):

(cid:88)

(cid:88)

(cid:96)i(y) =

(cid:96)i,jk(yjk) =

yjk(cid:96)i,jk(1) + (1 − yjk)(cid:96)i,jk(0) = (cid:96)i(0) +

yjk(cid:96)i,jk,

jk

jk

jk

where (cid:96)i,jk = (cid:96)i,jk(1) − (cid:96)i,jk(0). For example, the Hamming loss counts the number of

(cid:88)

11.2. LEARNINGFORMULATION

165

(cid:88)

edges incorrectly cut or uncut by a partition.

(cid:96)H
i (y) =

1I(yjk (cid:54)= y(i)

jk ) =

y(i)
jk +

jk

jk

jk

where (cid:96)i,jk = 1 − 2y(i)
jk .

(cid:88)

(cid:88)

yjk(1 − 2y(i)

jk ) = (cid:96)H

i (0) +

(cid:88)

jk

yjk(cid:96)i,jk,

With this assumption, the loss augmented maximization is

(cid:96)i(0) + max
y∈Y

yjk[w(cid:62)f (x(i)

jk ) + (cid:96)i,jk].

(11.5)

(cid:88)

jk

We can now use the LP relaxation in Eq. (11.3) and the SDP relaxation in Eq. (11.4) as
upper bounds on Eq. (11.5). We use these upper-bounds in the min-max formulation to
achieve approximate max-margin estimation.

The dual of the LP based upper bound for example i is (cid:96)i(0)+

(cid:88)

j

(cid:88)
(cid:88)

jkl

l

(cid:88)

min

s.t.

λi,jkl +

zi,j

(11.6)

[λi,jkl + λi,ljk − λi,klj] ≥ w(cid:62)f (x(i)

jk ) + (cid:96)i,jk, ∀j (cid:54)= k;

[λi,jjl + λi,ljj − λi,jlj] ≥ (cid:96)i,jj, ∀j;

zi,j +
λi,jkl ≥ 0, ∀j, k, l.

l

Above, we introduced a dual variable λi,jkl for each triangle inequality and zi,j for the
identity on the diagonal. Note the righthand-side of the second set of inequalities follows
from the assumption f (xjj) = 0.

166

CHAPTER11. CORRELATIONCLUSTERING

Plugging this dual into the min-max formulation, we have:

min

s.t.

||w||2 + C
1
2
w(cid:62)f (x(i), y(i)) + ξi ≥ (cid:96)i(0) +

ξi

(cid:88)

(cid:88)

zi,j, ∀i;

λi,jkl +

(11.7)

(cid:88)

(cid:88)

l

(cid:88)

[λi,jkl + λi,ljk − λi,klj] ≥ w(cid:62)f (x(i)

jk ) + (cid:96)i,jk, ∀i,∀j (cid:54)= k;

jkl

j

[λi,jjl + λi,ljj − λi,jlj] ≥ (cid:96)i,jj, ∀i,∀j;

zi,j +
λi,jkl ≥ 0, ∀i,∀j, k, l.

l

Similarly, the dual of the SDP based upper bound is (cid:96)i(0)+

(cid:88)

j

min

s.t.

zi,j

(11.8)

jk ) + (cid:96)i,jk, ∀j (cid:54)= k;

−λi,jk ≥ w(cid:62)f (x(i)
zi,j − λi,jj ≥ (cid:96)i,jj ∀j;
mat(λi) (cid:186) 0.

Plugging the SDP dual into the min-max formulation, we have:

min

s.t.

||w||2 + C
1
2
w(cid:62)f (x(i), y(i)) + ξi ≥ (cid:96)i(0) +

ξi

(cid:88)

zi,j, ∀i;

(11.9)

(cid:88)

j

jk ) + (cid:96)i,jk, ∀i,∀j (cid:54)= k;

−λi,jk ≥ w(cid:62)f (x(i)
zi,j − λi,jj ≥ (cid:96)i,jj, ∀i,∀j;
mat(λi) (cid:186) 0, ∀i,∀j, k, l.

11.3. DUALFORMULATIONANDKERNELS

167

11.3 Dual formulation and kernels

The dual of Eq. (11.7) and Eq. (11.9) provide some insight into the structure of the problem
and enable efﬁcient use of kernels. Here we give the dual of Eq. (11.7):

(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)
(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)(cid:88)

i,jk

(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)
(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)2

µi,jk(cid:96)i,jk − 1
2

C

jk − µi,jk)f (x(i)
(y(i)
jk )

µjk + µkl ≤ µlj + 1, ∀i,∀j, k, l;

µi,jj = 1, ∀i,∀j;

µi,jk ≥ 0, ∀i,∀j, k.

(cid:88)

i,jk

max

s.t.

(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)

(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)2

(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)
(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)(cid:88)

i,jk

(cid:88)

The dual of Eq. (11.9) is very similar, except that the linear transitivity constraints

µjk + µkl ≤ µlj + 1,

∀i,∀j, k, l are replaced by the corresponding mat(µi) (cid:186) 0:

(cid:88)

max

s.t.

µi,jk(cid:96)i,jk − 1
C
2
mat(µi) (cid:186) 0, ∀i;

i,jk

jk − µi,jk)f (x(i)
(y(i)
jk )
µi,jj = 1, ∀i,∀j;

µi,jk ≥ 0, ∀i,∀j, k.

The relation between the primal and dual solution is

w = C

jk − µjk)f (x(i)
(y(i)
jk ).

(11.10)

i,jk

One important consequence of this relationship is that the edge parameters are all sup-
port vector expansions. The dual objective can be expressed in terms of dot-products
f (xjk)(cid:62)f (xlm). Therefore, we can use kernels K(xjk, xlm) to deﬁne the space of basis
functions. This kernel looks at two pairs of nodes, (j, k) and (l, m), and measures the
similarity between the relation between the nodes of each pair. If we are clustering points
in Euclidian space, the kernel could be a function of the two segments corresponding to
the pairs of points, for example, a polynomial kernel over their lengths and angle between
them.

168

CHAPTER11. CORRELATIONCLUSTERING

11.4 Experiments

We present experiments on a synthetic problem exploring the effect of irrelevant basis
functions (features), and two real data sets, email clustering and image segmentation.

11.4.1 Irrelevant features

In this section, we explore on a synthetic example how our algorithm deals with irrele-
vant features.
In particular, we generate data (100 points) from a mixture of two one-
dimensional Gaussians, where each mixture component corresponds to a cluster. This ﬁrst
dimension is thus the relevant feature. Then we add noise components in D additional
(irrelevant) dimensions. The noise is independently generated for each dimension, from a
mixture of Gaussians with same difference in means and variance as for the relevant dimen-
sion. Figure 11.1(a) shows the projection of a data sample onto the ﬁrst two dimensions
and on two irrelevant dimensions.

Let xj denote each point and xj[d] denote the d-th dimension of the point. We used
a basis function for each dimension fd(xjk) = e−(xj [d]−xk[d])2, plus an additional constant
basis function. The training and test data consists of a 100 samples from the model. The
results in Fig. 11.1(b) illustrate the capability of our algorithm to learn to ignore irrelevant
dimensions. The accuracy is the fraction of edges correctly predicted to be between/within
cluster. Random clustering will give an accuracy of 50%. The comparison with k-means is
simply a baseline to illustrate the effect of the noise on the data.

11.4.2 Email clustering

We also test our approach on the task of clustering email into folders. We gathered the
data from the SRI CALO project.1 Our dataset consisted of email from seven users (ap-
proximately 100 consecutive messages per user), which the users had manually ﬁled into
different folders. The number of folders for each users varied from two to six, with an
average of 3-4 folders. We are interested in the problem of learning to cluster emails.

1http://www.ai.sri.com/project/CALO

11.4. EXPERIMENTS

169

(a)

(b)

Figure 11.1: (a) Projection onto ﬁrst two dimensions (top) and two noise dimensions (bot-
tom); (c) Performance on 2 cluster problem as function of the number of irrelevant noise
dimensions. Learning to cluster is the solid line, k-means the dashed line. Error-bars de-
note one standard deviation, averages are over 20 runs. Accuracy is the fraction of edges
correctly predicted to be between/within cluster.

Speciﬁcally, what score function sjk causes correlation clustering to give clusters similar
to those that human users had chosen?

To test our learning algorithm, we use each user as a training set in turn, learning the
parameters from the partition of a single user’s mailbox into folders. We then use the
learned parameters to cluster the other users’ mail. The basis functions f (xjk) measured the
similarity between the text of the messages, the similarity between the “From:” ﬁeld, “To:”
ﬁeld, and “Cc:” ﬁeld. One feature was used for each common word in the pair of emails
(except words that appeared in more than half the messages, which were deemed “stop
words” and omitted). Also, additional features captured the proportion of shared tokens
for each email ﬁeld, including the from, to, Cc, subject and body ﬁelds. The algorithm
is therefore able to automatically learn the relative importance of certain email ﬁelds to
ﬁling two messages together, as well as importance of meaningful words versus common,
irrelevant ones.

We compare our method to the k-means clustering algorithm using with the same word

−4−3−2−10123−4−3−2−101234−4−3−2−101234−4−3−2−1012340.450.550.650.750.850.951248163264128# noise dimensionstest accuracylcck-means170

CHAPTER11. CORRELATIONCLUSTERING

Figure 11.2: Average Pair F1 measure for clustering user mailboxes.

features, and took the best clustering out of ﬁve tries. We made this comparison somewhat
easy for k-means by giving it the correct number of clusters k. We also informed our algo-
rithm of the number of clusters by uniformly adding a positive weight to the edge weights
to cause it to give the correct number of clusters. We performed a simple binary search on
this additional bias weight parameter to ﬁnd the number of clusters comparable to k. The
results in Fig. 11.2 show the average F 1 measure (harmonic mean of precision and recall;
a standard metric in information retrieval [Baeza-Yates & Ribeiro-Neto, 1999]) computed
on the pairs of messages that belonged to the same cluster. Our algorithm signiﬁcantly
outperforms k-means on several users and does worse only for one of the users.

11.4.3 Image segmentation

We also test our approach on the task of image segmentation. We selected images from
the Berkeley Image Segmentation Dataset [Martin et al., 2001] for which two users had
signiﬁcantly different segmentations. For example, Fig. 11.3(a) and (b) show two distinct
segmentations: one very coarse, mostly based of overall hue, and one much ﬁner, based
on the hue and intensity. Depending on the task at hand, we may prefer the ﬁrst over the
second or vice-versa. It is precisely this kind of variability in the similarity judgements that

00.10.20.30.40.50.60.70.81234567UserPair F1lcck-means11.4. EXPERIMENTS

171

(a)

(b)

Figure 11.3: Two segmentations by different users: training image with (a) coarse segmen-
tation and (b) ﬁne segmentation.

we want our algorithm to capture.

In order to segment the image, we ﬁrst divided it contiguous regions of approximately
the same color by running connected components on the pixels. We connected two adjacent
pixels by an edge if their RGB value was the same at a coarse resolution (4 bits per each
of the R,G,B channel). We then selected about a hundred largest regions, which covered
80-90% of the pixels. These regions are the objects that our algorithm learns to cluster.
(We then use the learned metric to greedily assign the remaining small regions to the large
adjoining regions.)

There is a rich space of possible features we can use in our models: for each pair
of regions, we can consider their shape, color distribution, distance, presence of edges
between them, etc. In our experiments, we used a fairly simple set of features that are very
easy to compute. For each region, we calculated the bounding box, area and average color
(averaging the pixels in the RGB space). We then computed three distances (one for each
HSV channel), as well as the distance in pixels between the bounding boxes and the area
of the smaller of the two regions. All features were normalized to have zero mean and
variance 1.

We trained two models, one using Fig. 11.3(a) and the other using Fig. 11.3(b) and

172

CHAPTER11. CORRELATIONCLUSTERING

(a)

(b)

(c)

Figure 11.4: Test image: (a) input; (b) segmentation based on coarse training data (c)
segmentation based on ﬁne training data.

tested on the image in Fig. 11.4(a). The results are shown in Fig. 11.4(b) and (c), respec-
tively. Note that mountains, rocks and grass are segmented very coarsely based on hue in
(b) while the segmentation in (c) is more detailed and sensitive to saturation and value of
the colors.

11.5 Related work

The performance of most clustering algorithms depends critically on the distance metric
that they are given for measuring the similarity or dissimilarity between different data-
points. Recently, a number of algorithms have been proposed for automatically learning
distance metrics as a preprocessing step for clustering [Xing et al., 2002; Bar-Hillel et al.,
2003]. In contrast to algorithms that learn a metric independently of the algorithm that will
be used to cluster the data, we describe a formulation that tightly integrates metric learning
with the clustering algorithm, tuning one to the other in a joint optimization. Thus, instead
of using an externally-deﬁned criterion for choosing the metric, we will instead seek to
learn a good metric for the clustering algorithm. An example of work in a similar vein is
the algorithm for learning a distance metric for spectral clustering [Bach & Jordan, 2003].
The clustering algorithm essentially uses an eigenvector decomposition of an appropriate
matrix derived from the pairwise afﬁnity matrix, which is more efﬁcient than correlation
clustering, for which we use LP or SDP formulations. However the objective in the learning

11.6. CONCLUSION

173

formulation proposed in Bach and Jordan [2003] is not convex and difﬁcult to optimize.

11.6 Conclusion

We looked at correlation clustering, and how to learn the edge weights from example clus-
terings. Our approach ties together the inference and learning algorithm, and attempts
to learn a good metric speciﬁcally for the clustering algorithm.. We showed results on a
synthetic dataset, showcasing robustness to noise dimensions. Experiments on the CALO
e-mail and image segmentation experiments show the potential of the algorithm on real-
world data. The main limitation of the correlation clustering is scalability: the number of
constraints (|V|3) in the LP relaxation and the size of the positive-semideﬁnite constraint
in the SDP relaxation. It would be very interesting to explore constraint generation or sim-
ilar approaches to speed up learning and inference. On the theoretical side, it would be
interesting to work out a PAC-like bound for generalization of the learned score metric.

174

CHAPTER11. CORRELATIONCLUSTERING

Part IV

Conclusions and future directions

175

Chapter 12

Conclusions and future directions

This thesis presents a novel statistical estimation framework for structured models based
on the large margin principle underlying support vector machines. The framework results
in several efﬁcient learning formulations for complex prediction tasks. Fundamentally,
we rely on the expressive power of convex optimization problems to compactly capture
inference or solution optimality in structured models. Directly embedding this structure
within the learning formulation produces compact convex problems for efﬁcient estimation
of very complex models. For some of these models, alternative estimation methods are
intractable. We develop theoretical foundations for our approach and show a wide range
of experimental applications, including handwriting recognition, 3D terrain classiﬁcation,
disulﬁde connectivity in protein structure prediction, hypertext categorization, natural lan-
guage parsing, email organization and image segmentation.

12.1 Summary of contributions
We view a structured prediction model as a mapping from the space of inputs x ∈ X to
a discrete vector output y ∈ Y. Essentially, a model deﬁnes a compact, parameterized
scoring function w(cid:62)f (x, y) and prediction using the model reduces to ﬁnding the highest
scoring output y given the input x. Our class of models has the following linear form:

hw(x) = arg max
y : g(x,y)≤0

w(cid:62)f (x, y),

176

12.1. SUMMARYOFCONTRIBUTIONS

177

where w ∈ IRn is the vector of parameters of the model, constraints g(x, y) ∈ IRk deﬁne
the space of feasible outputs y given the input x and basis functions f (x, y) ∈ IRn represent
salient features of the input/output pair. Although the space of outputs {y : g(x, y) ≤ 0} is
usually immense, we assume that the inference problem arg maxy : g(x,y)≤0 w(cid:62)f (x, y) can
be solved (or closely approximated) by an efﬁcient algorithm that exploits the structure of
the constraints g and basis functions f. This deﬁnition covers a broad range of models,
from probabilistic models such as Markov networks and context free grammars to more
unconventional models like weighted graph-cuts and matchings.

12.1.1 Structured maximum margin estimation

Given a sample S = {(x(i), y(i))}m
that:

y∈Y (i)
where Y (i) = {y : g(x(i), y) ≤ 0}.

The naive formulation1 uses

i=1, we develop methods for ﬁnding parameters w such

arg max

w(cid:62)f (x(i), y) ≈ y(i), ∀i,

(cid:80)
i |Y (i)| linear constraints, which is generally exponential

in the number of variables in each y(i).

min

s.t.

||w||2
1
2
w(cid:62)fi(y(i)) ≥ w(cid:62)fi(y) + (cid:96)i(y), ∀i, ∀y ∈ Y (i).

We propose two general approaches that transform the above exponential size QP to an
exactly equivalent polynomial size QP in many important classes of models. These formu-
lations allow us to ﬁnd globally optimal parameters (with ﬁxed precision) in polynomial
time using standard optimization software. In many models where maximum likelihood
estimation is intractable, we provide exact maximum margin solutions (Ch. 7 and Ch. 10).

1For simplicity, we omit the slack variables in this summary.

178

CHAPTER12. CONCLUSIONSANDFUTUREDIRECTIONS

Min-max formulation

We can turn the above problem into an equivalent min-max formulation with i non-linear
max-constraints:

min

s.t.

||w||2
1
2
w(cid:62)fi(y(i)) ≥ max
y∈Y (i)

[w(cid:62)fi(y) + (cid:96)i(y)], ∀i.

The key to solving the estimation problem above efﬁciently is the loss-augmented infer-
ence problem maxy∈Y (i)[w(cid:62)fi(y) + (cid:96)i(y)]. Even if maxy∈Y (i) w(cid:62)fi(y) can be solved in
polynomial time using convex optimization, the form of the loss term (cid:96)i(y) is crucial for
the loss-augmented inference to remain tractable. We typically use a natural loss func-
tion which is essentially the Hamming distance between y(i) and h(x(i)): the number of
variables predicted incorrectly.

We show that if we can express the (loss-augmented) inference as a compact convex
optimization problem (e.g., LP, QP, SDP, etc.), we can embed the maximization inside the
min-max formulation to get a compact convex program equivalent to the naive exponential
formulation. We show that this approach leads to exact polynomial-size formulations for
estimation of low-treewidth Markov networks, associative Markov networks over binary
variables, context-free grammars, bipartite matchings, and many other models.

Certiﬁcate formulation

There are several important combinatorial problems which allow polynomial time solu-
tion yet do not have a compact convex optimization formulation. For example, maximum
weight perfect (non-bipartite) matching and spanning tree problems can be expressed as
linear programs with exponentially many constraints, but no polynomial formulation is
known [Bertsimas & Tsitsiklis, 1997; Schrijver, 2003]. Both of these problems, however,
can be solved in polynomial time using combinatorial algorithms. In some cases, though,
we can ﬁnd a compact certiﬁcate of optimality that guarantees that

y(i) = arg max

y

[w(cid:62)fi(y) + (cid:96)i(y)].

12.1. SUMMARYOFCONTRIBUTIONS

179

For perfect (non-bipartite) matchings, this certiﬁcate is a condition that ensures there are
no augmenting alternating cycles (see Ch. 10). We can express this condition by deﬁning
an auxiliary distance function on the nodes an a set of linear constraints that are satisﬁed if
and only if there are no negative cycles. This simple set of linear constraints scales linearly
with the number of edges in the graph. Similarly, we can derive a compact certiﬁcate for
the spanning tree problem.

The certiﬁcate formulation relies on the fact that verifying optimality of a solution is
often easier than actually ﬁnding one. This observation allows us to apply our framework
to an even broader range of models with combinatorial structure than the min-max formu-
lation.

Maximum margin vs. maximum likelihood

There are several theoretical advantages to our approach in addition to the empirical accu-
racy improvements we have shown experimentally. Because our approach only relies on
using the maximum in the model for prediction, and does not require a normalized dis-
tribution P (y | x) over all outputs, maximum margin estimation can be tractable when
maximum likelihood is not. For example, to learn a probabilistic model P (y | x) over
bipartite matchings using maximum likelihood requires computing the normalizing parti-
tion function, which is #P-complete [Valiant, 1979; Garey & Johnson, 1979]. By contrast,
maximum margin estimation can be formulated as a compact QP with linear constraints.
Similar results hold for an important subclass of Markov networks and non-bipartite match-
ings.

In models that are tractable for both maximum likelihood and maximum margin (such
as low-treewidth Markov networks, context free grammars, many other problems in which
inference is solvable by dynamic programming), our approach has an additional advantage.
Because of the hinge-loss, the solutions to the estimation are relatively sparse in the dual
space (as in SVMs), which makes the use of kernels much more efﬁcient. Maximum like-
lihood models with kernels are generally non-sparse and require pruning or greedy support
vector selection methods [Wahba et al., 1993; Zhu & Hastie, 2001; Lafferty et al., 2004;
Altun et al., 2004].

180

CHAPTER12. CONCLUSIONSANDFUTUREDIRECTIONS

There are, of course, several advantages to maximum likelihood estimation. In appli-
cations where probabilistic conﬁdence information is a must, maximum likelihood is much
more appropriate. Also, in training settings with missing data and hidden variables, proba-
bilistic interpretation permits the use of well-understood algorithms such as EM [Dempster
et al., 1977].

Approximations

In many problems, the maximization problem we are interested in may be NP-hard, for
example, we consider MAP inference in large treewidth Markov networks in Ch. 8, multi-
way cuts in Ch. 7, graph-partitioning in Ch. 11. Many such problems can be written as
integer programs. Relaxations of such integer programs into LPs, QPs or SDPs often pro-
vide excellent approximation algorithms and ﬁt well within our framework, particularly the
min-max formulation. We show empirically that these approximations are very effective in
many applications.

12.1.2 Markov networks: max-margin, associative, relational

The largest portion of the thesis is devoted to novel estimation algorithms, representational
extensions, generalization analysis and experimental validation for Markov networks.

◦ Low-treewidth Markov networks

We use a compact LP for MAP inference in Markov networks with sequence and
other low-treewidth structure to derive an exact, compact, convex learning formu-
lation. The dual formulation allows efﬁcient integration of kernels with graphical
models that leverages rich high-dimensional representations for accurate prediction
in real-world tasks.

◦ Scalable online algorithm

Although our convex formulation is a QP with linear number of variables and con-
straints in the size of the data, for large datasets (millions of examples), it is very
difﬁcult to solve using standard software. We present an efﬁcient algorithm for solv-
ing the estimation problem called Structured SMO. Our online-style algorithm uses

12.1. SUMMARYOFCONTRIBUTIONS

181

inference in the model and analytic updates to solve extremely large estimation prob-
lems.

◦ Generalization analysis

We analyze the theoretical generalization properties of max-margin estimation in
Markov networks and derive a novel margin-based bound for structured prediction.
This is the ﬁrst bound to address structured error (e.g., proportion of mislabeled
pixels in an image).

◦ Learning associative Markov networks (AMNs)

We deﬁne an important subclass of Markov networks that captures positive correla-
tions present in many domains. This class of networks extends the Potts model [Potts,
1952] often used in computer vision and allows exact MAP inference in the case of
binary variables. We show how to express the inference problem using an LP which
is exact for binary networks. As a result, for associative Markov networks over bi-
nary variables, our framework allows exact estimation of networks of arbitrary con-
nectivity and topology, for which likelihood methods are believed to be intractable.
For the non-binary case, we provide an approximation that works well in practice.
We present an AMN-based method for object segmentation from 3D range data. By
constraining the class of Markov networks to AMNs, our models are learned efﬁ-
ciently and, at run-time, can scale up to tens of millions of nodes and edges by using
graph-cut based inference [Kolmogorov & Zabih, 2002].

◦ Representation and learning of relational Markov networks

We introduce relational Markov networks (RMNs), which compactly deﬁne tem-
plates for Markov networks for domains with relational structure: objects, attributes,
relations. The graphical structure of an RMN is based on the relational structure of
the domain, and can easily model complex interaction patterns over related entities.
We apply this class of models to classiﬁcation of hypertext using hyperlink structure
to deﬁne relations between webpages. We use a compact approximate MAP LP in
these complex Markov networks, in which exact inference is intractable, to derive an
approximate max-margin formulation.

182

CHAPTER12. CONCLUSIONSANDFUTUREDIRECTIONS

12.1.3 Broader applications: parsing, matching, clustering

The other large portion of the thesis addresses a range of prediction tasks with very diverse
models: context free grammars for natural language parsing, perfect matchings for disulﬁde
connectivity in protein structure prediction, graph partitions for clustering documents and
segmenting images.

◦ Learning to parse

We exploit dynamic programming decomposition of context free grammars to derive
a compact max-margin formulation. We build on a recently proposed “unlexicalized”
grammar that allows cubic time parsing and we show how to achieve high-accuracy
parsing (still in cubic time) by exploiting novel kinds of lexical information. We show
experimental evidence of the model’s improved performance over several baseline
models.

◦ Learning to match

We use a combinatorial optimality condition, namely the absence of augmenting al-
ternating cycles, to derive an exact, efﬁcient certiﬁcate formulation for learning to
match. We apply our framework to prediction of disulﬁde connectivity in proteins
using perfect matchings. The algorithm we propose uses kernels, which makes it pos-
sible to efﬁciently embed input features in very high-dimensional spaces and achieve
state-of-the-art accuracy.

◦ Learning to cluster

By expressing the correlation clustering problem as a compact LP and SDP, we use
the min-max formulation to learn a parameterized scoring function for clustering. In
contrast to algorithms that learn a metric independently of the algorithm that will
be used to cluster the data, we describe a formulation that tightly integrates metric
learning with the clustering algorithm, tuning one to the other in a joint optimization.
We formulate the approximate learning problem as a compact convex program. Ex-
periments on synthetic and real-world data show the ability of the algorithm to learn
an appropriate clustering metric for a variety of desired clusterings, including email
folder organization and image segmentation.

12.2. EXTENSIONSANDOPENPROBLEMS

183

12.2 Extensions and open problems

There are several immediate applications, less immediate extensions and open problems for
our estimation framework. We organize these ideas into several sections below, including
further theoretical analysis and new optimization algorithms, novel prediction tasks, and
more general learning settings.

12.2.1 Theoretical analysis and optimization algorithms

◦ Approximation bounds

In several of the intractable models, like multi-class AMNs in Ch. 7 and correlation
clustering in Ch. 11, we used approximate convex programs within the min-max for-
mulation. These approximate inference programs have strong relative error bounds.
An open question is to translate these error bounds on inference into error bounds on
the resulting max-margin formulations.

◦ Generalization bounds with distributional assumptions

In Ch. 5, we presented a bound on the structured error in Markov networks, with-
out any assumption about the distribution of P (y | x), relying only on the samples
(x(i), y(i)) being i.i.d. This distribution-free assumption leads to a worst case analy-
sis, while some assumptions about the approximate decomposition P (y | x) may be
warranted. For example, for sequential prediction problems, the Markov assumption
of some ﬁnite order is reasonable (i.e., given the input and previous k labels, the next
label is independent of the labels more than k in the past). In spatial prediction tasks,
a label variable is independent of the rest given a large enough ball of labels around
it. Similar assumptions may be made for some “degree of separation” in relational
domains. More generally, it would be interesting to exploit such conditional indepen-
dence assumptions or asymptotic bounds on entropy of P (y | x) to get generalization
guarantees even from a single structured example (x, y).

◦ Problem-speciﬁc optimization methods

Although our convex formulations are polynomial in the size of the data, scaling

184

CHAPTER12. CONCLUSIONSANDFUTUREDIRECTIONS

up to larger datasets will require problem-speciﬁc optimization methods. For low-
treewidth Markov networks and context free grammars, we have presented the Struc-
tured SMO algorithm. Another algorithm useful for such models is Exponentiated
Gradient [Bartlett et al., 2004]. Both algorithms rely on dynamic programming de-
compositions. However, models which do not permit such decompositions, such as
graph-cuts, matchings, and many others, create a need for new algorithms that can ef-
fectively use combinatorial optimization as a subroutine to eliminate the dependence
on general-purpose convex solvers.

12.2.2 Novel prediction tasks

◦ Bipartite matchings

Maximum weight bipartite matchings are used in a variety of problems to predict
mappings between sets of items.
In machine translation, matchings are used to
map words of the two languages in aligned sentences [Matusov et al., 2004]. In 2D
shape matching, points on two shapes are matched based on their local contour fea-
tures [Belongie et al., 2002]. Our framework provides an exact, efﬁcient alternative
to the maximum likelihood estimation for learning the matching scoring function.

◦ Sequence alignment

In standard pairwise alignment of biological sequences, a string edit distance is used
to determine which portions of the sequences align to each other [Needleman &
Wunsch, 1970; Durbin et al., 1998]. Finding the best alignment involves a dynamic
program that generalizes the longest common subsequence algorithm. Our frame-
work can be applied (just as in context free grammar estimation) to efﬁciently learn
a more complex edit function that depends on the contextual string features, perhaps
using novel string kernels [Haussler, 1999; Leslie et al., 2002; Lodhi et al., 2000].

◦ Continuous prediction problems

We have addressed estimation of models with discrete output spaces, generalizing
classiﬁcation models to multivariate, structured classiﬁcation. Similarly, we can
consider a whole range of problems where the prediction variables are continuous.

12.2. EXTENSIONSANDOPENPROBLEMS

185

Such problems are a natural generalizations of regression, involving correlated, inter-
constrained real-valued outputs. For example, several recent models of metabolic
ﬂux in yeast use linear programming formulations involving quantities of various
enzymes, with stoichiometric constraints [Varma & Palsson, 1994].
It would be
interesting to use observed equilibria data under different conditions to learn what
“objective” the cell is maximizing. In ﬁnancial modeling, convex programs are often
used to model portfolio management; for example, Markowitz portfolio optimization
is formulated as a quadratic program which minimizes risk and maximizes expected
return under budget constraints [Markowitz, 1991; Luenberger, 1997]. In this setting,
one could learn a user’s return projection and risk assessment function from observed
portfolio allocations by the user.

These problems are similar to the discrete structured prediction models we have con-
sidered: inference in the model can formulated as a convex optimization problem.
However, there are obstacles to directly applying the min-max or certiﬁcate formu-
lations. Details of this are beyond the scope of this thesis, but it sufﬁces to say that
loss-augmented inference using, Hamming distance equivalent, L1 loss (or L2 loss),
no longer produces a maximization of a concave objective with convex constraints
since L1, L2 are convex, not concave (it turns out that it is actually possible to use
L∞ loss). Developing effective loss functions and max-margin formulations for the
continuous setting could provide a novel set of effective models for structured multi-
variate real-valued prediction problems.

12.2.3 More general learning settings

◦ Structure learning

We have focused on the problem of learning parameters of the model (even though
our kernelized models can be considered non-parametric). In the case of Markov
networks, especially in spatial and relational domains, there is a wealth of possible
structures (cliques in the network) one can use to model a problem. It is particularly
interesting to explore the problem of inducing these cliques automatically from data.
The standard method of greedy stepwise selection followed by re-estimation is very

186

CHAPTER12. CONCLUSIONSANDFUTUREDIRECTIONS

expensive in general networks [Della Pietra et al., 1997; Bach & Jordan, 2001].
Recent work on selecting input features in Markov networks (or CRFs) uses several
approximations to learn efﬁciently with millions of candidate features [McCallum,
2003]. However, clique selection is still relatively unexplored. It is possible that
AMNs, by restricting the network to be tractable under any structure, may permit
more efﬁcient clique selection methods.

◦ Semi-supervised learning

Throughout the thesis we have assumed completely labeled data. This assumption
often limits us to relatively small training sets where data has been carefully anno-
tated, while much of the easily accessible data is not at all or suitably labeled. There
are several more general settings we would like to extend our framework.

The simplest setting is a mix of labeled and unlabeled examples, where a small su-
pervised dataset is augmented by a large unsupervised one. There has been much
research in this setting for classiﬁcation [Blum & Mitchell, 1998; Nigam et al., 2000;
Chapelle et al., 2002; Szummer & Jaakkola, 2001; Zhu et al., 2003; Corduneanu &
Jaakkola, 2003]. Although most of this work has been done in a probabilistic set-
ting, the principle of regularizing (discouraging) decision boundaries near densely
clustered inputs could be applicable to our structured setting.

A more complex and rich setting involves presence of hidden variables in each ex-
ample. For example, in machine translation, word correspondences between pairs of
sentences are usually not manually annotated (at least not on a large scale). These
correspondence variables can be treated as hidden variables. Similarly, in handwrit-
ing recognition, we may not have each letter segmented out but instead just get a
word or sentence as a label for the entire image. This setting has been studied mainly
in the probabilistic, generative models often using the EM algorithm [Dempster et al.,
1977; Cowell et al., 1999]. Discriminative methods have been explored far less. Es-
pecially in the case of combinatorial structures, extensions of our framework allow
opportunities for problem-speciﬁc convex approximations to be exploited.

12.3. FUTURE

12.3 Future

187

We have presented a supervised learning framework for a large class of prediction mod-
els with rich and interesting structure. Our approach has several theoretical and practical
advantages over standard probabilistic models and estimation methods for structured pre-
diction. We hope that continued research in this framework will help tackle evermore
sophisticated prediction problems in the future.

Appendix A

Proofs and derivations

A.1 Proof of Theorem 5.5.1

The proof of Theorem 5.5.1 uses the covering number bounds of Zhang [2002] (in the
Data-Dependent Structural Risk Minimization framework [Shawe-Taylor et al., 1998].)
Zhang provides generalization guarantees for linear binary classiﬁers of the form hw(x) =
sgn(w(cid:62)x). His analysis is based on the upper bounds on the covering number for the class
of linear functions FL(w, z) = w(cid:62)z where the norms of the vectors w and z are bounded.
We reproduce the relevant deﬁnitions and theorems from Zhang [2002] here to highlight
the necessary extensions for structured classiﬁcation.

The covering number is a key quantity in measuring function complexity. Intuitively,
the covering number of an inﬁnite class of functions (e.g. parameterized by a set of weights
w) is the number of vectors necessary to approximate the values of any function in the class
on a sample. Margin-based analysis of generalization error uses the margin achieved by a
classiﬁer on the training set to approximate the original function class of the classiﬁer by
a ﬁnite covering with precision that depends on the margin. Here, we will only deﬁne the
∞-norm covering number.

188

A.1. PROOFOFTHEOREM5.5.1

189

A.1.1 Binary classiﬁcation
In binary classiﬁcation, we are given a sample S = {x(i), y(i)}m
X × Y, where X = IRn and Y is mapped to ±1, so we can fold x and y into z = yx.

i=1, from distribution D over

Deﬁnition A.1.1 (Covering Number) Let V = {v(1), . . . , v(r)}, where v(j) ∈ IRm, be a
covering of a function class F(w, S) with -precision under the metric ρ, if for all w there
exists a v(j) such that for each data sample z(i) ∈ S:

ρ(v(j)

i

,F(w, z(i))) ≤ .

The covering number of a sample S is the size of the smallest covering: N∞(F, ρ, , S) =
inf |V| s.t. V is a covering of F(w, S). We also deﬁne the covering number for any sample
of size m: N∞(F, ρ, , m) = supS: |S|=m N∞(F, ρ, , S).

When the norms of w and z are bounded, we have the following upper bound on the

covering number of linear functions under the linear metric ρL(v, v(cid:48)) = |v − v(cid:48)|.
Theorem A.1.2 (Theorem 4 from Zhang [2002]) If (cid:107)w(cid:107)2 ≤ a and (cid:107)z(cid:107)2 ≤ b, then ∀
 > 0,

log2 N∞(FL, ρL, , m) ≤ 36

a2b2
2

log2 (2(cid:100)4ab/ + 2(cid:101) m + 1) .

In order to use the classiﬁer’s margin to bound its expected loss, the bounds below use
a stricter, margin-based loss on the training sample that measures the worst loss achieved
by the approximate covering based on this margin. Let f : IR (cid:55)→ [0, 1] be a loss function.
In binary classiﬁcation, we let f (v) = 1I(v ≤ 0) be the step function, so that 0-1 loss of
sgn(w(cid:62)x) is f (FL(w, z)). The next theorem bounds the expected f loss in terms of the
γ-margin loss, f γ(v) = supρ(v,v(cid:48))<2γ f (v(cid:48)), on the training sample. For 0-1 loss and linear
metric ρL, the corresponding γ-margin loss is f γ(v) = 1I(v ≤ 2γ).

Theorem A.1.3 (Corollary 1 from Zhang [2002]) Let f : IR (cid:55)→ [0, 1] be a loss function
and f γ(v) = supρ(v,v(cid:48))<2γ f (v(cid:48)) be the γ-margin loss for a metric ρ. Let γ1 > γ2 > . . . be

190

APPENDIXA. PROOFSANDDERIVATIONS

(cid:80)∞

a decreasing sequence of parameters, and pi be a sequence of positive numbers such that

i=1 pi = 1, then for all δ > 0, with probability of at least 1 − δ over data:

(cid:115)

(cid:183)

(cid:184)

ED[f (F(w, z))] ≤ ES[f γ(F(w, z))] +

32
m

ln 4N∞(F, ρ, γi, S) + ln

1
piδ

for all w and γ, where for each ﬁxed γ, we use i to denote the smallest index s.t. γi ≤ γ.

A.1.2 Structured classiﬁcation

We will extend this framework to bound the average per-label loss (cid:96)H(y)/L for structured
classiﬁcation by deﬁning an appropriate loss f and a function class F (as well as a metric
ρ) such that f (F) computes average per-label loss and f γ(F) provides a suitable γ-margin
loss. We will bound the corresponding covering number by building on the bound in The-
orem A.1.2.

We can no longer simply fold x and y, since y is a vector, so we let z = (x, y). In
order for our loss function to compute average per-label loss, it is convenient to make our
function class vector-valued (instead of scalar-valued as above). We deﬁne a new function
class FM (w, z), which is a vector of minimum values of w(cid:62)∆fi(y) for each error level
(cid:96)H(y) from 1 to L as described below.

Deﬁnition A.1.4 (dth-error-level function) The dth-error-level function Md(w, z) for d ∈
{1, . . . , L} is given by:

Md(w, z) = min

y:(cid:96)H (y)=d

w(cid:62)∆fi(y).

Deﬁnition A.1.5 (Multi-error-level function class) The multi-error-level function class FM (w, z)
is given by:

FM (w, z) = (M1(w, z), . . . , Md(w, z), . . . , ML(w, z)) .

We can now compute the average per-label loss from FM (w, z) by deﬁning an appropriate
loss function fM .

A.1. PROOFOFTHEOREM5.5.1

191

Deﬁnition A.1.6 (Average per-label loss) The average per-label loss fM : IR L (cid:55)→ [0, 1] is
given by:

vd,
where in case ∀d, vd > 0, we deﬁne arg mind:vd≤0 vd ≡ 0.

arg min
d:vd≤0

fM (v) =

1
L

With the above deﬁnitions, we have an upper bound on the average per-label loss

(cid:96)H(cid:161)

(cid:162)

fM (FM (w, z)) =

1
L

arg min

d:Md(w,z)≤0

Md(w, z) ≥ 1
L

arg max

y

w(cid:62)fi(y)

.

Note that the case ∀d, Md(w, z) > 0 corresponds to the classiﬁer making no mistakes:
arg maxy w(cid:62)fi(y) = y. This upper bound is tight if y = arg maxy(cid:48) w(cid:62)f (x, y(cid:48)), Other-
wise, it is adversarial: it picks from all y(cid:48) which are better (w(cid:62)f (y) ≤ w(cid:62)f (y(cid:48))), one that
maximizes the Hamming distance from y.

We now need to deﬁne an appropriate metric ρ that in turn deﬁnes γ-margin loss for
structured classiﬁcation. Since the margin of the hypothesis grows with the number of
mistakes, our metric can become “looser” with the number of mistakes, as there is more
room for error.
Deﬁnition A.1.7 (Multi-error-level metric) Let the multi-error-level metric ρM : IRL ×
IRL (cid:55)→ IR for a vector in IR L be given by:

ρM (v, v(cid:48)) = max

d

|vd − v(cid:48)
d|

d

.

We now deﬁne the corresponding γ-margin loss using the new metric:

Deﬁnition A.1.8 (γ-margin average per-label loss) The γ-margin average per-label loss
M : IR L (cid:55)→ [0, 1] is given by:
f γ

f γ
M (v) =

sup

ρM (v,v(cid:48))≤2γ

fM (v(cid:48)).

Combining the two deﬁnitions, we get:

M (FM (w, z)) =
f γ

sup

v:|vd−Md(w,z)|≤2dγ

1
L

arg min
d:vd≤0

vd.

192

APPENDIXA. PROOFSANDDERIVATIONS

We also deﬁne the corresponding covering number for our vector-valued function class:
Deﬁnition A.1.9 (Multi-error-level covering number) Let V = {V(1), . . . , V(r)}, where
i ∈ IRL, be a covering of FM (w, S), with -
V(j) = (V(j)
precision under the metric ρM , if for all w there exists a V(j) such that for each data
sample z(i) ∈ S:

1 , . . . , V(j)

i

, . . . , V(j)

m ) and V(j)

ρM (V(j)
i

,FM (w, z(i))) ≤ .

The covering number of a sample S is the size of the smallest covering: N∞(FM , ρM , , S) =
inf |V| s.t. V is a covering of FM (w, S). We also deﬁne

N∞(FM , ρM , , m) = sup
S: |S|=m

N∞(FM , ρM , , S).

We provide a bound on the covering number of our new function class in terms of a
covering number for the linear function class. Recall that Nc is the maximum number of
cliques in G(x), Vc is the maximum number of values in a clique |Yc|, q is the maximum
number of cliques that have a variable in common, and Rc is an upper-bound on the 2-norm
of clique basis functions. Consider a ﬁrst-order sequence model as an example, with L as
the maximum length, and V the number of values a variable takes. Then Nc = 2L−1 since
we have L node cliques and L − 1 edge cliques; Vc = V 2 because of the edge cliques; and
q = 3 since nodes in the middle of the sequence participate in 3 cliques: previous-current
edge clique, node clique, and current-next edge clique.

Lemma A.1.10 (Bound on multi-error-level covering number)

N∞(FM , ρM , q, m) ≤ N∞(FL, ρL, , mNc(Vc − 1)).

Proof: We will show that N∞(FM , ρM , q, S) ≤ N∞(FL, ρL, , S(cid:48)) for any sample S
of size m, where we construct the sample S(cid:48) of size mNc(Vc − 1) in order to cover the
clique potentials as described below. Note that this is sufﬁcient since N∞(FL, ρL, , S(cid:48)) ≤
N∞(FL, ρL, , mNc(Vc − 1)), by deﬁnition, so

N∞(FM , ρM , q, m) = sup
S:|S|=m

N∞(FM , ρM , q, S) ≤ N∞(FL, ρL, , mNc(Vc − 1)).

A.1. PROOFOFTHEOREM5.5.1

193

The construction of S(cid:48) below is inspired by the proof technique in Collins [2001],
but the key difference is that our construction is linear in the number of cliques Nc and
exponential in the number of label variables per clique, while his is exponential in the total
number of label variables per example. This reduction in size comes about because our
covering approximates the values of clique potentials w(cid:62)∆fi,c(yc) for each clique c and
clique assignment yc as opposed to the values of entire assignments w(cid:62)∆fi(y).

For each sample z ∈ S, we create Nc(Vc − 1) samples ∆fi,c(yc), one for each clique
c . We construct a set of vectors V = {v(1), . . . , v(r)},
c and each assignment yc (cid:54)= y(i)
where v(j) ∈ IRmNc(Vc−1). The component of v(j) corresponding to the sample z(i) and the
assignment yc to the labels of the clique c will be denoted by v(j)
i,c (yc). For convenience,
we deﬁne v(j)
c ) = 0. To make V an
∞-norm covering of FL(w, S(cid:48)) under ρL, we require that for any w there exists a v(j) ∈ V
such that for each sample z(i):

c ) = 0 for correct label assignments, as ∆fi,c(y(i)

i,c (y(i)

|v(j)
i,c (yc) − w(cid:62)∆fi,c(yc)| ≤ ; ∀c ∈ C(i), ∀yc.

(A.1)

By Deﬁnition A.1.1, the number of vectors in V is given by r = N∞(FL, ρL, , mNc(Vc−1)).

We can now use V to construct a covering V = {V(1), . . . , V(r)}, where

V(j) = (V(j)

1 , . . . , V(j)

i

, . . . , V(j)
m )

and V(j)
Md(v(j)
i

i ∈ IRL, for our multi-error-level function FM . Let v(j)
, z(i)) = miny:(cid:96)H

i (y), then

i (y)=d v(j)

i (y) =

(cid:80)

c v(j)

i,c (yc), and

V(j)

i = (M1(v(j), z(i)), . . . , Md(v(j), z(i)), . . . , ML(v(j), z(i))) .

(A.2)

Note that v(j)

i,c (yc) is zero for all cliques c for which the assignment is correct: yc = y(i)
c .
i,c (yc) will be non-zero, as each

Thus for an assignment y with d mistakes, at most dq v(j)
label can appear in at most q cliques. By combining this fact with Eq. (A.1), we obtain:

i (y) − w(cid:62)∆fi(y)

∀i, ∀y : (cid:96)H

i (y) = d.

(A.3)

(cid:175)(cid:175)(cid:175)v(j)

(cid:175)(cid:175)(cid:175) ≤ dq,

194

APPENDIXA. PROOFSANDDERIVATIONS

We conclude the proof by showing that V is a covering of FM under ρM : For each w,
pick V(j) ∈ V such that the corresponding v(j) ∈ V satisﬁes the condition in Eq. (A.1). We
must now bound:

ρM (V(j)
i

,FM (w, z(i))) = max

d

| miny:(cid:96)H

i (y)=d v(j)

i (y) − miny:(cid:96)H

i (y)=d w(cid:62)∆fi(y)|

d

.

d = arg miny:(cid:96)H

Fix any i. Let yv
sider the case where v(j)
prove that:

i (y)=d v(j)
d ) ≥ w(cid:62)∆fi(yw

d = arg miny:(cid:96)H

i (y)=d w(cid:62)∆fi(y). Con-
d ) (the reverse case is analogous), we must

i (y) and yw

i (yv

v(j)
i (yv

d ) − w(cid:62)∆fi(yw

d ) ≤ v(j)

i (yw

d ) − w(cid:62)∆fi(yw

where the ﬁrst step follows from deﬁnition of yv
is a direct consequence of Eq. (A.3). Hence ρM (V(j)
i

d , since v(j)

d ) ≤ dq ;
d ) ≤ v(j)
i (yw
,FM (w, z(i))) ≤ q.

i (yv

(A.4)

d ). The last step

Lemma A.1.11 (Numeric bound on multi-error-level covering number)

log2 N∞(FM , ρM , , m) ≤ 36

c (cid:107)w(cid:107)2
R2
2

2 q2

Rc (cid:107)w(cid:107)2 q



+ 2

mNc(Vc − 1)

.

(cid:181)

(cid:187)

log2

1 + 2

4

(cid:188)

(cid:182)

(cid:184)

Proof: Substitute Theorem A.1.2 into Lemma A.1.10.

Theorem A.1.12 (Multi-label analog of Theorem A.1.3) Let fM and f γ
M (v) be as deﬁned
above. Let γ1 > γ2 > . . . be a decreasing sequence of parameters, and pi be a sequence
of positive numbers such that
i=1 pi = 1, then for all δ > 0, with probability of at least
1 − δ over data:

(cid:80)∞

(cid:115)

(cid:183)

EzfM (FM (w, z)) ≤ ESf γ

M (FM (w, z)) +

32
m

ln 4N∞(FM , ρM , γi, S) + ln

1
piδ

for all w and γ, where for each ﬁxed γ, we use i to denote the smallest index s.t. γi ≤ γ.
Proof: Similar to the proof of Zhang’s Theorem 2 and Corollary 1 [Zhang, 2002] where
in Step 3 (derandomization) we substitute the vector-valued FM and the metric ρM .
Theorem 5.5.1 follows from above theorem with γi = Rc (cid:107)w(cid:107)2 /2i and pi = 1/2i using an

A.2. AMNPROOFSANDDERIVATIONS

195

argument identical to the proof of Theorem 6 in Zhang [2002].

A.2 AMN proofs and derivations

In this appendix, we present proofs of the LP inference properties and derivations of the
factored primal and dual max-margin formulation from Ch. 7. Recall that the LP relaxation
for ﬁnding the optimal maxy g(y) is:

(cid:88)

K(cid:88)

(cid:88)

c∈C\V

K(cid:88)
K(cid:88)

k=1

max

s.t.

µv(k)gv(k) +

k=1

v∈V
µc(k) ≥ 0, ∀c ∈ C, k;
µc(k) ≤ µv(k),

k=1

∀c ∈ C \ V, v ∈ c, k.

µc(k)gc(k)

(A.5)

µv(k) = 1, ∀v ∈ V;

A.2.1 Binary AMNs

Proof (For Theorem 7.2.1) Consider any fractional, feasible µ. We show that we can con-
struct a new feasible assignment µ(cid:48) which increases the objective (or leaves it unchanged)
and furthermore has fewer fractional entries.

Since gc(k) ≥ 0, we can assume that µc(k) = minv∈c µv(k); otherwise we could in-
crease the objective by increasing µc(k). We construct an assignment µ(cid:48) from µ by leaving
integral values unchanged and uniformly shifting fractional values by λ:

v(1) = µv(1) − λ1I(0 < µv(1) < 1),
µ(cid:48)
c(1) = µc(1) − λ1I(0 < µc(1) < 1),
µ(cid:48)

µ(cid:48)
v(2) = µv(2) + λ1I(0 < µv(2) < 1),
µ(cid:48)
c(2) = µc(2) + λ1I(0 < µc(2) < 1).

Now consider the smallest fractional µv(k), λ(k) = minv : µv(k)>0 yv(k) for k = 1, 2.
Note that if λ = λ(1) or λ = −λ(2), µ(cid:48) will have at least one more integral µ(cid:48)
v(k) than µ.
Thus if we can show that the update results in a feasible and better scoring assignment, we
can apply it repeatedly to get an optimal integer solution. To show that µ(cid:48) is feasible, we
need µ(cid:48)

v(k) ≥ 0 and µ(cid:48)

c(k) = mini∈c µ(cid:48)

v(2) = 1, µ(cid:48)

v(1) + µ(cid:48)

v(k).

196

APPENDIXA. PROOFSANDDERIVATIONS

First, we show that µ(cid:48)

v(1) + µ(cid:48)

v(2) = 1.

µ(cid:48)
v(1) + µ(cid:48)

v(2) = µv(1) − λ1I(0 < µv(1) < 1) + µv(2) + λ1I(0 < µv(2) < 1)

= µv(1) + µv(2) = 1.

Above we used the fact that if µv(1) is fractional, so is µv(2), since µv(1) + µv(2) = 1.

To show that µ(cid:48)

v(k) ≥ 0, we prove minv µ(cid:48)

v(k) = 0.

µ(cid:48)
v(k) = min

v

min

v

µv(k) − ( min

i:µv(k)>0

µv(k))1I(0 < µv(k) < 1)

(cid:183)

µv(k) − min

i:µv(k)>0

µv(k)

= 0.

= min

min

i

µv(k), min

i:µv(k)>0

Lastly, we show µ(cid:48)

c(k) = mini∈c µ(cid:48)

v(k).

(cid:183)
(cid:181)

(cid:184)
(cid:184)(cid:182)

= (min
i∈c

c(1) = µc(1) − λ1I(0 < µc(1) < 1)
µ(cid:48)
µv(1)) − λ1I(0 < min
i∈c
µ(cid:48)
c(2) = µc(2) + λ1I(0 < µc(1) < 1)
µv(2)) + λ1I(0 < min
i∈c

= (min
i∈c

µv(1) < 1) = min
i∈c

µv(2) < 1) = min
i∈c

µ(cid:48)
v(1);

µ(cid:48)
v(2).

We have established that the new µ(cid:48) are feasible, and it remains to show that we can
improve the objective. We can show that the change in the objective is always λD for some
constant D that depends only on µ and g. This implies that one of the two cases, λ = λ(1)
or λ = −λ(2), will necessarily increase the objective (or leave it unchanged). The change

(cid:88)
in the objective is:(cid:88)
(cid:88)

v∈V

k=1,2

(cid:88)
v(k) − µv(k)]gv(k) +
[µ(cid:48)
(cid:88)

[Dv(1) − Dv(2)] +

c∈C\V

= λ

(cid:88)

k=1,2

v∈V

c∈C\V

c(k) − µc(k)]gc(k)
[µ(cid:48)

 = λD

[Dc(1) − Dc(2)]

Dv(k) = gv(k)1I(0 < µv(k) < 1), Dc(k) = gc(k)1I(0 < µc(k) < 1).

Hence the new assignment µ(cid:48) is feasible, does not decrease the objective function, and

A.2. AMNPROOFSANDDERIVATIONS

197

has strictly fewer fractional entries.

A.2.2 Multi-class AMNs

For K > 2, we use the randomized rounding procedure of Kleinberg and Tardos [1999]
to produce an integer solution for the linear relaxation, losing at most a factor of m =
maxc∈C |c| in the objective function. The basic idea of the rounding procedure is to treat
µv(k) as probabilities and assign labels according to these probabilities in phases. In each
phase, we pick a label k, uniformly at random, and a threshold α ∈ [0, 1] uniformly at
random. For each node i which has not yet been assigned a label, we assign the label k
if µv(k) ≥ α. The procedure terminates when all nodes have been assigned a label. Our
analysis closely follows that of Kleinberg and Tardos [1999].

Lemma A.2.1 The probability that a node i is assigned label k by the randomized proce-
dure is µv(k).

Proof The probability that an unassigned node is assigned label k during one phase is
1
K µv(k), which is proportional to µv(k). By symmetry, the probability that a node is as-
signed label k over all phases is exactly µv(k).

Lemma A.2.2 The probability that all nodes in a clique c are assigned label k by the
procedure is at least 1|c| µc(k).

(cid:80)K

k=1 maxi∈c µv(k).

K mini∈c µv(k) = 1

Proof For a single phase, the probability that all nodes in a clique c are assigned label k if
none of the nodes were previously assigned is 1
K µc(k). The probability
that at least one of the nodes will be assigned label k in a phase is 1
K (maxi∈c µv(k)). The
probability that none of the nodes in the clique will be assigned any label in one phase is
1 − 1

K
Nodes in the clique c will be assigned label k by the procedure if they are assigned label
k in one phase. (They can also be assigned label k as a result of several phases, but we can
ignore this possibility for the purposes of the lower bound.) The probability that all the

198

APPENDIXA. PROOFSANDDERIVATIONS

nodes in c will be assigned label k by the procedure in a single phase is:

∞(cid:88)

j=1

(cid:195)
(cid:80)

µc(k)

1
K
≥

(cid:80)K

1 − 1
K

µc(k)

K(cid:88)

k=1

max
i∈c

(cid:80)

=

µv(k)

=

(cid:33)j−1
(cid:80)K
(cid:80)∞

µc(k)

k=1

i∈c µv(k)

i∈c

k=1 µv(k)

(cid:80)K

µc(k)

k=1 maxi∈c µv(k)
µc(k)
|c|

.

=

Above, we ﬁrst used the fact that for d < 1,

i=0 di = 1

1−d, and then upper-bounded

the max of the set of positive µv(k)’s by their sum.

(cid:80)

(cid:80)K

Theorem A.2.3 The expected cost of the assignment found by the randomized procedure
given a solution µ to the linear program in Eq. (A.5) is at least
k=1 gv(k)µv(k) +

v∈V

(cid:80)

(cid:80)K

c∈C\V 1|c|

k=1 gc(k)µk
c .

Proof This is immediate from the previous two lemmas.

The only difference between the expected cost of the rounded solution and the (non-
integer) optimal solution is the 1|c| factor in the second term. By picking m = maxc∈C |c|, we
have that the rounded solution is at most m times worse than the optimal solution produced
by the LP of Eq. (A.5).

We can also derandomize this procedure to get a deterministic algorithm with the same
guarantees, using the method of conditional probabilities, similar in spirit to the approach
of Kleinberg and Tardos [1999].

Note that the approximation factor of m applies, in fact, only to the clique poten-
tials. Thus, if we compare the log-probability of the optimal MAP solution and the log-
probability of the assignment produced by this randomized rounding procedure, the terms
corresponding to the log-partition-function and the node potentials are identical. We obtain
an additive error (in log-probability space) only for the clique potentials. As node poten-
tials are often larger in magnitude than clique potentials, the fact that we incur no loss
proportional to node potentials is likely to lead to smaller errors in practice. Along similar
lines, we note that the constant factor approximation is smaller for smaller cliques; again,
we observe, the potentials associated with large cliques are typically smaller in magnitude,
reducing further the actual error in practice.

A.2. AMNPROOFSANDDERIVATIONS

199

A.2.3 Derivation of the factored primal and dual max-margin QP

Using Assumptions 7.4.1 and 7.4.4, we have the dual of the LP used to represent the
interior max subproblem maxy w(cid:62)fi(y) + (cid:96)i(y) in Eq. (3.2):

(cid:88)

v∈V

min

ξi,v

s.t. −w(cid:62)fi,v(k) −
− ¨w(cid:62)¨fi,c(k) +
mi,c,v(k) ≥ 0,

mi,c,v(k) ≥ (cid:96)i,v(k) − ξi,v,
mi,c,v(k) ≥ (cid:96)i,c(k),
∀i, c ∈ C(i) \ V (i), v ∈ c, k;

(A.6)

∀i, v ∈ V (i), k;

∀i, c ∈ C(i) \ V (i), k;

where fi,c(k) = fi,c(k, . . . , k) and (cid:96)i,c(k) = (cid:96)i,c(k, . . . , k). In the dual, we have a variable
ξi,v for each normalization constraint in Eq. (7.1) and variables mi,c,v(k) for each of the
inequality constraints.

(cid:88)
(cid:88)

c⊃v

v∈c

(cid:88)
(cid:88)
(cid:88)

c⊃v

v∈c

Substituting this dual into Eq. (5.1), we obtain:

1
2

||w||2 + C

min
ξi
s.t. w(cid:62)fi(y(i)) + ξi ≥

i

(cid:88)

(A.7)

∀i, v ∈ V (i), k;

∀i, c ∈ C(i) \ V (i), k;

ξi,v,

∀i;

v∈V (i)
mi,c,v(k) ≥ (cid:96)i,v(k) − ξi,v,
mi,c,v(k) ≥ (cid:96)i,c(k),
∀i, c ∈ C(i) \ V (i), v ∈ c, k;

−w(cid:62)fi,v(k) −
− ¨w(cid:62)¨fi,c(k) +
mi,c,v(k) ≥ 0,
¨w ≥ 0.

(cid:80)

Now let ξi,v = ξ(cid:48)

i,v + w(cid:62)fi,v(y(i)

v ) +

c⊃v ¨w(cid:62)¨fi,c(y(i)

c )/|c| and mi,c,v(k) = m(cid:48)

i,c,v(k) +

¨w(cid:62)¨fi,c(y(i)

c )/|c|. Re-expressing the above QP in terms of these new variables, we get:

200

APPENDIXA. PROOFSANDDERIVATIONS

min

s.t.

(cid:88)

||w||2 + C
1
2
ξi ≥

i
ξ(cid:48)
i,v,
w(cid:62)∆fi,v(k) −

v∈V (i)

ξi
∀i;

(cid:88)
(cid:88)
(cid:88)

c⊃v

¨w(cid:62)∆¨fi,c(k) +
i,c,v(k) ≥ − ¨w(cid:62)¨fi,c(y(i)
m(cid:48)
¨w ≥ 0.

v∈c

∀i, v ∈ V (i), k;

i,c,v(k) ≥ (cid:96)i,v(k) − ξ(cid:48)
m(cid:48)
i,v,
∀i, c ∈ C(i) \ V (i), k;
i,c,v(k) ≥ (cid:96)i,c(k),
m(cid:48)
∀i, c ∈ C(i) \ V (i), v ∈ c, k;
c )/|c|,

(A.8)

(cid:80)

Since ξi =

i,v∈V (i) ξ(cid:48)

min

||w||2 + C

1
2

s.t. w(cid:62)∆fi,v(k) −

(cid:88)
(cid:88)
(cid:88)

c⊃v

i,v∈V (i)

of constraints to get the formulation in Eq. (7.4), repeated here for reference:

i,v at the optimum, we can eliminate ξi and the corresponding set

ξi,v

(A.9)

mi,c,v(k) ≥ (cid:96)i,v(k) − ξi,v,
mi,c,v(k) ≥ (cid:96)i,c(k),

∀i, v ∈ V (i), k;

∀i, c ∈ C(i) \ V (i), k;
∀i, c ∈ C(i) \ V (i), v ∈ c, k;

¨w(cid:62)∆¨fi,c(k) +
mi,c,v(k) ≥ − ¨w(cid:62)¨fi,c(y(i)
¨w ≥ 0.

v∈c

c )/|c|,

A.2. AMNPROOFSANDDERIVATIONS

201

(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)

(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)2

(cid:88)

i,c∈C(i), k

(A.10)

(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)2
(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)

λi,c,v(k)¨fi,c(y(i)

c )/|c| +

µi,c(k)∆¨fi,c(k)

(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)

(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)

(cid:88)
(cid:88)

Now the dual of Eq. (A.9) is given by:

(cid:88)

i,c∈C(i), k

i,v∈V (i), k

µi,v(k)∆˙fi,v

µi,c(k)(cid:96)i,c(k) − 1
2

(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)¨τ +
(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)

−1
2

i,c∈C(i)\V (i),v∈c, k

K(cid:88)

max

s.t.

µi,c(k) ≥ 0, ∀i, ∀c ∈ C(i), k;
µi,c(k) − µi,v(k) = λi,c,v(k),
λi,c,v(k) ≥ 0
¨τ ≥ 0.

∀i, ∀c ∈ C(i) \ V (i), v ∈ c, k,

µi,v(k) = C, ∀i, ∀v ∈ V (i);

k=1

∀i, ∀c ∈ C(i) \ V (i), v ∈ c, k;

In this dual, µ correspond to the ﬁrst two sets of constraints, while λ and ¨τ correspond

to third and fourth set of constraints. Using the substitution

(cid:88)

¨ν = ¨τ +

i,c∈C(i)\V (i),v∈c, k

λi,c,v(k)¨fi,c(y(i)

c )/|c|

and the fact that λi,c,v(k) ≥ 0 and ¨fi,c(y(i)
µ’s by C, and re-express the above QP as:

c ) ≥ 0, we can eliminate λ and ¨τ , as well as divide

(cid:88)

(cid:88)

(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)
(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)

(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)

(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)2

(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)
(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)¨ν +

(cid:88)

µi,v(k)∆˙fi,v

− 1
2

C

i,v∈V (i), k

i,c∈C(i), k
µi,v(k) = 1, ∀i, ∀v ∈ V (i);

K(cid:88)

k=1

∀i, ∀c ∈ C(i) \ V (i), v ∈ c, k;

¨ν ≥ 0.

max

s.t.

µi,c(k)(cid:96)i,c(k) − 1
2

C

i,c∈C(i), k
µi,c(k) ≥ 0, ∀i, ∀c ∈ C(i), k;
µi,c(k) ≤ µi,v(k),

(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)

(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)(cid:175)2

µi,c(k)∆¨fi,c(k)

Bibliography

Abbeel, P., & Ng, A. Y. (2004). Apprenticeship learning via inverse reinforcement learning.

Proc. ICML.

Ahuja, R., & Orlin, J. (2001). Inverse optimization, Part I: Linear programming and general

problem. Operations Research, 35, 771–783.

Altschul, S., Madden, T., Schaffer, A., Zhang, A., Miller, W., & Lipman (1997). Gapped
BLAST and PSI-BLAST: a new generation of protein database search programs. Nucleid
Acids Res., 25, 3389–3402.

Altun, Y., Smola, A., & Hofmann, T. (2004). Exponential families for conditional random

ﬁelds. Proc. UAI.

Altun, Y., Tsochantaridis, I., & Hofmann, T. (2003). Hidden markov support vector ma-

chines. Proc. ICML.

Bach, F., & Jordan, M. (2001). Thin junction trees. NIPS.

Bach, F., & Jordan, M. (2003). Learning spectral clustering. NIPS.

Baeza-Yates, R., & Ribeiro-Neto, B. (1999). Modern information retrieval. Addison-

Wesley-Longman.

Bairoch, A., & Apweiler, R. (2000). The Swiss-Prot protein sequence database and its

supplement trembl. Nucleic Acids Res., 28, 45–48.

Baldi, P., Cheng, J., & Vullo, A. (2004). Large-scale prediction of disulphide bond connec-

tivity. Proc. NIPS.

202

BIBLIOGRAPHY

203

Baldi, P., & Pollastri, G. (2003). The principled design of large-scale recursive neural
network architectures dag-rnns and the protein structure prediction problem. Journal of
Machine Learning Research, 4, 575–602.

Bansal, N., Blum, A., & Chawla, S. (2002). Correlation clustering. FOCS.

Bar-Hillel, A., Hertz, T., Shental, N., & Weinshall, D. (2003). Learning distance functions

using equivalence relations. Proc. ICML.

Bartlett, P., Collins, M., Taskar, B., & McAllester, D. (2004). Exponentiated gradient

algorithms for large-margin structured classiﬁcation. NIPS.

Bartlett, P. L., Jordan, M. I., & McAuliffe, J. D. (2003). Convexity, classiﬁcation, and risk

bounds (Technical Report 638). Department of Statistics, U.C. Berkeley.

Belongie, S., Malik, J., & Puzicha, J. (2002). Shape matching and object recognition using

shape contexts. IEEE Trans. Pattern Anal. Mach. Intell., 24.

Berman, H., Westbrook, J., Feng, Z., Gilliland, G., Bhat, T., Weissig, H., Shindyalov, I., &

Bourne, P. (2000). The protein data bank.

Bertsekas, D. (1999). Nonlinear programming. Belmont, MA: Athena Scientiﬁc.

Bertsimas, D., & Tsitsiklis, J. (1997). Introduction to linear programming. Athena Scien-

tiﬁc.

Besag, J. E. (1986). On the statistical analysis of dirty pictures. Journal of the Royal

Statistical Society B, 48.

Bishop, C. (1995). Neural networks for pattern recognition. Oxford, UK: Oxford Univer-

sity Press.

Blum, A., & Mitchell, T. (1998). Combining labeled and unlabeled data with co-training.

Proc. COLT.

Bouman, C., & Shapiro, M. (1994). A multiscale random ﬁeld model for bayesian image

segmentation. IP, 3(2).

204

BIBLIOGRAPHY

Boyd, S., & Vandenberghe, L. (2004). Convex optimization. Cambridge University Press.

Boykov, Y., & Kolmogorov, V. (2004). An experimental comparison of min-cut/max-ﬂow

algorithms for energy minimization in computer vision. PAMI.

Boykov, Y., Veksler, O., & Zabih, R. (1999a). Fast approximate energy minimization via

graph cuts. ICCV.

Boykov, Y., Veksler, O., & Zabih, R. (1999b). Markov random ﬁelds with efﬁcient approx-

imations. CVPR.

Burton, D., & Toint, P. L. (1992). On an instance of the inverse shortest paths problem.

Mathematical Programming, 53, 45–61.

Ceroni, A., Frasconi, P., Passerini, A., & Vullo, A. (2003). Predicting the disulﬁde bond-
ing state of cysteines with combinations of kernel machines. Journal of VLSI Signal
Processing, 35, 287–295.

Chakrabarti, S., Dom, B., & Indyk, P. (1998). Enhanced hypertext categorization using

hyperlinks. SIGMOD.

Chapelle, O., Weston, J., & Schoelkopf, B. (2002). Cluster kernels for semi-supervised

learning. Proc. NIPS.

Charikar, M., Guruswami, V., & Wirth, A. (2003). Clustering with qualitative information.

FOCS.

Charniak, E. (1993). Statistical language learning. MIT Press.

Clark, S., & Curran, J. R. (2004). Parsing the wsj using ccg and log-linear models. Pro-
ceedings of the 42nd Annual Meeting of the Association for Computational Linguistics
(ACL ’04).

Collins, M. (1999). Head-driven statistical models for natural language parsing. Doctoral

dissertation, University of Pennsylvania.

BIBLIOGRAPHY

205

Collins, M. (2000). Discriminative reranking for natural language parsing. ICML 17 (pp.

175–182).

Collins, M. (2001). Parameter estimation for statistical parsing models: Theory and prac-

tice of distribution-free methods. IWPT.

Collins, M. (2004). Parameter estimation for statistical parsing models: Theory and prac-
tice of distribution-free methods. In H. Bunt, J. Carroll and G. Satta (Eds.), New devel-
opments in parsing technology. Kluwer.

Corduneanu, A., & Jaakkola, T. (2003). On information regularization. Proc. UAI.

Cormen, T., Leiserson, C., Rivest, R., & Stein, C. (2001). Introduction to algorithms. MIT

Press. 2nd edition.

Cover, T. M., & Thomas, J. A. (1991). Elements of information theory. New York: Wiley.

Cowell, R., Dawid, A., Lauritzen, S., & Spiegelhalter, D. (1999). Probabilistic networks

and expert systems. New York: Springer.

Crammer, K., & Singer, Y. (2001). On the algorithmic implementation of multiclass kernel-

based vector machines. Journal of Machine Learning Research, 2(5), 265–292.

Craven, M., DiPasquo, D., Freitag, D., McCallum, A., Mitchell, T., Nigam, K., & Slattery,
S. (1998). Learning to extract symbolic knowledge from the world wide web. Proc
AAAI98 (pp. 509–516).

Cristianini, N., & Shawe-Taylor, J. (2000). An introduction to support vector machines and

other kernel-based learning methods. Cambridge University Press.

DeGroot, M. H. (1970). Optimal statistical decisions. New York: McGraw-Hill.

Della Pietra, S., Della Pietra, V., & Lafferty, J. (1997). Inducing features of random ﬁelds.

IEEE Trans. on Pattern Analysis and Machine Intelligence, 19(4), 380–393.

Demaine, E. D., & Immorlica, N. (2003). Correlation clustering with partial information.

APPROX.

206

BIBLIOGRAPHY

Dempster, P., Laird, N. M., & Rubin, D. B. (1977). Maximum likelihood from incomplete

data via the EM algorithm. Journal of the Royal Statistical Society, 39.

Devroye, L., Gy¨orﬁ, L., & Lugosi, G. (1996). Probabilistic theory of pattern recognition.

New York: Springer-Verlag.

Duda, R. O., Hart, P. E., & Stork, D. G. (2000). Pattern classiﬁcation. New York: Wiley

Interscience. 2nd edition.

Durbin, R., Eddy, S., Krogh, A., & Mitchison, G. (1998). Biological sequence analysis.

Cambridge University Press.

Edmonds, J. (1965). Maximum matching and a polyhedron with 0-1 vertices. Journal of

Research at the National Bureau of Standards, 69B, 125–130.

Egghe, L., & Rousseau, R. (1990). Introduction to informetrics. Elsevier.

Emanuel, D., & Fiat, A. (2003). Correlation clustering - minimizing disagreements on

arbitrary weighted graphs. ESA.

Fariselli, P., & Casadio, R. (2001). Prediction of disulﬁde connectivity in proteins. Bioin-

formatics, 17, 957–964.

Fariselli, P., Martelli, P., & Casadio, R. (2002). A neural network-based method for pre-
dicting the disulﬁde connectivity in proteins. Knowledge based intelligent information
engineering systems and allied technologies (KES 2002), 1, 464–468.

Fariselli, P., Ricobelli, P., & Casadio, R. (1999). Role of evolutionary information in pre-

dicting the disulﬁde-bonding state of cysteine in proteins. Proteins, 36, 340–346.

Fiser, A., & Simon, I. (2000). Predicting the oxidation state of cysteines by multiple se-

quence alignment. Bionformatics, 3, 251–256.

Forsyth, D. A., & Ponce, J. (2002). Computer vision: A modern approach. Prentice Hall.

Frasconi, P., Gori, M., & Sperduti, A. (1998). A general framework for adaptive structures.

IEEE Transactions on Neural Networks.

BIBLIOGRAPHY

207

Frasconi, P., Passerini, A., & Vullo, A. (2002). A two stage svm architecture for predicting
the disulﬁde bonding state of cysteines. Proceedings of IEEE Neural Network for signal
processing conference.

Freund, Y., & Schapire, R. (1998). Large margin classiﬁcation using the perceptron algo-

rithm. Computational Learing Theory.

Friedman, N., Getoor, L., Koller, D., & Pfeffer, A. (1999). Learning probabilistic relational

models. Proc. IJCAI99 (pp. 1300–1309). Stockholm, Sweden.

Friess, T., Cristianini, N., & Campbell, C. (1998). The kernel adatron algorithm: a fast and

simple learning procedure for support vector machine. Proc. ICML.

Gabow, H. (1973). Implementation of algorithms for maximum matching on nonbipartite

graphs. Doctoral dissertation, Stanford University.

Garey, M. R., & Johnson, D. S. (1979). Computers and intractability. Freeman.

Geman, S., & Johnson, M. (2002). Dynamic programming for parsing and estimation of
stochastic uniﬁcation-based grammars. Proceedings of the 40th Annual Meeting of the
Association for Computational Linguistics.

Getoor, L., Friedman, N., Koller, D., & Taskar, B. (2002). Learning probabilistic models

of link structure. Journal of Machine Learning Research, 8.

Getoor, L., Segal, E., Taskar, B., & Koller, D. (2001). Probabilistic models of text and link
structure for hypertext classiﬁcation. Proc. IJCAI01 Workshop on Text Learning: Beyond
Supervision. Seattle, Wash.

Greig, D. M., Porteous, B. T., & Seheult, A. H. (1989). Exact maximum a posteriori

estimation for binar images. J. R. Statist. Soc. B, 51.

Guestrin, C., Koller, D., Parr, R., & Venkataraman, S. (2003). Efﬁcient solution algorithms

for factored mdps. Journal of Artiﬁcial Intelligence Research, 19.

Gusﬁeld, D. (1997). Algorithms on strings, trees, and sequences : Computer science and

computational biology. Cambridge University Press.

208

BIBLIOGRAPHY

Harrison, P., & Sternberg, M. (1994). Analysis and classiﬁcation of disulphide connectivity

in proteins. the entropic effect of cross-linkage. Journal of Molecular Biology, 244.

Hastie, T., Tibshirani, R., & Friedman, J. (2001). The elements of statistical learning. New

York: Springer-Verlag.

Haussler, D. (1999). Convolution kernels on discrete structures (Technical Report). UC

Santa Cruz.

Heuberger, C. (2004). Inverse combinatorial optimization: A survey on problems, methods,

and results. Journal of Combinatorial Optimization, 8.

Hochbaum, D. S. (Ed.). (1997). Approximation algorithms for NP-hard problems. PWS

Publishing Company.

Joachims, T. (1999). Transductive inference for text classiﬁcation using support vector
machines. Proc. ICML99 (pp. 200–209). Morgan Kaufmann Publishers, San Francisco,
US.

Johnson, M. (2001). Joint and conditional estimation of tagging and parsing models. ACL

39.

Johnson, M., Geman, S., Canon, S., Chi, Z., & Riezler, S. (1999). Estimators for stochastic

“uniﬁcation-based” grammars. Proceedings of ACL 1999.

Kabsch, W., & Sander, C. (1983). Dictionary of protein secondary structure: Pattern recog-

nition of hydrogen-bonded and geometrical features.

Kaplan, R., Riezler, S., King, T., Maxwell, J., Vasserman, A., & Crouch, R. (2004). Speed

and accuracy in shallow and deep stochastic parsing. Proceedings of HLT-NAACL’04.

Kassel, R. (1995). A comparison of approaches to on-line handwritten character recogni-

tion. Doctoral dissertation, MIT Spoken Language Systems Group.

Kivinen, J., & Warmuth, M. (1997). Exponentiated gradient versus gradient descent for

linear predictors. Information and Computation, 132(1), 1–63.

BIBLIOGRAPHY

209

Klein, D., & Manning, C. D. (2003). Accurate unlexicalized parsing. ACL 41 (pp. 423–

430).

Kleinberg, J., & Tardos, E. (1999). Approximation algorithms for classiﬁcation problems

with pairwise relationships: Metric labeling and Markov random ﬁelds. FOCS.

Kleinberg, J. M. (1999). Authoritative sources in a hyperlinked environment. Journal of

the ACM, 46(5), 604–632.

Klepeis, J., & Floudas, C. (2003). Prediction of β-sheet topology and disulﬁde bridges in

polypeptides. Journal of Computational Chemistry, 24, 191–208.

Koller, D., & Pfeffer, A. (1998). Probabilistic frame-based systems. Proc. AAAI98 (pp.

580–587). Madison, Wisc.

Kolmogorov, V., & Zabih, R. (2002). What energy functions can be minimized using graph

cuts? PAMI.

Kumar, S., & Hebert, M. (2003). Discriminative ﬁelds for modeling spatial dependencies

in natural images. NIPS.

Lafferty, J., McCallum, A., & Pereira, F. (2001). Conditional random ﬁelds: Probabilistic

models for segmenting and labeling sequence data. ICML.

Lafferty, J., Zhu, X., & Liu, Y. (2004). Kernel conditional random ﬁelds: Representation

and clique selection. ICML.

Lawler, E. (1976). Combinatorial optimization: Networks and matroids. New York: Holt,

Rinehart and Winston.

Leslie, C., Eskin, E., & Noble, W. (2002). The spectrum kernel: a string kernel for svm

protein classiﬁcation. Proc. Paciﬁc Symposium on Biocomputing.

Liu, Z., & Zhang, J. (2003). On inverse problems of optimum perfect matching. Journal

of Combinatorial Optimization, 7.

210

BIBLIOGRAPHY

Lodhi, H., Shawe-Taylor, J., Cristianini, N., & Watkins, C. (2000). Text classiﬁcation using

string kernels. NIPS.

Luenberger, D. (1997). Investment science. Oxford University Press.

Manning, C., & Sch¨utze, H. (1999). Foundations of statistical natural language processing.

Cambridge, Massachusetts: The MIT Press.

Marcus, M. P., Santorini, B., & Marcinkiewicz, M. A. (1993). Building a large annotated

corpus of English: The Penn Treebank. Computational Linguistics, 19(2), 313–330.

Markowitz, H. (1991). Portfolio selection: Efﬁcient diversiﬁcation of investments. Basil

Blackwell.

Martelli, P., Fariselli, P., Malaguti, L., & Casadio, R. (2002). Prediction of the disulﬁde-

bonding state of cysteines in proteins at 88% accuracy. Protein Science, 11, 27359.

Martin, D., Fowlkes, C., Tal, D., & Malik, J. (2001). A database of human segmented
natural images and its application to evaluating segmentation algorithms and measuring
ecological statistics. Proc. ICCV.

Matsumura, M., Signor, G., & Matthews, B. (1989). Substantial increase of protein stability

by multiple disulﬁde bonds. Nature, 342, 291:293.

Matusov, E., Zens, R., & Ney, H. (2004). Symmetric word alignments for statistical ma-

chine translation. Proc. COLING.

McCallum, A. (2003). Efﬁciently inducing features of conditional random ﬁelds. Proc.

UAI.

McCallum, A., & Wellner, B. (2003). Toward conditional models of identity uncertainty
with application to proper noun coreference. IJCAI Workshop on Information Integration
on the Web.

Mitchell, T. (1997). Machine learning. McGraw-Hill.

BIBLIOGRAPHY

211

Miyao, Y., & Tsujii, J. (2002). Maximum entropy estimation for feature forests. Proceed-

ings of Human Language Technology Conference (HLT 2002).

Murphy, K. P., Weiss, Y., & Jordan, M. I. (1999). Loopy belief propagation for approximate

inference: an empirical study. Proc. UAI99 (pp. 467–475).

Needleman, S., & Wunsch, C. (1970). A general method applicable to the search for
similarities in the amino acid sequences of two proteins. Journal of Molecular Biology,
48.

Nemhauser, G. L., & Wolsey, L. A. (1999). Integer and combinatorial optimization. New

York: J. Wiley.

Neville, J., & Jensen, D. (2000). Iterative classiﬁcation in relational data. Proc. AAAI-2000

Workshop on Learning Statistical Models from Relational Data (pp. 13–20).

Ng, A., & Jordan, M. (2001). On discriminative vs. generative classiﬁers: A comparison

of logistic regression and naive Bayes. NIPS.

Ng, A. Y., & Russell, S. (2000). Algorithms for inverse reinforcement learning. Proc.

ICML.

Nigam, K., McCallum, A., Thrun, S., & Mitchell, T. (2000). Text classiﬁcation from

labeled and unlabeled documents using em. Machine Learning, 39.

Nocedal, J., & Wright, S. J. (1999). Numerical optimization. New York: Springer.

Papadimitriou, C., & Steiglitz, K. (1982). Combinatorial optimization: Algorithms and

complexity. Englewood Cliffs, NJ: Prentice-Hall.

Pearl, J. (1988). Probabilistic reasoning in intelligent systems. San Francisco: Morgan

Kaufmann.

Pinto, D., McCallum, A., Wei, X., & Croft, W. B. (2003). Table extraction using conditional

random ﬁelds. Proc. ACM SIGIR.

212

BIBLIOGRAPHY

Platt, J. (1999). Using sparseness and analytic QP to speed training of support vector

machines. NIPS.

Potts, R. B. (1952). Some generalized order-disorder transformations. Proc. Cambridge

Phil. Soc., 48.

Quinlan, J. R. (2001). Induction of decision trees. Machine Learning, 1, 81–106.

Schrijver, A. (2003). Combinatorial optimization: Polyhedra and efﬁciency. Springer.

Sha, F., & Pereira, F. (2003). Shallow parsing with conditional random ﬁelds. Proc. HLT-

NAACL.

Shawe-Taylor, J., Bartlett, P. L., Williamson, R. C., & Anthony, M. (1998). Structural
risk minimization over data-dependent hierarchies. IEEE Trans. on Information Theory,
44(5), 1926–1940.

Shen, L., Sarkar, A., & Joshi, A. K. (2003). Using ltag based features in parse reranking.

Proc. EMNLP.

Slattery, S., & Mitchell, T. (2000). Discovering test set regularities in relational domains.

Proc. ICML00 (pp. 895–902).

Smith, T., & Waterman, M. (1981). Identiﬁcation of common molecular subsequences. J.

Mol. Biol., 147, 195–197.

Sutton, C., Rohanimanesh, K., & McCallum, A. (2004). Dynamic conditional random
ﬁelds: Factorized probabilistic models for labeling and segmenting sequence data. Proc.
ICML.

Szummer, M., & Jaakkola, T. (2001). Partially labeled classiﬁcation with Markov random

walks. Proc. NIPS.

Tarantola, A. (1987). Inverse problem theory: Methods for data ﬁtting and model parame-

ter estimation. Amsterdam: Elsevier.

BIBLIOGRAPHY

213

Taskar, B., Abbeel, P., & Koller, D. (2002). Discriminative probabilistic models for rela-

tional data. UAI.

Taskar, B., Chatalbashev, V., & Koller, D. (2004a). Learning associative Markov networks.

Proc. ICML.

Taskar, B., Guestrin, C., & Koller, D. (2003a). Max margin Markov networks. NIPS.

Taskar, B., Klein, D., Collins, M., Koller, D., & Manning, C. (2004b). Max margin parsing.

EMNLP.

Taskar, B., Segal, E., & Koller, D. (2001). Probabilistic classiﬁcation and clustering in

relational data. Proc. IJCAI01 (pp. 870–876). Seattle, Wash.

Taskar, B., Wong, M., Abbeel, P., & Koller, D. (2003b). Link prediction in relational data.

Proc. NIPS.

Toutanova, K., Klein, D., Manning, C. D., & Singer, Y. (2003). Feature-rich part-of-speech

tagging with a cyclic dependency network. NAACL 3 (pp. 252–259).

Tsochantaridis, I., Hofmann, T., Joachims, T., & Altun, Y. (2004). Support vector machine
learning for interdependent and structured output spaces. Twenty-ﬁrst international con-
ference on Machine learning.

Valiant, L. G. (1979). The complexity of computing the permanent. Theoretical Computer

Science, 8, 189–201.

Vapnik, V. (1995). The nature of statistical learning theory. New York, New York:

Springer-Verlag.

Varma, A., & Palsson, B. (1994). Metabolic ﬂux balancing: Basic concepts, scientiﬁc and

practical use. Bio/Technology, 12.

Vazquez, A., Flammini, A., Maritan, A., & Vespignani, A. (2003). Global protein function

prediction from protein-protein interaction networksh. Nature Biotechnology, 6.

214

BIBLIOGRAPHY

Veksler, O. (1999). Efﬁcient graph-based energy minimization methods in computer vision.

Doctoral dissertation, Cornell University.

Vullo, A., & Frasconi, P. (2004). Disulﬁde connectivity prediction using recursive neural

networks and evolutionary information. Bioinformatics, 20, 653–659.

Wahba, G., Gu, C., Wang, Y., & Chappell, R. (1993). Soft classiﬁcation, a.k.a. risk estima-
tion, via penalized log likelihood and smoothing spline analysis of variance. Computa-
tional Learning Theory and Natural Learning Systems.

Wainwright, M., Jaakkola, T., & Willsky, A. (2002). Map estimation via agreement on
(hyper)trees: Message-passing and linear programming approaches. Proc. Allerton Con-
ference on Communication, Control and Computing.

Wainwright, M., & Jordan, M. I. (2003). Variational inference in graphical models: The
view from the marginal polytope. Proc. Allerton Conference on Communication, Control
and Computing.

Weston, J., & Watkins, C. (1998). Multi-class support vector machines (Technical Re-
port CSD-TR-98-04). Department of Computer Science, Royal Holloway, University of
London.

Xing, E., Ng, A., Jordan, M., & Russell, S. (2002). Distance metric learning, with applica-

tion to clustering with side-information. NIPS.

Yang, Y., Slattery, S., & Ghani, R. (2002). A study of approaches to hypertext categoriza-

tion. Journal of Intelligent Information Systems, 18(2).

Yedidia, J., Freeman, W., & Weiss, Y. (2000). Generalized belief propagation. NIPS.

Younger, D. H. (1967). Recognition and parsing of context-free languages in time n3.

Information and Control, 10, 189–208.

Zhang, J., & Ma, Z. (1996). A network ﬂow method for solving inverse combinatorial

optimization problems. Optimization, 37, 59–72.

BIBLIOGRAPHY

215

Zhang, T. (2002). Covering number bounds of certain regularized linear function classes.

Journal of Machine Learning Research, 2, 527–550.

Zhu, J., & Hastie, T. (2001). Kernel logistic regression and the import vector machine.

Proc. NIPS.

Zhu, X., Ghahramani, Z., & Lafferty, J. (2003). Semi-supervised learning using gaussian

ﬁelds and harmonic functions. Proc. ICML.

