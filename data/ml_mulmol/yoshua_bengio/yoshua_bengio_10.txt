we explore an original strategy for building deep networks , based on stacking layers of denoising autoencoders which are trained locally to denoise corrupted versions of their inputs .
the resulting algorithm is a straightforward variation on the stacking of ordinary autoencoders .
it is however shown on a benchmark of classication problems to yield signicantly lower classication error , thus bridging the performance gap with deep belief networks ( dbn ) , and in several cases surpass - ing it .
higher level representations learnt in this purely unsupervised fashion also help boost the performance of subsequent svm classiers .
qualitative experiments show that , contrary to ordi - nary autoencoders , denoising autoencoders are able to learn gabor - like edge detectors from natural image patches and larger stroke detectors from digit images .
this work clearly establishes the value of using a denoising criterion as a tractable unsupervised objective to guide the learning of useful higher level representations .
deep learning , unsupervised feature learning , deep belief networks , autoencoders ,
it has been a long held belief in the eld of neural network research that the composition of several levels of nonlinearity would be key to efciently model complex relationships between variables and to achieve better generalization performance on difcult recognition tasks ( mcclelland et al . , 123; hinton , 123; utgoff and stracuzzi , 123 ) .
this viewpoint is motivated in part by knowledge
c ( cid : 123 ) 123 pascal vincent , hugo larochelle , isabelle lajoie , yoshua bengio and pierre - antoine manzagol .
vincent , larochelle , lajoie , bengio and manzagol
of the layered architecture of regions of the human brain such as the visual cortex , and in part by a body of theoretical arguments in its favor ( hastad , 123; hastad and goldmann , 123; bengio and lecun , 123; bengio , 123 ) .
yet , looking back at the history of multi - layer neural networks , their problematic non - convex optimization has for a long time prevented reaping the expected benets ( bengio et al . , 123; bengio , 123 ) of going beyond one or two hidden layers . 123 consequently much of machine learning research has seen progress in shallow architectures allowing for convex optimization , while the difcult problem of learning in deep networks was left dormant .
the recent revival of interest in such deep architectures is due to the discovery of novel ap - proaches ( hinton et al . , 123; hinton and salakhutdinov , 123; bengio et al . , 123; ranzato et al . , 123; lee et al . , 123 ) that proved successful at learning their parameters .
several alternative tech - niques and renements have been suggested since the seminal work on deep belief networks ( dbn ) by hinton et al .
( 123 ) and hinton and salakhutdinov ( 123 ) .
all appear however to build on the same principle that we may summarize as follows :
training a deep network to directly optimize only the supervised objective of interest ( for ex - ample the log probability of correct classication ) by gradient descent , starting from random initialized parameters , does not work very well .
what works much better is to initially use a local unsupervised criterion to ( pre ) train each layer in turn , with the goal of learning to produce a useful higher - level representation from the lower - level representation output by the previous layer .
from this starting point on , gradient descent on the supervised objective leads to much better solutions in terms of generalization
deep layered networks trained in this fashion have been shown empirically to avoid getting stuck in the kind of poor solutions one typically reaches with only random initializations .
see erhan et al .
( 123 ) for an in depth empirical study and discussion regarding possible explanations for the phenomenon .
in addition to the supervised criterion relevant to the task , what appears to be key is using an additional unsupervised criterion to guide the learning at each layer .
in this sense , these techniques bear much in common with the semi - supervised learning approach , except that they are useful even in the scenario where all examples are labeled , exploiting the input part of the data to regularize , thus approaching better minima of generalization error ( erhan et al . , 123 ) .
there is yet no clear understanding of what constitutes good representations for initializing deep architectures or what explicit unsupervised criteria may best guide their learning .
we know but a few algorithms that work well for this purpose , beginning with restricted boltzmann machines ( rbms ) ( hinton et al . , 123; hinton and salakhutdinov , 123; lee et al . , 123 ) , and autoencoders ( bengio et al . , 123; ranzato et al . , 123 ) , but also semi - supervised embedding ( weston et al . , 123 ) and kernel pca ( cho and saul , 123 ) .
it is worth mentioning here that rbms ( hinton , 123; smolensky , 123 ) and basic classical autoencoders are very similar in their functional form , although their interpretation and the pro - cedures used for training them are quite different .
more specically , the deterministic function that maps from input to mean hidden representation , detailed below in section 123 , is the same for both models .
one important difference is that deterministic autoencoders consider that real valued
there is a notable exception to this in the more specialized convolutional network architecture of lecun et al .
( 123 ) .
stacked denoising autoencoders
mean as their hidden representation whereas stochastic rbms sample a binary hidden representa - tion from that mean .
however , after their initial pretraining , the way layers of rbms are typically used in practice when stacked in a deep neural network is by propagating these real - valued means ( hinton et al . , 123; hinton and salakhutdinov , 123 ) .
this is more in line with the deterministic autoencoder interpretation .
note also that reconstruction error of an autoencoder can be seen as an approximation of the log - likelihood gradient in an rbm , in a way that is similar to the approxima - tion made by using the contrastive divergence updates for rbms ( bengio and delalleau , 123 ) .
it is thus not surprising that initializing a deep network by stacking autoencoders yields almost as good a classication performance as when stacking rbms ( bengio et al . , 123; larochelle et al . , 123a ) .
but why is it only almost as good ? an initial motivation of the research presented here was to nd a way to bridge that performance gap .
with the autoencoder paradigm in mind , we began an inquiry into the question of what can shape a good , useful representation .
we were looking for unsupervised learning principles likely to lead to the learning of feature detectors that detect important structure in the input patterns .
section 123 walks the reader along the lines of our reasoning .
starting from the simple intuitive notion of preserving information , we present a generalized formulation of the classical autoencoder , before highlighting its limitations .
this leads us in section 123 to motivate an alternative denoising criterion , and derive the denoising autoencoder model , for which we also give a possible intuitive geometric interpretation .
a closer look at the considered noise types will then allow us to derive a further extension of the base model .
section 123 discusses related preexisting works and approaches .
section 123 presents experiments that qualitatively study the feature detectors learnt by a single - layer denoising autoencoder under various conditions .
section 123 describes experiments with multi - layer architectures obtained by stacking denoising autoencoders and compares their classication perfor - mance with other state - of - the - art models .
section 123 is an attempt at turning stacked ( denoising ) autoencoders into practical generative models , to allow for a qualitative comparison of generated samples with dbns .
section 123 summarizes our ndings and concludes our work .
we will be using the following notation throughout the article :
random variables are written in upper case , for example , x .
if x is a random vector , then its jth component will be noted x j .
ordinary vectors are written in lowercase bold .
for example , a realization of a random vector
x may be written x .
vectors are considered column vectors .
matrices are written in uppercase bold ( e . g . , w ) .
i denotes the identity matrix .
the transpose of a vector x or a matrix w is written xt or wt ( not x or w which may be
used to refer to an entirely different vector or matrix ) .
we use lower case p and q to denote both probability density functions or probability mass
functions according to context .
let x and y two random variables with marginal probability p ( x ) and p ( y ) .
their joint
probability is written p ( x , y ) and the conditional p ( x|y ) .
we may use the following common shorthands when unambiguous : p ( x ) for p ( x = x ) ; p ( x|y ) for p ( x|y = y ) ( denoting a conditional distribution ) and p ( x|y ) for p ( x = x|y = y ) .
vincent , larochelle , lajoie , bengio and manzagol
f , g , h , will be used for ordinary functions .
expectation ( discrete case , p is probability mass ) : ep ( x ) ( f ( x ) ) = ( cid : 123 ) x p ( x = x ) f ( x ) .
expectation ( continuous case , p is probability density ) : ep ( x ) ( f ( x ) ) = r p ( x ) f ( x ) dx .
entropy or differential entropy : ih ( x ) = ih ( p ) = ep ( x ) ( log p ( x ) ) .
conditional entropy : ih ( x|y ) = ep ( x , y ) ( log p ( x|y ) ) .
kullback - leibler divergence : idkl ( pkq ) = ep ( x ) ( log p ( x ) cross - entropy : ih ( pkq ) = ep ( x ) ( logq ( x ) ) = ih ( p ) + idkl ( pkq ) .
mutual information : i ( x;y ) = ih ( x ) ih ( x|y ) .
sigmoid : s ( x ) = 123 bernoulli distribution with mean : b ( ) .
by extension for vector variables : x b ( ) means
123+ex and s ( x ) = ( s ( x123 ) , .
, s ( xd ) ) t .
i , xi b ( i ) .
123 general setup
we consider the typical supervised learning setup with a training set of n ( input , target ) pairs dn = ( ( x ( 123 ) , t ( 123 ) ) .
, ( x ( n ) , t ( n ) ) ) , that we suppose to be an i . i . d .
sample from an unknown distribution q ( x , t ) with corresponding marginals q ( x ) and q ( t ) .
we denote q123 ( x , t ) and q123 ( x ) the empirical distributions dened by the samples in dn .
x is a d - dimensional random vector ( typically in ird or in ( 123 , 123 ) d ) .
in this work we are primarily concerned with nding a new , higher - level representation y of x .
y is a d - dimensional random vector ( typically in ird or in ( 123 , 123 ) d ) .
if d > d we will talk of an over - complete representation , whereas it will be termed an under - complete representation if d < d .
y may be linked to x by a deterministic or stochastic mapping q ( y|x;q ) parameterized by a vector of parameters q
what makes a good representation ? from mutual information to autoencoders
from the outset we can give an operational denition of a good representation as one that will eventually be useful for addressing tasks of interest , in the sense that it will help the system quickly achieve higher performance on those tasks than if it hadnt rst learned to form the representa - tion .
based on the objective measure typically used to assess algorithm performance , this might be phrased as a good representation is one that will yield a better performing classier .
final classi - cation performance will indeed typically be used to objectively compare algorithms .
however , if a lesson is to be learnt from the recent breakthroughs in deep network training techniques , it is that the error signal from a single narrowly dened classication task should not be the only nor primary criterion used to guide the learning of representations .
first because it has been shown experimen - tally that beginning by optimizing an unsupervised criterion , oblivious of the specic classication problem , can actually greatly help in eventually achieving superior performance for that classica - tion problem .
second it can be argued that the capacity of humans to quickly become procient in new tasks builds on much of what they have learnt prior to being faced with that task .
in this section , we begin with the simple notion of retaining information and progress to formally
introduce the traditional autoencoder paradigm from this more general vantage point .
stacked denoising autoencoders
123 retaining information about the input
we are interested in learning a ( possibly stochastic ) mapping from input x to a novel representa - tion y .
to make this more precise , let us restrict ourselves to parameterized mappings q ( y|x ) = q ( y|x;q ) with parameters q one natural criterion that we may expect any good representation to meet , at least to some degree , is to retain a signicant amount of information about the input .
it can be expressed in information - theoretic terms as maximizing the mutual information i ( x;y ) between an input random variable x and its higher level representation y .
this is the infomax principle put forward by linsker
that we want to learn .
mutual information can be decomposed into an entropy and a conditional entropy term in two different ways .
a rst possible decomposition is i ( x;y ) = ih ( y ) ih ( y|x ) which lead bell and sejnowski ( 123 ) to their infomax approach to independent component analysis .
here we will start from another decomposition : i ( x;y ) = ih ( x ) ih ( x|y ) .
since observed input x comes from an unknown distribution q ( x ) on which q has no inuence , this makes ih ( x ) an unknown constant .
thus the infomax principle reduces to :
i ( x;y ) = argmax
eq ( x , y ) ( log q ( x|y ) ) .
now for any distribution p ( x|y ) we will have let us consider a parametric distribution p ( x|y ;q
eq ( x , y ) ( log p ( x|y ) ) eq ( x , y ) ( log q ( x|y ) ) as can easily be shown starting from the property that for any two distributions p and q we have idkl ( qkp ) 123 , and in particular idkl ( q ( x|y = y ) kp ( x|y = y ) ) 123
) , parameterized by q
, and the following
eq ( x , y ;q ) ( log p ( x|y ;q
from equation 123 , we see that this corresponds to maximizing a lower bound on ih ( x|y ) and thus on the mutual information .
we would end up maximizing the exact mutual information provided s . t .
q ( x|y ) = p ( x|y ;q if , as is done in infomax ica , we further restrict ourselves to a deterministic mapping from x to y , that is , representation y is to be computed by a parameterized function y = fq ( x ) or equivalently q ( y|x;q ) = d ( y fq ( x ) ) ( where d denotes dirac - delta ) , then this optimization can be written :
eq ( x ) ( log p ( x|y = fq ( x ) ;q
this again corresponds to maximizing a lower bound on the mutual information .
since q ( x ) is unknown , but we have samples from it , the empirical average over the training
samples can be used instead as an unbiased estimate ( i . e . , replacing eq ( x ) by eq123 ( x ) ) :
eq123 ( x ) ( log p ( x|y = fq ( x ) ;q
vincent , larochelle , lajoie , bengio and manzagol
we will see in the next section that this equation corresponds to the reconstruction error criterion
used to train autoencoders .
123 traditional autoencoders ( ae ) here we briey specify the traditional autoencoder ( ae ) 123 framework and its terminology , based on fq and p ( x|y ;q tation y is called the encoder .
its typical form is an afne mapping followed by a nonlinearity :
that transforms an input vector x into hidden represen -
encoder : the deterministic mapping fq
) introduced above .
fq ( x ) = s ( wx + b ) .
its parameter set is q = ( w , b ) , where w is a d d weight matrix and b is an offset vector of decoder : the resulting hidden representation y is then mapped back to a reconstructed d - is called the decoder .
its typical dimensional vector z in input space , z = gq form is again an afne mapping optionally followed by a squashing non - linearity , that is , either
this mapping gq
( y ) = wy + b or
with appropriately sized parameters q
( y ) = s ( wy + b ) ,
in general z is not to be interpreted as an exact reconstruction of x , but rather in probabilistic terms as the parameters ( typically the mean ) of a distribution p ( x|z = z ) that may generate x with high probability .
we have thus completed the specication of p ( x|y ;q ) from the previous section as p ( x|y = y ) = p ( x|z = gq ( y ) ) .
this yields an associated reconstruction error to be optimized :
l ( x , z ) ( cid : 123 ) log p ( x|z ) .
common choices for p ( x|z ) and associated loss function l ( x , z ) include : for real - valued x , that is , x ird : x|z n ( z , s 123i ) , that is , x j|z n ( z j , s 123 ) .
this yields l ( x , z ) = l123 ( x , z ) = c ( s 123 ) kx zk123 where c ( s 123 ) denotes a constant that depends only on s 123 and that can be ignored for the optimization .
this is the squared error objective found in most traditional autoencoders .
in this setting , due to the gaussian interpretation , it is more natural not to use a squashing nonlinearity in the decoder .
for binary x , that is , x ( 123 , 123 ) d : x|z b ( z ) , that is , x j|z b ( z j ) .
typically be used in the decoder .
in this case , the decoder needs to produce a z ( 123 , 123 ) d .
so a squashing nonlinearity such as a this yields l ( x , z ) = lih ( x , z ) = sigmoid s will j ( x j logz j + ( 123x j ) log ( 123z j ) ) = ih ( b ( x ) kb ( z ) ) which is termed the cross - entropy loss because it is seen as the cross - entropy between two independent multivariate bernoullis , the rst with mean x and the other with mean z .
this loss can also be used when x is not strictly binary but rather x ( 123 , 123 ) d .
note : autoencoders ( ae ) are also often called autoassociators ( aa ) in the literature .
the shorter autoencoder term was preferred in this work , as we believe encoding better conveys the idea of producing a novel useful representation .
similarly , what we call stacked auto encoders ( sae ) has also been called stacked autoassociators ( saa ) .
stacked denoising autoencoders
note that in the general autoencoder framework , we may use other forms of parameterized func - tions for the encoder or decoder , and other suitable choices of the loss function ( corresponding to a different p ( x|z ) ) .
in particular , we investigated the usefulness of a more complex encoding function in larochelle , erhan , and vincent ( 123b ) .
for the experiments in the present work however , we will restrict ourselves to the two usual forms detailed above , that is , an afne+sigmoid encoder and either afne decoder with squared error loss or afne+sigmoid decoder with cross - entropy loss .
a further constraint that can optionally be imposed , and that further parallels the workings of rbms , is having tied weights between w and w , in effect dening w as w = w t .
autoencoder training consists in minimizing the reconstruction error , that is , carrying the fol -
where we wrote z ( x ) to emphasize the fact that z is a deterministic function of x , since z is obtained by composition of deterministic encoding and decoding .
making this explicit and using our denition of loss l from equation 123 this can be rewritten as :
eq123 ( x ) ( log p ( x|z = gq
( fq ( x ) ) ) ) ,
eq123 ( x ) ( log p ( x|y = fq ( x ) ;q
we see that this last line corresponds to equation 123 , that is , the maximization of a lower bound on the mutual information between x and y .
it can thus be said that training an autoencoder to minimize reconstruction error amounts to maximizing a lower bound on the mutual information between input x and learnt repre - sentation y .
intuitively , if a representation allows a good reconstruction of its input , it means that it has retained much of the information that was present in that input .
123 merely retaining information is not enough
the criterion that representation y should retain information about input x is not by itself sufcient to yield a useful representation .
indeed mutual information can be trivially maximized by setting y = x .
similarly , an ordinary autoencoder where y is of the same dimensionality as x ( or larger ) can achieve perfect reconstruction simply by learning an identity mapping . 123 without any other constraints , this criterion alone is unlikely to lead to the discovery of a more useful representation than the input .
thus further constraints need to be applied to attempt to separate useful information ( to be re - tained ) from noise ( to be discarded ) .
this will naturally translate to non - zero reconstruction error .
the traditional approach to autoencoders uses a bottleneck to produce an under - complete repre - sentation where d < d .
the resulting lower - dimensional y can thus be seen as a lossy compressed representation of x .
when using afne encoder and decoder without any nonlinearity and a squared error loss , the autoencoder essentially performs principal component analysis ( pca ) as showed by
more precisely , it sufces that g f be the identity to obtain zero reconstruction error .
for d = d if we had a linear encoder and decoder this would be achieved for any invertible matrix w by setting w = w123
now there is a sigmoid nonlinearity in the encoder , but it is possible to stay in the linear part of the sigmoid with small enough w .
vincent , larochelle , lajoie , bengio and manzagol
baldi and hornik ( 123 ) . 123 when a nonlinearity such as a sigmoid is used in the encoder , things become a little more complicated : obtaining the pca subspace is a likely possibility ( bourlard and kamp , 123 ) since it is possible to stay in the linear regime of the sigmoid , but arguably not the only one ( japkowicz et al . , 123 ) .
also when using a cross - entropy loss rather than a squared error the optimization objective is no longer the same as that of pca and will likely learn different features .
the use of tied weights can also change the solution : forcing encoder and decoder matrices to be symmetric and thus have the same scale can make it harder for the encoder to stay in the linear regime of its nonlinearity without paying a high price in reconstruction error .
alternatively it is also conceivable to impose on y different constraints than that of a lower dimensionality .
in particular the possibility of using over - complete ( i . e . , higher dimensional than the input ) but sparse representations has received much attention lately .
interest in sparse repre - sentations is inspired in part by evidence that neural activity in the brain seems to be sparse and has burgeoned following the seminal work of olshausen and field ( 123 ) on sparse coding .
other motivations for sparse representations include the ability to handle effectively variable - size repre - sentations ( counting only the non - zeros ) , and the fact that dense compressed representations tend to entangle information ( i . e . , changing a single aspect of the input yields signicant changes in all components of the representation ) whereas sparse ones can be expected to be easier to interpret and to use for a subsequent classier .
various modications of the traditional autoencoder framework have been proposed in order to learn sparse representations ( ranzato et al . , 123 , 123 ) .
these were shown to extract very useful representations , from which it is possible to build top performing deep neural network classiers .
a sparse over - complete representations can be viewed as an alter - native compressed representation : it has implicit straightforward compressibility due to the large number of zeros rather than an explicit lower dimensionality .
using a denoising criterion
we have seen that the reconstruction criterion alone is unable to guarantee the extraction of useful features as it can lead to the obvious solution simply copy the input or similarly uninteresting ones that trivially maximizes mutual information .
one strategy to avoid this phenomenon is to constrain the representation : the traditional bottleneck and the more recent interest on sparse representations both follow this strategy .
here we propose and explore a very different strategy .
rather than constrain the representation , we change the reconstruction criterion for a both more challenging and more interesting objec - tive : cleaning partially corrupted input , or in short denoising .
in doing so we modify the implicit denition of a good representation into the following : a good representation is one that can be obtained robustly from a corrupted input and that will be useful for recovering the corresponding clean input .
two underlying ideas are implicit in this approach :
first it is expected that a higher level representation should be rather stable and robust under
corruptions of the input .
second , it is expected that performing the denoising task well requires extracting features that
capture useful structure in the input distribution .
more specically it will nd the same subspace as pca , but the specic projection directions found will in general
not correspond to the actual principal directions and need not be orthonormal .
stacked denoising autoencoders
we emphasize here that our goal is not the task of denoising per se .
rather denoising is ad - vocated and investigated as a training criterion for learning to extract useful features that will constitute better higher level representation .
the usefulness of a learnt representation can then be assessed objectively by measuring the accuracy of a classier that uses it as input .
123 the denoising autoencoder algorithm
this approach leads to a very simple variant of the basic autoencoder described above .
a denoising autoencoder ( dae ) is trained to reconstruct a clean repaired input from a corrupted version of it ( the specic types of corruptions we consider will be discussed below ) .
this is done by rst corrupting the initial input x into x by means of a stochastic mapping x qd ( x|x ) .
corrupted input x is then mapped , as with the basic autoencoder , to a hidden representation ( y ) .
see figure 123 for a schematic y = fq ( x ) = s ( wx + b ) from which we reconstruct a z = gq representation of the procedure .
parameters q and q are trained to minimize the average recon - struction error over a training set , that is , to have z as close as possible to the uncorrupted input x .
the key difference is that z is now a deterministic function of x rather than x .
as previously , the considered reconstruction error is either the cross - entropy loss lih ( x , z ) = ih ( b ( x ) kb ( z ) ) , with an afne+sigmoid decoder , or the squared error loss l123 ( x , z ) = kx zk123 , with an afne decoder .
pa - rameters are initialized at random and then optimized by stochastic gradient descent .
note that each time a training example x is presented , a different corrupted version x of it is generated according to qd ( x|x ) .
note that denoising autoencoders are still minimizing the same reconstruction loss between a clean x and its reconstruction from y .
so this still amounts to maximizing a lower bound on the mutual information between clean input x and representation y .
the difference is that y is now obtained by applying deterministic mapping fq to a corrupted input .
it thus forces the learning of a far more clever mapping than the identity : one that extracts features useful for denoising .
figure 123 : the denoising autoencoder architecture .
an example x is stochastically corrupted ( via qd ) to x .
the autoencoder then maps it to y ( via encoder fq ) and attempts to reconstruct , producing reconstruction z .
reconstruction error is measured by loss x via decoder gq
vincent , larochelle , lajoie , bengio and manzagol
123 geometric interpretation
the process of denoising , that is , mapping a corrupted example back to an uncorrupted one , can be given an intuitive geometric interpretation under the so - called manifold assumption ( chapelle et al . , 123 ) , which states that natural high dimensional data concentrates close to a non - linear low - dimensional manifold .
this is illustrated in figure 123
during denoising training , we learn a
stochastic operator p ( x|ex ) that maps a corrupted ex back to its uncorrupted x , for example , in the
case of binary data ,
( fq ( ex ) ) ) .
corrupted examples are much more likely to be outside and farther from the manifold than the
uncorrupted ones .
thus stochastic operator p ( x|ex ) learns a map that tends to go from lower prob - ability points ex to nearby high probability points x , on or near the manifold .
note that when ex is farther from the manifold , p ( x|ex ) should learn to make bigger steps , to reach the manifold
cessful denoising implies that the operator maps even far away points to a small region close to the
the denoising autoencoder can thus be seen as a way to dene and learn a manifold .
in particu - lar , if we constrain the dimension of y to be smaller than the dimension of x , then the intermediate representation y = f ( x ) may be interpreted as a coordinate system for points on the manifold .
more generally , one can think of y = f ( x ) as a representation of x which is well suited to capture the main variations in the data , that is , those along the manifold .
123 types of corruption considered
the above principle and technique can potentially be used with any type of corruption process .
also the corruption process is an obvious place where prior knowledge , if available , could be easily in - corporated .
but in the present study we set to investigate a technique that is generally applicable
g ( f ( x ) )
qd ( x|x )
figure 123 : manifold learning perspective .
suppose training data ( ) concentrate near a low - dimensional manifold .
corrupted examples ( . ) obtained by applying corruption process qd ( ex|x ) will generally lie farther from the manifold .
the model learns with p ( x|ex ) to project them back ( via autoencoder gq ( fq ( ) ) ) onto the manifold .
intermediate rep - resentation y = fq ( x ) may be interpreted as a coordinate system for points x on the
stacked denoising autoencoders
particular we want it to be usable for learning ever higher level representations by stacking denois - ing autoencoders .
now while prior knowledge on relevant corruption processes may be available in a particular input space ( such as images ) , such prior knowledge will not be available for the space of intermediate - level representations .
we will thus restrict our discussion and experiments to the following simple corruption pro -
is forced to 123;
additive isotropic gaussian noise ( gs ) : x|x n ( x , s 123i ) ; masking noise ( mn ) : a fraction n of the elements of x ( chosen at random for each example ) salt - and - pepper noise ( sp ) : a fraction n of the elements of x ( chosen at random for each
example ) is set to their minimum or maximum possible value ( typically 123 or 123 ) according to a fair coin ip .
additive gaussian noise is a very common noise model , and is a natural choice for real val - ued inputs .
the salt - and - pepper noise will also be considered , as it is a natural choice for input domains which are interpretable as binary or near binary such as black and white images or the representations produced at the hidden layer after a sigmoid squashing function .
much of our work however , both for its inspiration and in experiments , focuses on masking noise which can be viewed as turning off components considered missing or replacing their value by a default valuethat is , a common technique for handling missing values .
all information about these masked components is thus removed from that particular input pattern , and we can view the denoising autoencoder as trained to ll - in these articially introduced blanks .
also , numerically , forcing components to zero means that they are totally ignored in the computations of downstream
we draw the readers attention to the fact that both salt - and - pepper and masking noise drasti - cally corrupt but a fraction of the elements while leaving the others untouched .
denoising , that is , recovering the values of the corrupted elements , will only be possible thanks to dependencies be - tween dimensions in high dimensional distributions .
denoising training is thus expected to capture these dependencies .
the approach probably makes less sense for very low dimensional problems , at least with these types of corruption .
123 extension : putting an emphasis on corrupted dimensions
noise types such as masking noise and salt - and - pepper that erase only a changing subset of the inputs components while leaving the others untouched suggest a straightforward extension of the denoising autoencoder criterion .
rather than giving equal weight to the reconstruction of all com - ponents of the input , we can put an emphasis on the corrupted dimensions .
to achieve this we give a different weight a that were left untouched .
a and b are considered hyperparameters .
for the reconstruction error on components that were corrupted , and b
for the squared loss this yields
l123 , a ( x , z ) = a ( cid : 123 )
( x j z j ) 123 ! + b ( cid : 123 )
( x j z j ) 123 ! ,
j / j ( x )
where j ( x ) denotes the indexes of the components of x that were corrupted .
vincent , larochelle , lajoie , bengio and manzagol
and for the cross - entropy loss this yields
lih , a ( x , z ) = a ( cid : 123 )
( x j logz j + ( 123 x j ) log ( 123 z j ) ) ! ( x j logz j + ( 123 x j ) log ( 123 z j ) ) ! .
j / j ( x )
we call this extension emphasized denoising autoencoder .
a special case that we call full emphasis is obtained for a = 123 , b = 123 where we only take into account the error on the prediction of corrupted elements .
123 stacking denoising autoencoders to build deep architectures
stacking denoising autoencoders to initialize a deep network works in much the same way as stack - ing rbms in deep belief networks ( hinton et al . , 123; hinton and salakhutdinov , 123 ) or ordinary autoencoders ( bengio et al . , 123; ranzato et al . , 123; larochelle et al . , 123a ) .
let us specify that input corruption is only used for the initial denoising - training of each individual layer , so that it may learn useful feature extractors .
once the mapping fq has thus been learnt , it will henceforth be used on uncorrupted inputs .
in particular no corruption is applied to produce the representation that will serve as clean input for training the next layer .
the complete procedure for learning and stacking several layers of denoising autoencoders is shown in figure 123
once a stack of encoders has thus been built , its highest level output representation can be used as input to a stand - alone supervised learning algorithm , for example a support vector machine classier or a ( multi - class ) logistic regression .
alternatively , as illustrated in figure 123 , a logistic regression layer can be added on top of the encoders , yielding a deep neural network amenable to supervised learning .
the parameters of all layers can then be simultaneously ne - tuned using a gradient - based procedure such as stochastic gradient descent .
related approaches in the literature
in this section , we briey review and discuss related prior work along three different axes .
123 previous work on training neural networks for denoising
the idea of training a multi - layer perceptron using error backpropagation on a denoising task is not new .
the approach was rst introduced by lecun ( 123 ) and gallinari et al .
( 123 ) as an alternative method to learn an ( auto - ) associative memory similar to how hopeld networks ( hopeld , 123 ) were understood .
the networks were trained and tested on binary input patterns , corrupted by ipping a fraction of input bits chosen at random .
both the model and training procedure in this precursory work are very similar to the denoising autoencoder we describe . 123 our motivation and goal are however quite different .
the objective of lecun ( 123 ) was to study the capacity of such a network for memorization tasks , that is , counting how many training patterns it was able to
there are a few minor differences; for example , the use of a squared error after sigmoid for binary data , while we tend to use a cross - entropy loss .
also their denoising procedure considers doing several recurrent passes through the autoencoder network , as in a recurrent net .
stacked denoising autoencoders
figure 123 : stacking denoising autoencoders .
after training a rst level denoising autoencoder ( see figure 123 ) its learnt encoding function fq is used on clean input ( left ) .
the resulting representation is used to train a second level denoising autoencoder ( middle ) to learn a second level encoding function f ( 123 )
from there , the procedure can be repeated ( right ) .
figure 123 : fine - tuning of a deep network for classication .
after training a stack of encoders as explained in the previous gure , an output layer is added on top of the stack .
the param - eters of the whole system are ne - tuned to minimize the error in predicting the supervised target ( e . g . , class ) , by performing gradient descent on a supervised cost .
vincent , larochelle , lajoie , bengio and manzagol
correctly recall under these conditions .
the work also clearly established the usefulness of a non - linear hidden layer for this .
by contrast , our work is motivated by the search and understanding of unsupervised pretraining criteria to initialize deep networks .
our primary interest is thus in investigating the ability of the denoising criterion to learn good feature extractors , with which to initialize a deep network by stacking and composing these feature extractors .
we focus on analyzing the learnt higher - level representations and their effect on the classication performance of resulting
another insightful work that is very much related to the approach advocated here is the research of seung ( 123 ) , in which a recurrent neural network is trained to complete corrupted input patterns using backpropagation through time .
both the work of seung ( 123 ) and that of lecun ( 123 ) and gallinari et al .
( 123 ) appear to be inspired by hopeld - type associative memories ( hopeld , 123 ) in which learnt patterns are conceived as attractive xed points of a recurrent network dynamic .
seung ( 123 ) contributes a very interesting analysis in terms of continuous attractors , points out the limitations of regular autoencoding , and advocates the pattern completion task as an alternative to density estimation for unsupervised learning .
again , it differs form our study mainly by its focus a ) on recurrent networks123 and b ) on the image denoising task per se .
the latter justies their use of prior knowledge of the 123d topology of images , both in the architectural choice of local 123d receptive eld connectivity , and in the corruption process that consists in zeroing - out a square image patch at a random position .
this occlusion by a 123d patch is a special form of a structured masking noise , where the a - priori known 123d topological structure of images is taken into account .
in our research we deliberately chose not to use topological prior knowledge in our model nor in our corruption process , so that the same generic procedure may be applied to learn higher levels of representation from lower ones , or to other domains for which we have no such topological prior knowledge .
more recently jain and seung ( 123 ) presented a very interesting and successful approach for image denoising , that consists in layer - wise building of a deep convolutional neural network .
their algorithm yields comparable or better performance than state - of - the - art markov random field and wavelet methods developed for image denoising .
the approach clearly has roots in their earlier work ( seung , 123 ) and appears also inspired by more recent research on deep network pretraining , including our own groups ( bengio et al . , 123 ) .
but apparently , neither of us was initially aware of the other groups relevant work on denoising ( vincent et al . , 123; jain and seung , 123 ) .
again the focus of seung ( 123 ) on image denoising per se differs from our own focus on studying deep net - work pretraining for classication tasks and results in marked differences in the actual algorithms .
specically , in jain and seung ( 123 ) each layer in the stack is trained to reconstruct the original clean image a little better , which makes sense for image denoising .
this can be contrasted with our approach , in which upper layers are trained to denoise - and - reconstruct whatever representation they receive from the layer immediately below , rather than to restore the original input image in one operation .
this logically follows from our search for a generic feature extraction algorithm for pretraining , where upper level representations will eventually be used for a totally different task such as classication .
note however that a recurrent network can be seen as deep network , with the additional property that all layers share
the same weights .
stacked denoising autoencoders
123 training classiers with noisy inputs
the idea of training a neural network with noisy input ( scalettar and zee , 123; von lehman et al . , 123 ) or training with jitter as it is sometimes calledhas been proposed to enhance generaliza - tion performance for supervised learning tasks ( sietsma and dow , 123; holmstrm and koistinen , 123; an , 123 ) .
this thread of research is less directly related to autoencoders and denoising than the studies discussed in the previous section .
it is nevertheless relevant .
after all , denoising amounts to using noisy patterns as input with the clean pattern as a supervised target , albeit a rather high di - mensional one .
it has been argued that training with noise is equivalent to applying generalized tikhonov regularization ( bishop , 123 ) .
on the surface , this may seem to suggest that training with noisy inputs has a similar effect to training with an l123 weight decay penalty ( i . e . , penalizing the sum of squared weights ) , but this view is incorrect .
tikhonov regularization applied to linear regression is indeed equivalent to a l123 weight decay penalty ( i . e . , ridge regression ) .
but for a non - linear map - ping such as a neural network , tikhonov regularization is no longer so simple ( bishop , 123 ) .
more importantly , in the non - linear case , the equivalence of noisy training with tikhonov regularization is derived from a taylor series expansion , and is thus only valid in the limit of very small additive noise .
see grandvalet et al .
( 123 ) for a theoretical study and discussion regarding the limitations of validity for this equivalence .
last but not least , our experimental results in section 123 clearly show qualitatively very different results when using denoising autoencoders ( i . e . , noisy inputs ) than when using regular autoencoders with a l123 weight decay .
here , we must also mention a well - known technique to improve the generalization performance of a classier ( neural network or other ) , which consists in augmenting the original training set with additional distorted inputs , either explicitly ( baird , 123; poggio and vetter , 123 ) or virtually through a modied algorithm ( simard et al . , 123; scholkopf et al . , 123 ) .
for character images for instance such distortions may include small translations , rotations , scalings and shearings of the image , or even applying a scanner noise model .
this technique can thus be seen as training with noisy corrupted inputs , but with a highly structured corruption process based on much prior knowledge . 123 as already explained and motivated above , our intent in this work is to develop and investigate a generally applicable technique , that should also be applicable to intermediate higher level representations .
thus we intentionally restrict our study to very simple generic corruption processes that do not incorporate explicit prior knowledge .
we also stress the difference between the approaches we just discussed , that consist in training a neural network by optimizing a global supervised criterion using noisy input , and the approach we investigate in the present work , that is , using a local unsupervised denoising criterion to pretrain each layer of the network with the goal to learn useful intermediate representations .
we shall see in experimental section 123 that the latter applied to a deep network yields better classication performance than the former .
123 pseudo - likelihood and dependency networks
the view of denoising training as lling in the blanks that motivated the masking noise and the extension that puts an emphasis on corrupted dimensions presented in section 123 , can also be re - lated to the pseudo - likelihood ( besag , 123 ) and dependency network ( heckerman et al . , 123 )
clearly , simple tikhonov regularization cannot achieve the same as training with such prior knowledge based cor - ruption process .
this further illustrates the limitation of the equivalence between training with noise and tikhonov
vincent , larochelle , lajoie , bengio and manzagol
paradigms .
maximizing pseudo - likelihood instead of likelihood implies replacing the likelihood term p ( x ) by the product of conditionals ( cid : 123 ) i=123 p ( xi|xi ) .
here xi denotes the ith component of input vector variable x and xi denotes all components but the ith .
similarly , in the dependency network approach of heckerman et al .
( 123 ) one learns d conditional distributions , each trained to predict component i given ( a subset of ) all other components .
this is in effect what an emphasized denoising autoencoder with a masking noise that masks but one input component ( n = 123 d ) , and a full emphasis ( a = 123 , b = 123 ) , is trained to do .
more specically , for binary variables it will learn to predict p ( xi = 123|xi ) ; and when using squared error for real - valued variables it will learn to predict e ( xi|xi ) assuming xi|xi n ( e ( xi|xi ) , s 123 ) .
note that with denoising autoencoders , all d conditional distributions are constrained to share common parameters , which dene the mapping to and from hidden representation y .
also when the emphasis is not fully put on the corrupted com - ponents ( b > 123 ) some of the networks capacity will be devoted to encoding / decoding uncorrupted
a more important difference can be appreciated by considering the following scenario : what happens if components of the input come in identical pairs ? in that case , conditional distribution p ( xi|xi ) can simply learn to replicate the other component of the pair , thus not capturing any other potentially useful dependency .
now for dependency networks this exact scenario is forbidden by the formal requirement that no input conguration may have zero probability .
but a similar problem may occur in practice if the components in a pair are not identical but very highly correlated .
by contrast , denoising autoencoders can and will typically be trained with a larger fraction n of cor - rupted components , so that reliable prediction of a component cannot rely exclusively on a single
experiments on single denoising autoencoders : qualitative evaluation of
learned feature detectors
a rst series of experiments was carried out using single denoising autoencoders , that is , without any stacking nor supervised ne tuning .
the goal was to examine qualitatively the kind of feature detectors learnt by a denoising criterion , for various noise types , and compare these to what ordinary
feature detectors that correspond to the rst hidden layer of a network trained on image data are straightforward to visualize .
each hidden neuron y j has an associated vector of weights w j that it uses to compute a dot product with an input example ( before applying its non - linearity ) .
these w j vectors , the lters , have the same dimensionality as the input , and can thus be displayed as little images showing what aspects of the input each hidden neuron is sensitive to .
123 feature detectors learnt from natural image patches we trained both regular autoencoders and denoising autoencoders on 123 patches from whitened natural scene images , made available by olshausen ( olshausen and field , 123 ) . 123 a few of these patches are shown in figure 123 ( left ) .
for these natural image patches , we used a linear decoder and a squared reconstruction cost .
network parameters were trained from a random start , 123 using
more specically randomly positioned 123 123 patches were extracted from the 123 123 patches made available by 123
we applied the usual random initialization heuristic in which weights are sampled independently form a uniform in
olshausen at the following url : https : / / redwood . berkeley . edu / bruno / sparsenet / .
range ( 123fanin
) where fanin in this case is the input dimension .
stacked denoising autoencoders
stochastic gradient descent to perform 123 weight updates with a xed learning rate of 123 .
all lters shown were from experiments with tied weights , but untied weights yielded similar results .
figure 123 displays lters learnt by a regular under - complete autoencoder that used a bottleneck of 123 hidden units , as well as those learnt by an over - complete autoencoder using 123 hidden units .
filters obtained in the under - complete case look like very local blob detectors .
no clear structure is apparent in the lters learnt in the over - complete case .
figure 123 : regular autoencoder trained on natural image patches .
left : some of the 123 123 image patches used for training .
middle : lters learnt by a regular under - complete autoencoder ( 123 hidden units ) using tied weights and l123 reconstruction error .
right : lters learnt by a regular over - complete autoencoder ( 123 hidden units ) .
the under - complete autoencoder appears to learn rather uninteresting local blob detectors .
filters obtained in the over - complete case have no recognizable structure , looking entirely random .
we then trained 123 hidden units over - complete noiseless autoencoders regularized with l123 weight decay , as well as 123 hidden units denoising autoencoders with isotropic gaussian noise ( but no weight decay ) .
resulting lters are shown in figure 123
note that a denoising autoencoder with a noise level of 123 is identical to a regular autoencoder .
so , naturally , lters learnt by a denoising autoencoder at small noise levels ( not shown ) look like those obtained with a regular autoencoder previously shown in figure 123
with a sufciently large noise level however ( s = 123 ) , the denoising autoencoder learns gabor - like local oriented edge detectors ( see figure 123 ) .
this is similar to what is learnt by sparse coding ( olshausen and field , 123 , 123 ) , or ica ( bell and sejnowski , 123 ) and resembles simple cell receptive elds from the primary visual cortex rst studied by hubel and wiesel ( 123 ) .
the l123 regularized autoencoder on the other hand learnt nothing interesting beyond restoring some of the local blob detectors found in the under - complete case .
note that we did try a wide range of values for the regularization hyperparameter , 123 but were never able to get gabor - like lters .
from this experiment , we see clearly that training with sufciently large noise yields a qualitatively very different outcome than training with a weight decay regularization , which conrms experimentally that the two are not equivalent for a non - linear autoencoder , as discussed earlier in section 123 .
figure 123 shows some of the results obtained with the other two noise types considered , that is ,
salt - and - pepper noise , and masking - noise .
we experimented with 123 corruption levels n : 123% , 123% , 123% .
the lters shown were obtained using 123 hidden units , but similar lters were found with 123 or 123 hidden units .
salt - and - pepper noise yielded gabor - like edge detectors , whereas masking noise 123
attempted weight decays values were the following : l ( 123 , 123 , 123 , 123 , 123 , 123 , 123 , 123 , 123 ,
vincent , larochelle , lajoie , bengio and manzagol
figure 123 : weight decay vs .
gaussian noise .
we show typical lters learnt from natural image patches in the over - complete case ( 123 hidden units ) .
left : regular autoencoder with weight decay .
we tried a wide range of weight - decay values and learning rates : lters never appeared to capture a more interesting structure than what is shown here .
note that some local blob detectors are recovered compared to using no weight decay at all ( figure 123 right ) .
right : a denoising autoencoder with additive gaussian noise ( s = 123 ) learns gabor - like local oriented edge detectors .
clearly the lters learnt are qualitatively very different in the two cases .
yielded a mixture of edge detectors and grating lters .
clearly different corruption types and levels can yield qualitatively different lters .
but it is interesting to note that all three noise types we experimented with were able to yield some potentially useful edge detectors .
123 feature detectors learnt from handwritten digits we also trained denoising autoencoders on the 123 123 gray - scale images of handwritten digits from the mnist data set .
for this experiment , we used denoising autoencoders with tied weights , cross - entropy reconstruction error , and zero - masking noise .
the goal was to better understand the qualitative effect of the noise level .
so we trained several denoising autoencoders , all starting from the same initial random point in weight space , but with different noise levels .
figure 123 shows some of the resulting lters learnt and how they are affected as we increase the level of corruption .
with 123% corruption , the majority of the lters appear totally random , with only a few that specialize as little ink blob detectors .
with increased noise levels , a much larger proportion of interesting ( visibly non random and with a clear structure ) feature detectors are learnt .
these include local oriented stroke detectors and detectors of digit parts such as loops .
it was to be expected that denoising a more corrupted input requires detecting bigger , less local structures : the denoising auto - encoder must rely on longer range statistical dependencies and pool evidence from a larger subset of pixels .
interestingly , lters that start from the same initial random weight vector often look like they grow from random , to local blob detector , to slightly bigger structure detectors such as a stroke detector , as we use increased noise levels .
by grow we mean that the slightly larger structure learnt at a higher noise level often appears related to the smaller structure obtained at lower noise levels , in that they share about the same position and orientation .
stacked denoising autoencoders
figure 123 : filters obtained on natural image patches by denoising autoencoders using other noise types .
left : with 123% salt - and - pepper noise , we obtain oriented gabor - like lters .
they appear slightly less localized than when using gaussian noise ( contrast with figure 123 right ) .
right : with 123% zero - masking noise we obtain lters that look like oriented gratings .
for the three considered noise types , denoising training appears to learn lters that capture meaningful natural image statistics structure .
experiments on stacked denoising autoencoders
in this section , we evaluate denoising autoencoders as a pretraining strategy for building deep net - works , using the stacking procedure that we described in section 123 .
we shall mainly compare the classication performance of networks pretrained by stacking denoising autoencoders ( sdae ) , ver - sus stacking regular autoencoders ( sae ) , versus stacking restricted boltzmann machines ( dbn ) , on a benchmark of classication problems .
123 considered classication problems and experimental methodology
we considered 123 classication problems , the details of which are listed in table 123
they consist
the standard mnist digit classication problem with 123 training examples .
the eight benchmark image classication problems used in larochelle et al .
( 123 ) which in - clude more challenging variations of the mnist digit classication problem ( all with 123 training examples ) , as well as three articial 123 123 binary image classication tasks . 123 these problems were designed to be particularly challenging to current generic learning al - gorithms ( larochelle et al . , 123 ) .
they are illustrated in figure 123
a variation of the tzanetakis audio genre classication data set ( bergstra , 123 ) which con - tains 123 three - second audio clips , equally distributed among 123 musical genres : blues , classical , country , disco , hiphop , pop , jazz , metal , reggae and rock .
each example in the set
the data sets for this benchmark are available at http : / / www . iro . umontreal . ca / lisa / icml123
vincent , larochelle , lajoie , bengio and manzagol
( a ) no corruption
( b ) 123% corruption
( c ) 123% corruption
( d ) neuron a ( 123% , 123% , 123% , 123% corruption )
( e ) neuron b ( 123% , 123% , 123% , 123% corruption )
figure 123 : filters learnt by denoising autoencoder on mnist digits , using zero - masking noise .
( a - c ) show some of the lters learnt by denoising autoencoders trained with various corruption .
filters at the same position in the three images are related only by the fact that the autoencoders were started from the same random initialization point in parameter space .
( d ) and ( e ) zoom in on the lters obtained for two of the neurons .
as can be seen , with no noise , many lters remain similarly uninteresting ( undistinctive almost uniform random grey patches ) .
as we increase the noise level , denoising training forces the lters to differentiate more , and capture more distinctive features .
higher noise levels tend to induce less local lters , as expected .
one can distinguish different kinds of lters , from local blob detectors , to stroke detectors , and character parts detectors at the higher noise
was represented by 123 mel phon coefcient ( mpc ) features .
these are a simplied for - mulation of the mel - frequency cepstral coefcients ( mfccs ) that were shown to yield better classication performance ( bergstra , 123 ) .
all problems except tzanetakis had their data split into training set , validation set and test set .
we kept the same standard splits that were used in larochelle et al .
( 123 ) .
the training set is used for both pretraining and ne tuning of the models .
classication performance on the validation set is used for choosing the best conguration of hyperparameters ( model selection ) .
the corresponding classication performance on the test set is then reported together with a 123% condence interval .
for tzanetakis we used a slightly different procedure , since there was no predened standard split and fewer examples .
we used 123 - fold cross validation , where each fold consisted of 123 training examples , 123 test and 123 validation examples .
for each fold , hyperparameters were chosen based on the performance on the validation set , and the retained model was used for com - puting the corresponding test error .
we report the average test error and standard deviation across the 123 folds .
we were thus able to compare the classication performance of deep neural networks using
different unsupervised initialization strategies for their parameters :
stacked denoising autoencoders
mlp random : multilayer perceptron with usual random initialization; dbn ( deep belief networks ) corresponds to stacked rbm pretraining; sae stacked autoencoder pretraining; sdae stacked denoising autoencoder pretraining .
in all cases , the same supervised ne - tuning procedure was then used , that is , simple stochastic gradient descent with early stopping based on validation set performance .
data set description
mnist standard mnist digit classi -
basic smaller subset of mnist .
rot mnist digits with added
bg - rand mnist digits with random
bg - img mnist digits with random
bg - img - rot mnist digits with rotation
and image background .
rect discriminate between tall and wide rectangles ( white
rect - img discriminate between tall and wide rectangular image overlayed on a different
convex discriminate between con -
vex and concave shape .
tzanetakis classify genre of thirty sec -
123 - fold cross valida - tion on 123 training
table 123 : data sets .
characteristics of the 123 different problems considered .
except for tzane - takis whose input is made of 123 mpc features extracted from short audio sequences , all other problems are 123 123 gray - scale image classication tasks ( i . e . , input dimension - ality is 123 123 = 123 ) .
see larochelle et al .
( 123 ) and bergstra ( 123 ) for further details on these data sets .
the table gives , for each task , its shorthand name , a description of the problem , a description of input preprocessing , the number of classes ( m ) , and the number of examples used for the training , validation and test sets respectively .
vincent , larochelle , lajoie , bengio and manzagol
( a ) rot , bg - rand , bg - img , bg - img - rot
( b ) rect , rect - img , convex
figure 123 : samples form the various image classication problems .
( a ) : harder variations on the
mnist digit classication problems .
( b ) : articial binary classication problems .
on the 123 123 gray - scale image problems , sae and sdae used linear+sigmoid decoder layers and were trained using a cross - entropy loss , due to this being a natural choice for this kind of ( near ) binary images , as well as being functionally closer to rbm pretraining we wanted to compare
however for training the rst layer on the tzanetakis problem , that is , for reconstructing mpc coefcients , a linear decoder and a squared reconstruction cost were deemed more appropriate ( sub - sequent layers used sigmoid cross entropy as before ) .
similarly the rst layer rbm used in pre - training a dbn on tzanetakis was dened with a gaussian visible layer .
table 123 lists the hyperparameters that had to be tuned by proper model selection ( based on validation set performance ) .
note that to reduce the choice space , we restricted ourselves to the same number of hidden units , the same noise level , and the same learning rate for all hidden layers .
123 empirical comparison of deep network training strategies
table 123 reports the classication performance obtained on all data sets using a 123 hidden layer neural network pretrained with the three different strategies : by stacking denoising autoencoders ( sdae - 123 ) , stacking restricted boltzmann machines ( dbn - 123 ) , and stacking regular autoencoders ( sae - 123 ) .
for reference the table also contains the performance obtained by a single hidden - layer dbn - 123 and by a support vector machine with a rbf kernel ( svmrbf ) . 123
svms were trained using the libsvm implementation .
their hyperparameters ( c and kernel width ) were tuned semi -
automatically ( i . e . , by human guided grid - search ) , searching for the best performer on the validation set .
stacked denoising autoencoders
number of hidden layers number of units per hidden layer ( same for all layers )
lrate xed learning rate for unsuper -
lratesup xed learning rate for supervised
number of pretraining epochs through the whole corrupting noise level
( 123 123 , 123 123 , 123 123 , 123 123 , 123 123 , 123 )
( 123 , 123 , 123 , 123 ) ( 123 , 123 , 123 , 123 , 123 , 123 )
table 123 : list of hyperparameters for deep networks .
these hyperparameters are common to all considered deep network training strategies , except for noise level n which is specic to sdae ( for which we must also choose the kind of corruption ) .
we list the typical values we considered in the majority of our experiments .
best performing conguration on the validation set was always searched for in a semi - automatic fashion , that is , running experiments in parallel on a large computation cluster , but with manual guidance to avoid wasting resources on unnecessary parts of the conguration space .
some experiments meant to study more closely the inuence of specic hyperparameters occasionally used a ner search grid for them , as will be specied in the description of these experiments .
in these experiments , sdae used a zero - masking corruption noise for all problems except for tzanetakis , for which a gaussian noise was deemed more appropriate due to the nature of the input .
we see that sdae - 123 systematically outperforms the baseline svm , as well as sae - 123 ( except for convex for which the difference is not statistically signicant ) .
this shows clearly that de - noising pretraining with a non - zero noise level is a better strategy than pretraining with regular autoencoders .
for all but one problem , sdae - 123 is either the best performing algorithm or has its condence interval overlap with that of the winning algorithm ( i . e . , difference cannot be considered statistically signicant ) .
in most cases , stacking 123 layers of denoising autoencoder seems to be on par or better than stacking 123 layers of rbms in dbn - 123
in the following subsections , we will be conducting further detailed experiments to shed light
on particular aspects of the denoising autoencoder pretraining strategy .
123 inuence of number of layers , hidden units per layer , and noise level
next we wanted to study more closely the inuence of important architectural hyperparameters , namely the number of layers , the number of hidden units per layer , and the noise level .
for this ner
vincent , larochelle , lajoie , bengio and manzagol
sdae - 123 ( n )
table 123 : comparison of stacked denoising autoencoders ( sdae - 123 ) with other models .
test error rate on all considered classication problems is reported together with a 123% condence interval .
best performer is in bold , as well as those for which condence intervals overlap .
sdae - 123 appears to achieve performance superior or equivalent to the best other model on all problems except bg - rand .
for sdae - 123 , we also indicate the fraction n of corrupted input components , or in case of tzanetakis , the standard deviation of the gaussian noise , as chosen by proper model selection .
note that sae - 123 is equivalent to sdae - 123 with n = 123% .
grained series of experiments , we chose to concentrate on the hardest of the considered problems , that is , the one with the most factors of variation : bg - img - rot .
we rst examine how the proposed network training strategy behaves as we increase the capacity of the model both in breadth ( number of neurons per layer ) and in depth ( number of hidden layers ) .
figure 123 shows the evolution of the performance as we increase the number of hidden layers from 123 to 123 , for three different network training strategies : without any pretraining ( standard mlp ) , with ordinary autoencoder pretraining ( sae ) and with denoising autoencoder pretraining ( sdae ) .
we clearly see a strict ordering : denoising pretraining being better than autoencoder pretraining being better than no pretraining .
the advantage appears to increase with the number of layers ( note that without pretraining it seems impossible to successfully train a 123 hidden layer network ) and with the number of hidden units .
this general behavior is a typical illustration of what is gained by pretraining deep networks with a good unsupervised criterion , and appears to be common to several pretraining strategies .
we refer the reader to erhan et al .
( 123 ) for an empirical study and discussion regarding possible explanations for the phenomenon , centered on the observation of regularization effects ( we exploit the hypothesis that features of x that help to capture p ( x ) also help to capture p ( y|x ) ) and optimization effects ( unsupervised pre - training initializes parameters near a better local minimum of generalization error ) .
notice that in tuning the hyperparameters for all classication performances so far reported , we considered only a coarse choice of noise levels n ( namely 123% , 123% , 123% , or 123% of zero - masking corruption for the image classication problems ) .
clearly it was not necessary to pick the noise level very precisely to obtain good performances .
in figure 123 we examine in more details the inuence of the level of corruption n using a more ne - grained grid for problem bg - img - rot
stacked denoising autoencoders
figure 123 : classication performance on bg - img - rot for standard mlp with random initialization ( nopretrain , left ) , sae ( middle ) , and sdae ( right ) , as we increase the number of hid - den layers and the number of neurons per layer .
error bars show 123% condence in - tervals .
note that without pretraining the curve for 123 layers is outside the graphic , the classication error being above 123% .
notice that sdae appears to perform better than sae ( 123 noise ) for a rather wide range of noise levels , regardless of the number of hidden layers .
the following section reports an experiment that was conducted on three other data sets .
the ex - periment had a different goal and thus used a coarser n grid , but the resulting curves ( see figure 123 ) appear to follow a similar pattern to the one seen here ( figure 123 ) .
123 denoising pretraining vs .
training with noisy input
we discussed in section 123 the important distinction between denoising pretraining as it is done in sdae and simply training with noisy inputs .
sdae uses a denoising criterion to learn good initial feature extractors at each layer that will be used as initialization for a noiseless supervised training .
this is very different from training with noisy inputs , which amounts to training with a ( virtually ) expanded data set .
this latter approach can in principle be applied to any classier , such as an svm123 or a sae .
note that in the case of the sae , since there are two phases ( pretraining and ne - tuning ) , it is possible to use noisy inputs for only the pretraining or for both the pretraining
for sae , input examples can cheaply be corrupted on the y , but this is not an option with standard svm algorithms .
so for svm training we rst augmented the training set by generating 123 extra variations of each original training example thus yielding a training set 123 times bigger than the original .
alternatively , we could instead have used the
vincent , larochelle , lajoie , bengio and manzagol
figure 123 : sensitivity to the level of corruption .
the curves report the test error rate for sdae trained on problem bg - img - rot as a function of the fraction n of corrupted input compo - nents ( using zero masking noise ) .
error bars show 123% condence interval .
note that 123% corruption corresponds to a sae ( regular autoencoder ) .
and ne - tuning phase .
we experimentally compare these different approaches on three data sets in figure 123
we see that denoising pretraining with sdae , for a large range of noise levels , yields signicantly improved performance , whereas training with noisy inputs sometimes degrades the performance , and sometimes improves it slightly but is clearly less benecial than sdae .
123 variations on the denoising autoencoder : alternate corruption types and emphasizing
in the next series of experiments , we wanted to evaluate quantitatively the effect of using the various corrupting noises described in section 123 as well as the emphasized denoising autoencoder variant described in section 123 .
extensive experiments were carried out on the same 123 problems we used in the previous section .
besides zero - masking noise ( mn ) we trained 123 hidden layer sdae using salt - and - pepper noise ( sp ) and additive gaussian noise ( gs ) .
for mn and sp , we also tried the emphasized variant . 123 for each considered variant , hyperparameters were selected as usual to yield the best performance on the
virtual sv technique ( scholkopf et al . , 123 ) , which may or may not have yielded better performance , but since our main focus here is comparing noisy sae with sdae , svm only serves as a simple baseline .
as already mentioned previously , since gaussian noise corrupts every dimension , emphasized denoising does not
make sense for this type of corruption .
stacked denoising autoencoders
figure 123 : sdae vs .
training with noisy input .
the test error of a sdae with 123 hidden layers is compared to other algorithms trained with noisy inputs : a svm with rbf kernel ( svmrbf ) , a 123 - hidden - layers sae where noisy inputs were used for pretraining only ( sae ( 123 ) ) and one where noisy inputs were used both for pretraining and supervised ne - tuning ( sae ( 123 ) ) .
hidden layers have 123 neurons each .
zero - masking noise was used .
note that at 123% noise , the three stacked models correspond to an ordinary sae .
error bars show 123% condence interval .
denoising pretraining with sdae appears to always yield signicantly better performance , unlike training with noisy inputs .
vincent , larochelle , lajoie , bengio and manzagol
sdae - 123mn ( n ) + emph 123 . 123 ( 123% ) sdae - 123sp ( n ) + emph
table 123 : variations on 123 - hidden - layer stacked denoising autoencoders ( sdae - 123 ) : alternative noise types and effect of emphasis .
considered noise types are masking noise ( mn ) , salt - and - pepper ( sp ) and gaussian noise ( gs ) .
emphasized version considered double emphasis and full emphasis ( see main text for detailed explanation ) .
for easy comparison , the table also reproduces previously shown results for svmrbf , sae - 123 , and dbn - 123
test error rate is reported together with a 123% condence interval .
best performer is in bold , as well as those for which condence intervals overlap .
corruption level n ( fraction of corrupted input components or gaussian standard deviation ) that was retained by model selection on the validation set is specied in parenthesis .
sdae - 123sp with emphasis on reconstruction of corrupted dimension appears to be the best sdae variant for these data sets , signicantly improving performance on rot and bg - rand .
validation set .
these included the number of units per layer ( same for all layers ) , the corruption ( fraction of corrupted dimensions for mn and sp , or standard deviation for gs ) , with the usual considered values ( listed previously in table 123 ) .
for the emphasized version , a further hy - perparameter was the degree of emphasis .
we considered both double emphasis , where the weight on the reconstruction of the corrupted components is twice that on the uncorrupted components ( a = 123 , b = 123 ) , and full emphasis where all the weight is on reconstructing the corrupted compo - nents and none on the uncorrupted dimensions ( a = 123 , b = 123 ) .
table 123 reports the corresponding classication performance on the held - out test set .
for the three considered data sets , an empha - sized sdae with salt - and - pepper noise appears to be the winning sdae variant .
it thus appears that a judicious choice of noise type and added emphasis may often buy us a better performance .
however we had hoped , with these variants , to catch up with the performance of dbn - 123 on the bg - rand problem , 123 but dbn - 123 still performs signicantly better than the best sdae variant on this
123 are features learnt in an unsupervised fashion by sdae useful for svms ?
in the following series of experiments , we wanted to verify whether the higher level representations extracted using sdae could improve the performance of learning algorithms other than a neural network , such as svms .
as discussed in larochelle et al .
( 123 ) , bg - rand is particularly favorable to rbms because the pixel - wise indepen -
dent noise perfectly matches what an rbm expects and will naturally not be represented in the hidden units .
stacked denoising autoencoders
to this end , we fed the representations learnt by the purely unsupervised phase of sdae , at increasing higher levels ( rst , second and third hidden layer ) to both a linear svm and a kernel svm ( using a rbf kernel ) .
the hyperparameters of the svm and its kernel were tuned on the validation set as usual .
for computational reasons , we did not re - tune sdae hyperparameters .
instead , we identied the best performing sdae - pretrained neural networks with 123 units per layer , based on their validation performance after ne - tuning from previous experiments , but used their saved weights prior to ne - tuning ( i . e . , after unsupervised denoising training only ) .
results for all considered data sets are reported in table 123 , and figure 123 highlights performance curves for two of them .
clearly , svm performance can benet signicantly from using the higher level representation learnt by sdae . 123 on all problems we see improved performance compared to using the original input ( svm123 ) .
more interestingly , on most problems , svm performance im - proves steadily as we use ever higher level representations .
while it is not too surprising that linear svms can benet from having the original input processed non - linearly , it is noteworthy that rbf kernel svms , which are high - capacity non - linear classiers , also seem to benet greatly from the non - linear mapping learned by sdae .
figure 123 : svm on representations learnt by sdae .
the curves show evolution , on two data sets , of the test performance of linear and rbf kernel svms as we train them on higher level representations learnt in the unsupervised phase of sdae .
performance of sdae after supervised ne - tuning is also shown as sdaemn ( mn stands for masking noise ) .
hidden layer 123 corresponds to original input representation .
generating samples from stacked denoising autoencoder networks
besides the classication performance comparisons and qualitative visual inspection of learnt lters , it is also customary in studies of deep generative models such as dbns , to show samples generated
to verify that the learnt representation was responsible for the improved performance , rather than a random non - linear transformation , we also trained svms on the representation of the same neural network architecture but using randomly initialized weights : the performance degraded as we used the higher level representations .
vincent , larochelle , lajoie , bengio and manzagol
table 123 : svm performance on higher level representations learnt by sdae .
performance of both linear svm , and svm with rbf kernel is reported , as they are trained on either original input ( svm123 ) , or on the representation learnt by a sdae at the level of its rst ( svm123 ) , second ( svm123 ) , or third ( svm123 ) hidden layer .
the representations used for the svms were those obtained prior to ne - tuning .
test error rate on all considered classication problems is reported together with a 123% condence interval .
best performer is in bold , as well as those for which condence intervals overlap .
clearly both linear and kernel svm performance benet from using the higher level representations learnt by sdae .
for most problems the performance increases steadily as we use representations from ever higher levels of the architecture .
from the trained models .
this can yield another qualitative visual assessment of whether they were able to capture the input distribution well .
123 top - down generation of a visible sample given a top - layer representation
given a top - layer representation , a deep belief network ( hinton et al . , 123 ) is a directed graphical model , and it is easy to do a top down sampling pass , that is , sampling each layer conditioned on the layer above , to eventually produce a sample in the bottom layer that can be displayed .
more precisely , in sigmoid deep belief networks ( dbn ) , the representation at a lower layer x given the
stacked denoising autoencoders
layer above y is distributed according to a product of independent bernoullis whose mean is a deterministic function of y , that is , x|y b ( gq has the exact same form as that given in equation 123 for the decoder part of an autoencoder .
from a trained sae or sdae123 it is thus possible to generate samples at one layer from the representation of the layer above in the exact same way as in a dbn .
( y ) ) , where gq
123 bottom - up inferring of the top - layer representation corresponding to a given input
in sae / sdae , given an input representation at the bottom layer , the corresponding representation in the top layer is computed in a deterministic bottom - up pass using encoding functions fq .
the same procedure is used in dbns and , in the graphical model perspective , can be viewed as an approximate inference of a factorial bernoulli top - layer distribution given the low level input .
this top - layer representation is to be understood as the parameters ( the mean ) of a factorial bernoulli distribution for the actual binary units .
123 generating samples with sae , sdae , and dbn using the same procedure
the deep belief network of hinton et al .
( 123 ) is a fully specied generative model .
in particular the joint distribution of its top two layers is dened by an rbm model , 123 , that is , an undirected graphical model from which one can efciently sample using alternating gibbs sampling ( hinton et al . , 123 ) .
so to sample from a dbn model , one would rst sample from the top - layer rbm using alternating gibbs sampling .
then , given the thus obtained top - layer representation , perform the single top down sampling pass previously described to produce a visible pattern at the bottom
by contrast , sae / sdae training does not attempt to model the distribution of the top - layer representation .
so even thoughgiven a top - layer representationwe can use the exact same top down sampling procedure to generate input patterns from a sae / sdae as for a dbn , sae / sdae cannot by themselves alone be treated as fully specied generative models .
they lack a model of the marginal distribution of their top layer .
we can easily x this by modeling that top - layer distribution non - parametrically by the simple memory - based empirical distribution of the encoded top - layer representations of the n training set patterns .
a visible sample can then be generated by simply taking the top - layer encoded represen - tation of a randomly picked training set input , and carrying out the top - down sampling procedure explained previously , as illustrated in figure 123
this same technique can also be used as an alter - native sample - generation procedure for dbns built by stacking rbms .
if we keep the same xed input pattern , and hence the same corresponding higher level rep - resentation , and perform several top - down samplings , we can thus observe what kind of pattern variations the deep multilayer part of a deep network has learnt to model ( or abstract away in ex - tracting the top - layer representation ) .
figure 123 shows the resulting variability in the regenerated patterns , for models pretrained respectively as sae , sdae123 and dbn on mnist without any su -
sae and sdae train such gq
to perform reconstruction , that is , predicting the mean value of a layer given the
representation in the layer immediately above it .
this rbm was trained , using the training set , to model the representations obtained at the layer just below the top
one , produced by the bottom - up pass we just described .
both were pretrained with salt - and - pepper noise .
vincent , larochelle , lajoie , bengio and manzagol
figure 123 : non - parametric sampling procedure for pretrained networks .
a randomly picked input form the original data set is provided as input .
its top level representation is obtained by deterministic bottom - up encoding using functions fq ( k ) .
a visible pattern is generated given this high level representation , by alternating bernoulli sampling and deterministic ( k ) ( previouslayer ) .
this same decoding , that is , by successively sampling from b ( gq procedure can be applied with sae , sdae and dbn .
it allows to see the quality and variability of patterns one obtains given a high - level representation .
pervised ne - tuning .
it appears that sdae and dbn are able to resynthesize a variety of similarly good quality digits , whereas the sae trained model regenerates patterns with much visible degra - dation in quality .
this is further evidence of the qualitative difference resulting from optimizing a denoising criterion instead of mere reconstruction criterion .
note how sdae puts back the miss - ing hole in the loop of the regenerated 123 , and sometimes straightens up the upper stroke of the 123 , suggesting that it did indeed capture interesting specic characteristics .
it appears that , when using this same sample generation procedure , sdae and dbn yield a similar degree of variability in the regenerated patterns ( with dbn patterns looking slightly fatter and sdae patterns slightly thinner ) .
neither dbn nor sdae guarantee that class boundaries will not be crossed , 123 for example dbn closes a loop in a 123 making it look closer to a 123 , whereas sdae sometimes breaks open the loop of an 123 making it look like a 123
but in all cases , and contrary to sae , the regenerated patterns look like they could be samples from the same unknown input distribution that yielded the training set .
conclusion and future work
the present work was inspired by recent successful approaches to training deep networks , specif - ically by their use of a local unsupervised criterion , and led by the question of what that crite - rion should be .
at the same time we were motivated by a desire to bridge a remaining perfor - mance gap between deep belief networks and the stacking of ordinary autoencoders ( bengio et al . , 123; larochelle et al . , 123a ) .
this led us to address a theoretical shortcoming of traditional autoencodersnamely their inability in principle to learn useful over - complete representationsin a simple yet original way : by changing the objective from one involving mere reconstruction to the more challenging task of denoising .
the resulting stacked denoising autoencoder algorithm
the reader should however keep in mind that this results from unsupervised training only .
stacked denoising autoencoders
figure 123 : variability of the samples generated with 123 - hidden - layer sae , sdae and dbn pre - trained models .
each sub - gure is to be read row - wise : the leftmost pattern in each row is a training set pattern .
following the sample generation depicted in figure 123 , it was provided as input to the network and its top - layer representation was computed by de - terministic bottom up encoding .
patterns to its right were then generated independently given that top level representation .
clearly , sdae trained networks , like dbns , are able to regenerate high quality samples from their high level representation , contrary to sae .
sdae and dbns also appear to give rise to a similar level of variability in the bottom - up generated patterns ( dbn patterns tending to be somewhat fatter ) .
note how sdae puts back the missing hole in the loop of the regenerated 123 , and sometimes straightens up the upper stroke of the last 123 , suggesting that it did indeed capture meaningful specic characteristics .
dbn and sdae generated patterns can easily pass for samples from the unknown input distribution being modeled , unlike patterns generated by sae .
vincent , larochelle , lajoie , bengio and manzagol
for training deep networks , proved indeed able to bridge the performance gap with dbns , yielding equivalent or better classication performance on all but one of the considered benchmark prob - lems .
as a deep network pretraining strategy , stacking of denoising autoencoders yielded in most cases a signicant improvement in performance over the stacking of ordinary autoencoders .
the representations thus extracted layer by layer , using a purely unsupervised local denoising criterion , appear to make subsequent classication tasks much easier .
this is further evidenced by the fact that state - of - the - art shallow classiers such as kernel svms also appear able to greatly benet from it .
close examination of the feature extractors learnt by denoising autoencoders showed that they were able to zero in on useful structure in the data ( such as gabor - like edge detectors on natural image patches ) that regular autoencoders seemed unable to learn .
the algorithm we developed is a straightforward , easy to implement , variation on the well - understood ordinary autoencoders .
all that remains to be chosen is the kind and level of corrupting noise .
it is likely that a careful choice , possibly guided by prior domain knowledge , may further boost application - specic performance .
nevertheless our experiments showed that high perfor - mance can already be achieved using very simple and generic noise types and with little tuning of the noise level .
in addition , we were able to show that , contrary to what it may seem on the sur - face based on popular myths , the denoising training we advocate is not equivalent to using a mere weight decay regularization , nor is it the same as direct supervised training with corrupted ( jittered )
beyond the specicities and practical usefulness of the simple algorithm we developed , our re - sults clearly establish the value of using a denoising criterion as an unsupervised objective to guide the learning of useful higher level representations .
this is in our view the most important contribution of our work , as it offers an interesting alternative to more usual ( and often intractable ) likelihood derived criteria .
indeed , denoising performance can easily be measured and directly op - timized .
the use of a denoising criterion is very different from the contrastive divergence training of rbms or the direct enforcing of sparsity in autoencoders .
we hope that our very encouraging results will inspire further research in this direction , both theoretical ( to better understand the rela - tionship between denoising and representation learning ) , and practical ( to develop better learning algorithms based on this understanding ) .
there are certainly better ways to use denoising - based training signals in the learning of a deep network than the simple local approach we explored here .
in particular , while stacking denoising autoencoders allows us to build a deep network , the denoising autoencoders we used here were shallow .
it would thus be interesting to investigate deep denoising autoencoders with several hidden layers , and their ability to form useful representations .
the choice and role of the corruption process also deserves further inquiry .
if more involved corruption processes than those explored here prove benecial , it would be most useful if they could be parameterized and learnt directly from the data , rather than having to be hand - engineered based on prior - knowledge .
this research was supported by funding from nserc , mitacs , fqrnt , cifar , and the canada research chairs , and partly carried out on computation resources made available by rqchp .
stacked denoising autoencoders
