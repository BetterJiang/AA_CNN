the world wide web is a vast source of information accessible to computers , but understandable only to humans .
the goal of the research described here is to auto - matically create a computer understandable knowledge base whose content mirrors that of the world wide web .
such a knowledge base would enable much more e ( cid : 123 ) ective retrieval of web information , and promote new uses of the web to sup - port knowledge - based inference and problem solving .
our approach is to develop a trainable information extraction system that takes two inputs .
the ( cid : 123 ) rst is an ontol - ogy that de ( cid : 123 ) nes the classes ( e . g . , company , person , employee , product ) and relations ( e . g . , employed by , produced by ) of interest when creating the knowledge base .
the second is a set of training data consisting of labeled regions of hypertext that repre - sent instances of these classes and relations .
given these inputs , the system learns to extract information from other pages and hyperlinks on the web .
this article describes our general approach , several machine learning algorithms for this task , and promising initial results with a prototype system that has created a knowledge base describing university people , courses , and research projects .
? this research has been supported in part by the darpa hpkb program under research contract f123 - 123 - 123 - 123
the views and conclusions contained in this document are those of the authors and should not be interpreted as representing the o ( cid : 123 ) cial policies , either expressed or implied , of darpa or the u . s .
government .
preprint submitted to arti ( cid : 123 ) cial intelligence
123 november 123
123 the opportunity
the rise of the world wide web has made it possible for your workstation to retrieve over 123 , 123 , 123 web pages for your personal perusal .
the web has already become one of the largest and most diverse sources of information on the planet , and many expect it to grow into the worlds primary knowledge resource over the next decade .
the research described here is motivated by a simple observation : although your workstation can currently retrieve over 123 , 123 , 123 web pages , it cur - rently understands none of these web pages .
the goal of our web ! kb re - search project is to automatically create a computer - understandable knowl - edge base whose content mirrors that of the world wide web .
such a \world wide knowledge base " would consist of computer understandable assertions in symbolic , probabilistic form ( e . g . , employed by ( mark craven , carnegie mellon univ ) , probability= . 123 ) .
we expect such a world wide knowledge base would have many uses .
at a minimum , it would allow much more e ( cid : 123 ) ective information retrieval by supporting queries such as \ ( cid : 123 ) nd all universities within 123 miles of pittsburgh that o ( cid : 123 ) er evening courses on java programming . " going a step further , it would enable new uses of the web to support knowledge - based infer - ence and problem solving .
for example , it would provide the knowledge base needed by a software travel agent that might handle requests such as \make me hotel and ight arrangements for the upcoming acm conference . " notice that information about the acm conference , nearby hotels , and ights is already available in human - readable form , spread across multiple text pages on the web .
a knowledge base that makes this information computer - understandable would support a variety of intelligent knowledge - based agents .
how might we construct and maintain such a world wide knowledge base ? the thesis explored in this article is that one can develop such a knowledge base by ( 123 ) using machine learning to create information extraction methods for each of the desired types of knowledge , then ( 123 ) applying these learned information extraction methods to extract symbolic , probabilistic statements directly from web hypertext .
each assertion in the knowledge base can therefore carry with it a justi ( cid : 123 ) cation , in terms of the web sources and information extraction method , that provide its evidential support .
as the web evolves over time , the knowledge base can be automatically updated to reect its changing content .
this article explores the above thesis by proposing and evaluating several learning algorithms relevant to this information extraction task , and by pre - senting the prototype web ! kb system which has successfully built a knowl - edge base containing several thousand assertions about computer science de - partments using these learned information extractors .
instructors_of : jim , tom
fundamentals of cs home page
jims home page
i teach several courses : fundamentals of cs intro to ai
my research includes intelligent web agents
human computer interaction
an overview of the web ! kb system .
the top part of the ( cid : 123 ) gure shows an ontology that de ( cid : 123 ) nes the classes and relations of interest .
each partial box repre - sents a class , and the arrows indicate specialization relationships .
the other de ( cid : 123 ) ned relations for each class are listed inside of its corresponding box .
the bottom part shows two web pages identi ( cid : 123 ) ed as training examples of the classes course and fac - ulty .
together , these two pages also constitute a training example for the relations instructors of and courses taught by .
given the ontology and a set of training data , web ! kb learns to interpret additional web pages and hyperlinks to add new instances to the knowledge base , such as those shown in the middle of the ( cid : 123 ) gure .
these instances are represented by dashed partial boxes .
the dashed lines show the relationships between the instances and their web sources .
we begin by briey surveying the capabilities of the web ! kb system in the next section .
the subsequent section considers in detail the representational assumptions underlying our approach .
the remaining sections present our experimental testbed , several learning algorithms and experimental results for the various information extraction tasks , related work , and conclusions .
123 overview of the web ! kb system
the web ! kb system is ( cid : 123 ) rst trained to extract information of the desired types , and is then allowed to browse new web sites in order to automatically populate a knowledge base with new assertions .
when training this system , the user must provide two inputs :
( 123 ) a speci ( cid : 123 ) cation of the classes and relations of interest .
this is the ontology that de ( cid : 123 ) nes the vocabulary for the target knowledge base .
an example of such an ontology is provided in the top half of figure 123
this par - ticular ontology de ( cid : 123 ) nes a hierarchy of classes including person , student , research project , course , etc .
it also de ( cid : 123 ) nes relations between these classes such as advisors of ( which relates an instance of a student to the instances of faculty who are the advisors of the given student ) .
this ontology , and optionally instances of some of the classes and relations , constitutes the initial version of the knowledge base .
( 123 ) training examples that describe instances of the ontology classes and relations .
for example , the two web pages shown at the bottom of figure 123 represent instances of course and faculty classes .
furthermore , this pair of pages represents an instance of the relation courses taught by ( i . e . , the courses taught by jim includes fundamentals - of - cs ) .
given such an ontology and a set of training examples , the web ! kb system learns general procedures for extracting new instances of these classes and relations from the web .
in the current prototype , this is accomplished by learning to classify arbitrary web pages and hyperlink paths according to the classes and relations de ( cid : 123 ) ned by the ontology .
when exploring the web , the web ! kb system starts from a given input url and explores pages using a breadth - ( cid : 123 ) rst search to follow links .
each explored page is examined , using learned class descriptions , to see if it represents a member of one of the ontology classes .
if a page is determined to be a class member , an entity representing that page is placed into the knowledge base , and the ontology relations for that page are instantiated based on learned rules and the local structure of the web around the page .
if a page is not a class member , the search is truncated , and links from this page are not followed .
in one such crawling experiment the system was given a training set of ap - proximately 123 , 123 web pages and 123 , 123 web - page pairs taken from the com - puter science department web sites at four universities ( cornell , university of texas at austin , university of washington , and university of wisconsin ) .
these training examples were hand labeled according to the ontology shown in figure 123
the system was then allowed to explore the web site of a ( cid : 123 ) fth computer science department ( at carnegie mellon university ) , and to add new knowledge base entries based on information extracted from this new web site .
name : " david garlan "
two of the entities automatically extracted from the cmu computer science department web site after training on four other university computer science sites .
these entities were added as new instances of faculty and project to the knowledge base shown in figure 123
the identi ( cid : 123 ) ers used to reference entities ( e . g . , david - garlan and able - project ) are automatically generated from the titles of the pages from which the entities are extracted .
class instance recogni tion accuracy when exploring cmu computer science de - partment web site , after training on computer science departments at four other
two new instances added by the system to its knowledge base , as a result of browsing this new university web site , are shown in figure 123
the top instance describes a new faculty added to the knowledge base , as a result of examining a web page that the system classi ( cid : 123 ) ed into this category .
as a result , the system created the new faculty instance in the knowledge base , and extracted several relations involving this instance .
for example , it de - termined ( correctly ) the name of this faculty member , a course taught by the faculty member , and three instances of the projects of relation for this faculty member : architectural - mismatch , cmu - cs - composable - software - systems - home - page , and able - project .
these three projects are themselves instances of the research project class , extracted from other web pages .
the description of one of these , the able - project , is shown at the bottom of the ( cid : 123 ) gure .
the identi ( cid : 123 ) ers used to reference these instances are automatically generated from the titles of the pages from which the instances are extracted .
how accurate is the system in extracting such information ? in this experiment , the system visited 123 web pages at the new carnegie mellon site , and as
instructors of members of project
department of overall
relation instance recognition accuracy when exploring cmu computer science de - partment web site , after training on computer science departments at four other a result added 123 new class instances to its knowledge base .
the fraction of correctly extracted instances is summarized in table 123
for example , this table indicates that the system created 123 new knowledge base instances of the class course .
of these 123 new instances , 123 in fact represented courses and the other 123 did not .
its accuracy 123 in extracting relation instances is summarized in a similar fashion in table 123
note that since we dont have a labelling for all the pages and relations at carnegie mellon , we have no way of calculating coverage results for these tasks .
figure 123 shows the information displayed by the system as it browses .
note this display shows the web page that is currently being visited ( top right ) , and the information extracted by the system from this web page ( middle left ) .
the interface also contains a control panel that allows the user to interact with the system ( top left ) , and to browse the growing knowledge base ( bottom right ) .
123 problem formulation
as summarized in the previous section , the web ! kb system provides exper - imental support for our thesis that a system can be trained to automatically populate a knowledge base by browsing web hypertext .
later sections describe in detail the learning algorithms used by this web ! kb system .
in this sec - tion , we consider the precise problem formulation and the representational assumptions that underlie our current approach .
to summarize , we are interested in the following general problem :
( cid : 123 ) a knowledge base consisting of an ontology de ( cid : 123 ) ning the classes ( e . g . , per - son ) and relations ( e . g . , instructor of ) of interest , and optionally , instances
123 throughout the article , when we refer to accuracy on a per - class basis , it is equivalent to the precision measure commonly used in the information - retrieval community .
similarly , when we refer to coverage on a per - class basis , it is equivalent to the recall measure .
the web interface to the web ! kb system .
the upper left pane serves as a control panel .
the middle left pane describes the current activity of the web ! kb system , and the lower left pane summarizes the session .
the upper right pane shows the page currently being processed , and the lower right pane provides a mechanism for browsing the extracted knowledge base .
of some of these classes and relations , ( cid : 123 ) training examples from the web that describe instances of these classes ( cid : 123 ) general procedures capable of extracting additional instances of these classes and relations by browsing the rest of the web .
note that we do not necessarily extract new instances for all of the classes and
relations in the ontology .
for example , our ontology may have a class country and the initial knowledge base may include instances for all of the countries in the world .
in this case , since we already know all instances , we do not need to learn procedures to recognize new ones .
to pursue the problem of learning to extract instances from the web , we must make some assumptions about the types of knowledge to be extracted from the web , and the way in which this knowledge is represented in hypertext on the web .
these assumption are : ( cid : 123 ) assumptions about how class instances are described on the web .
we as - sume that each instance of an ontology class is represented by one or more segments of hypertext on the web .
by segment of hypertext , we mean either a single web page , or a contiguous string of text within a web page , or a rooted graph of several web pages linked by the directed edges of hyper - links .
for example , an instance of a person might be described by a single page ( the persons home page ) , or by a reference to the person in a string of text within an arbitrary web page , or by a collection of interconnected web pages that jointly describe the person .
( cid : 123 ) assumptions about how relation instances are described on the web .
con - sider an arbitrary instance r ( a , b ) of a relation r .
we assume that each in - stance of a relation is represented on the web in one of three ways .
first , the instance r ( a , b ) may be represented by an undirected path of hyperlinks and pages that connects the segment representing a to the segment representing b .
for example , the bottom of figure 123 shows two hyperlinks that connect the segment representing jim to the segment representing fundamentals - of - cs .
these hyperlinks represent the relation instructor of ( fundamentals - of - cs , jim ) .
second , the instance r ( a , b ) may alternatively be represented by a seg - ment of text representing a that contains the segment that represents b .
for example , the relation instance courses taught by ( jim , introduction - to - ai ) is represented in figure 123 by the fact that jims home page contains the phrase \intro to ai " in a particular context .
finally , the instance r ( a , b ) may be represented by the fact that the hypertext segment for a satis ( cid : 123 ) es some learned model for relatedness to b .
for example , we might extract the instance research area of ( jim , arti ( cid : 123 ) cial - intelligence ) by classifying jims page using a statistical model of the words typically found in pages describing
appendix a provides a more formal presentation of these assumptions .
in addition to these assumptions about the mapping between web hypertext and the ontology , we make several simplifying assumptions in our initial research reported in this article .
we plan to relax the following assumptions in the future as our research progresses .
( cid : 123 ) we assume in this article that each class instance is represented by a single
web page ( e . g . , a person is represented by their home page ) .
if an instance happens to be described by multiple pages ( e . g . , if a person is described by their home page plus a collection of neighboring pages describing their publications , hobbies , etc . ) , our current system is trained to classify only the primary home page as the description of the person , and to ignore the neighboring a ( cid : 123 ) liated pages .
alternatively , if an instance happens to be described by a text fragment , our system does not currently create a knowledge base instance for this .
it does , however , extract certain relation values from such text fragments ( e . g . , the name of the person , as illustrated in figure 123 ) .
( cid : 123 ) we assume that each class instance is represented by a single segment of hypertext .
in other words , if the system encounters two unlinked web pages that represent instances of the same class , it creates two distinct instances of this class in its knowledge base .
while this assumption will often be satis ( cid : 123 ) ed ( e . g . , two distinct personal home pages typically represent two distinct peo - ple ) , there are clearly exceptions ( e . g . , there are many di ( cid : 123 ) erent web pages describing elvis ) .
overcoming this \multiple elvis problem " will require methods that hypothesize equivalences between independently discovered ( cid : 123 ) we assume that all relations are two - place relations; that is , each relation has only two arguments .
we believe that it will be fairly easy to relax this
given this problem de ( cid : 123 ) nition and our current set of assumptions , we view the following as the three primary learning tasks that are involved in extracting knowledge - base instances from the web :
( 123 ) recognizing class instances by classifying bodies of hypertext .
section 123 looks at this problem , using both statistical and relational learning tech - niques .
it also examines how to relax our assumption about class instances being represented by single web pages .
( 123 ) recognizing relation instances by classifying chains of hyperlinks
tion 123 investigates a relational learning solution to this problem .
( 123 ) recognizing class and relation instances by extracting small ( cid : 123 ) elds of text from web pages .
section 123 looks at this task and also uses a relational
123 experimental testbed
all experiments reported in this article are based on the ontology for computer science departments shown in figure 123
this ontology includes the classes de - partment , faculty , sta ( cid : 123 ) , student , research project , and course .
our web page classi ( cid : 123 ) cation experiments also use the class other as the label for web pages
that fall into none of these ontology classes .
each ontology class has an asso - ciated set of slots , or relations , that exist among instances of this class and other class instances in the ontology .
for example , the course class has a slot called instructors of that relates courses to people .
we assembled two data sets 123 for the experiments reported here .
the ( cid : 123 ) rst is a set of pages and hyperlinks drawn from four cs departments : university of texas at austin , cornell university , university of washington , and university of wisconsin .
the second is a set of pages from numerous other computer science departments .
the four - department set includes 123 , 123 pages and 123 , 123 hyperlinks interconnecting them .
the second set includes 123 , 123 additional pages .
the pages for most of the classes in our data set were collected using \index " pages for our classes of interest ( e . g . , a page that has hyperlinks to all of the students in a department ) , so labeling this data was straightforward .
after gathering this initial set of pages , we then collected every page that was both ( i ) pointed to by a hyperlink in the initial set , and ( ii ) from the same university as the page pointing to it .
most of the pages gathered in the second step were labeled as other .
in addition to labeling pages , we also labeled relation instances .
each of these relation instances consists of a pair of pages corresponding to the class instances involved in the relation .
for example , an instance of the instruc - tors of relation consists of a course home page and a person home page .
our data set of relation instances comprises 123 instructors of instances , 123 mem - bers of project instances , and 123 members of department instances .
these in - stances are all from the four - department set .
finally , we also labeled the name of the owner of pages in the person class .
this was done automatically by tagging any text fragment in the persons home page that matched the name as it appeared in the hyperlink pointing to the page from the index page .
the matching heuristics were conservative , favoring precision over recall .
consequently , we believe that , although some name occurrences were missed , there were no false positives .
from 123 person pages , this procedure yielded 123 distinct name occurrences .
these instances are all from the four - department set as well .
for all of the subsequent experiments in this article , we use a four - fold cross - validation methodology to evaluate our algorithms .
we conduct four runs in which we train classi ( cid : 123 ) ers using data from three of the universities in our data set ( plus the second set of pages where applicable ) , and test the classi ( cid : 123 ) ers using data from the remaining university .
on each iteration we hold out a di ( cid : 123 ) erent university for the test set .
123 these data sets are publicly available at http : / / www . cs . cmu . edu / ~ webkb / .
123 learning to recognize class instances
the ( cid : 123 ) rst task for our system is to identify new instances of ontology classes from the text sources on the web .
in this section we address the case in which class instances are represented by web pages; for example , a given instance of the student class is represented by the students home page .
in the ( cid : 123 ) rst part of this section we discuss a statistical bag ( of ( words approach to classifying web pages .
we use this method along with three di ( cid : 123 ) erent repre - sentations of pages .
in the second part of this section we discuss learning ( cid : 123 ) rst - order rules to classify web pages .
an appealing aspect of the second approach is that ( cid : 123 ) rst - order rules can describe page classes using a rich description of the local graph structure around the page .
finally , we evaluate the e ( cid : 123 ) ectiveness of combining the predictions made by all four of these classi ( cid : 123 ) ers .
123 statistical text classi ( cid : 123 ) cation
in this section we consider classifying web pages using statistical methods .
our approach is similar to a growing body of work in text classi ( cid : 123 ) cation that involves using a so - called bag of words or unigram representation .
however , we apply our method in novel ways that take advantage of the redundancy of hy - pertext .
speci ( cid : 123 ) cally , we train three independent classi ( cid : 123 ) ers which use di ( cid : 123 ) erent representations for page classi ( cid : 123 ) cation : ( cid : 123 ) full - text : the words that occur anywhere in the page , ( cid : 123 ) title / heading : the words that occur in the title and html headings of the ( cid : 123 ) hyperlink : the words that occur in hyperlinks ( i . e . , the words in the anchor
text ) that point to the page .
our approach involves building a probabilistic model of each class using la - beled training data , and then classifying newly seen pages by selecting the class that is most probable given the evidence of words describing the new
the method that we use for classifying web pages is naive bayes , with minor modi ( cid : 123 ) cations based on kullback - leibler divergence .
given a document d to
classify , we calculate a score for each class c as follows :
that a randomly drawn word from a randomly drawn document in class c will
where n is the number of words in d , t is the size of the vocabulary , and wi is the ith word in the vocabulary .
p r ( wijc ) thus represents the probability be the word wi .
p r ( wijd ) represents the proportion of words in document d that are word wi .
the class predicted by the method for a given document is simply the class with the greatest score .
this method makes exactly the same classi ( cid : 123 ) cations as naive bayes , but produces classi ( cid : 123 ) cation scores that are less extreme .
below we explain naive bayes; in appendix b we detail our modi ( cid : 123 ) cations to it .
the probabilistic models we use ignore the sequence in which the words occur .
such models are often called unigram or bag - of - words models because they are based on statistics about single words in isolation .
since the unigram model naively assumes that the presence of each word in a document is conditionally independent of all other words in the the docu - ment given its class , this approach , when used with bayes rule is often called naive bayes .
the conditional independence assumption is clearly violated in real - world data , however , despite these violations , empirically the naive bayes classi ( cid : 123 ) er does a good job of classifying text documents ( 123 , 123 , 123 , 123 ) .
this ob - servation is in part explained by the fact that classi ( cid : 123 ) cation estimation is only a function of the sign ( in binary cases ) of the function estimation ( 123 , 123 ) .
the word independence assumption causes naive bayes to give extreme ( almost 123 or 123 ) class probability estimates .
however , these estimates can still be poor while classi ( cid : 123 ) cation accuracy remains high .
there are two common approaches to naive bayes text classi ( cid : 123 ) cation .
one , the multi - variate bernoulli model , is a bayesian network with no dependencies between words and binary word counts; the document is considered to be the \event " and each feature is a boolean variable indicating the presence or absence of a particular word in that document .
the other approach , the multinomial model , is a unigram language model with integer word counts; the words are considered to \events " and the document is comprised of a collection of these events .
we use the second approach , since it has been found to out - perform the ( cid : 123 ) rst on several data sets ( 123 ) .
we formulate naive bayes for text classi ( cid : 123 ) cation as follows .
given a set of
classes c = fc123; : : : cng and a document consisting of n words , ( w123; w123; : : : wn ) ,
we classify the document as a member of the class , c ? , that is most probable , given the words in the document :
c ? = argmaxc pr ( cjw123; : : : ; wn ) :
we transform pr ( cjw123; : : : ; wn ) into a computable expression by applying bayes
rule ( eq .
123 ) ; rewriting the expression using the product rule and dropping the denominator , since this term is a constant across all classes , ( eq .
123 ) ; and assuming that words are independent of each other ( eq
pr ( cjw123; : : : ; wn ) =
pr ( c ) pr ( w123; : : : ; wnjc )
pr ( w123; : : : ; wn )
pr ( wijc; w123; : : : ; wi123 )
the modi ( cid : 123 ) cations that transform this traditional formulation of naive bayes into the form we use ( shown in equation 123 ) are described in appendix b .
estimating word probabilities
a key step in implementing naive bayes is estimating the word probabili -
ties , pr ( wijc ) .
to make our probability estimates more robust with respect
to infrequently encountered words , we use a smoothing method to modify the probabilities that would have been obtained by simple event counting .
one important e ( cid : 123 ) ect of smoothing is that it avoids assigning probability values of zero to words that do not occur in the training data for a particular class .
since naive bayes involves taking a product of word probabilities , a single zero for a class would prevent that class from being the maximum even if there are many other words that strongly indicate that class .
rather than smoothing with the common laplace estimates ( i . e . , adding one to all the word counts for a class ) , we use witten - bell smoothing ( 123 ) , which we have found to per - form better in some cases , particularly when the amount of training data in each class di ( cid : 123 ) ers dramatically .
witten - bell di ( cid : 123 ) ers from laplace smoothing in that it strength of the prior depends on the relationship between the number of unique words and the total number of word occurrences in the training data for the class; if most of the word occurences are unique words , the prior is stronger , if words are often repeated , the prior is weaker .
more precisely
witten - bell sets pr ( wijc ) as follows :
j n ( wj;c )
if n ( wi; c ) 123= 123 if n ( wi; c ) = 123
where n ( wi; c ) is the count of the number of times word wi occurs in the training data for class c , tc is the total number of unique words in class c , and t is the total number of unique words across all classes .
note that if we set t and tc to zero , ( and de ( cid : 123 ) ne 123=123 = 123 ) , we obtain the standard maximum likelihood estimates for pr ( wijc ) .
another important implementation issue is deciding upon the vocabulary size to be used for the problem domain .
we have found empirically that we get slightly more accurate classi ( cid : 123 ) cations when using a restricted vocabulary size .
thus we limit our vocabulary to 123 words in all of our experiments .
the vocabulary is selected by ranking words according to their average mutual information with respect to the class labels ( 123 ) .
we write wi for a random variable indicating whether word wi is present or absent in a document , and write vi 123 fwi; : wig for the values it takes on .
we write c for a random variable taking values of all the class labels , c 123 c .
then , average mutual
i ( c; wi ) = h ( c ) h ( cjwi )
pr ( c; vi ) log
this feature selection method has been found to perform best among sev - eral alternatives ( 123 ) , and has been used in many text classi ( cid : 123 ) cation studies
123 . 123 experimental evaluation
we evaluate our method using the data sets and cross - validation methodology described in section 123
on each iteration of the cross - validation run , we train a classi ( cid : 123 ) er for each of the page representations described at the beginning of
a confusion matrix showing the results of classifying web pages using the full - text classi ( cid : 123 ) er .
results are combined across all of the four - university test runs .
the overall coverage and accuracy are also shown .
this section : full - text , title / heading , and hyperlink .
table 123 shows the resulting confusion matrix ( summed over the four test sets ) for the full - text classi ( cid : 123 ) ers .
each column of the matrix represents one class and shows how the instances of this class are classi ( cid : 123 ) ed .
each row represents the instances that are predicted to belong to a given class , and shows the true classes of these instances .
this table illustrates several interesting results .
first , note that for most classes , coverage is quite high .
for example , 123% of the course and 123% of the faculty instances are correctly classi ( cid : 123 ) ed .
the notable exception to this trend is the other class; only 123% of the instances belonging to this class are correctly classi ( cid : 123 ) ed .
we discuss this result in more detail below .
a second interesting result is that many of the remaining mistakes made by the classi ( cid : 123 ) ers involve confusing di ( cid : 123 ) erent subclasses of person .
for example , although only 123% of the sta ( cid : 123 ) instances are correctly assigned to the sta ( cid : 123 ) category , 123% of them are correct at the superclass level of person .
as this result suggests , not all mistakes are equally harmful; even when we fail to correctly classify an instance into one of the leaf classes in our ontology , we can still make many correct inferences about the instance if we correctly assign it to a more general class .
the low level of classi ( cid : 123 ) cation accuracy for the other class is largely explained by the nature of this class .
recall from section 123 that the instances of this
class were collected by gathering pages that were one hyperlink away from the instances in the other six classes .
for this reason , many of the instances of the other class have content , and hence word statistics , very similar to instances in one of the \core " classes .
for example , whereas the home page for a course will belong to the course class , \secondary " pages for the course , such as a page describing reading assignments , will belong to the other class .
although the content of many of the pages in the other class might suggest that they properly belong in one of the core classes , our motivation for not including them in these classes is the following .
when our system is browsing the web and adding new instances to the knowledge base , we want to ensure that we do not add multiple instances that correspond to the same real - world object .
for example , we should not add two new instances to the knowledge base when we encounter a course home page and its secondary page listing the reading assignments .
because of this requirement , we have framed our page classi ( cid : 123 ) cation task as one of correctly recognizing the \primary " pages for the classes of interest .
as table 123 indicates , this is a very di ( cid : 123 ) cult task , but as we will show shortly , by combining several sources of evidence for each page , it is one we can perform with high accuracy .
one way to obtain insight into the learned classi ( cid : 123 ) ers is to ask which words contribute most highly to the quantity scorec ( d ) for each class .
to measure this , we used one of our training sets ( consisting of data from three of the four universities ) to calculate
for each word wi and class c .
figure 123 shows the ten words for each class that have the greatest value of this weighted log - odds ratio .
for space reasons , we do not show the words for the sta ( cid : 123 ) class .
as the table illustrates , most of the highly weighted words are intuitively prototypical for their class .
the excep - tions to this generalization are mostly from the other class which represents an extremely diverse set of pages .
another interesting result illustrated by this table is that many words which are conventionally included in stop lists 123 are highly weighted by our models .
for example , the words my , me , and am are typical stop - list words but they are among the top ten words for the student class .
although these are common words , they are clearly predictive of the student class since ( cid : 123 ) rst - person pro - nouns and verb conjugations do not appear frequently on pages in the other
123 a stop list is a set of words that are commonly removed from documents before they are processed by an information - retrieval or text - classi ( cid : 123 ) cation system .
there are standard stop lists which include words generally thought to convey little infor - mation about the document topic .
the top ten most highly weighted words .
for each class , the table shows the ten words that are most highly weighted by one of our learned full - text models .
the weights shown represent the weighted log - odds ratio of the words given the class .
the symbol d is used to represent an arbitrary digit .
for example , the top word shown for the faculty class , dddd , represents any four - digit token ( such as that occurring in a phone number ) .
classes .
this result suggests that it is advantageous to select a vocabulary in a domain speci ( cid : 123 ) c way ( as we did using mutual information ) , instead of using a general purpose stop list .
table 123 shows the results when we assign each page to the class with the high - est score .
one approach to improving classi ( cid : 123 ) cation accuracy is to limit the
accuracy / coverage tradeo ( cid : 123 ) for full - text classi ( cid : 123 ) ers .
predictions within each class are ordered according to their con ( cid : 123 ) dence .
each curve shows the behavior of the classi ( cid : 123 ) er as a threshold on this con ( cid : 123 ) dence is varied .
the x - axis represents the percentage of pages of a given class that are correctly classi ( cid : 123 ) ed as belonging to the class .
the y - axis represents the percentage of pages assigned to a given class that are actually members of that class .
predictions made by the classi ( cid : 123 ) ers to just those predictions in which they are most con ( cid : 123 ) dent .
this is easily achieved with our method because the quantity scorec ( d ) calculated when classifying a page can be taken as a measure of the con ( cid : 123 ) dence in the classi ( cid : 123 ) cation .
by setting a minimum threshold on this con ( cid : 123 ) dence , we can select a point that sacri ( cid : 123 ) ces some coverage in order to ob - tain increased accuracy .
given our goal of automatically extracting knowledge base information from the web , it is desirable to begin with a high - accuracy classi ( cid : 123 ) er , even if we need to limit coverage to only , say , 123% of the 123 , 123 , 123 pages available on the web .
the e ( cid : 123 ) ect of trading o ( cid : 123 ) coverage for accuracy using our full - text classi ( cid : 123 ) ers is shown in figure 123
the horizontal axis on this plot represents coverage : the percentage of pages of a given class that are correctly classi ( cid : 123 ) ed as belonging to the class .
the vertical axis represents accuracy : the percentage of pages classi - ( cid : 123 ) ed into a given class that are actually members of that class .
to understand these results , consider , for example , the class student .
as the results in table 123 show , when the classi ( cid : 123 ) ers predict that a page belongs to the student class they are correct 123% of the time .
the rightmost point on the student curve in the table 123 corresponds to this point .
as we raise the con ( cid : 123 ) dence threshold for this class , however , the accuracy of our predictions rises .
for example , at a
accuracy / coverage tradeo ( cid : 123 ) for hyperlink classi ( cid : 123 ) ers .
accuracy / coverage tradeo ( cid : 123 ) for title / heading classi ( cid : 123 ) ers .
coverage of 123% , accuracy reaches a level of 123% .
so far , we have discussed the results only for the full - text classi ( cid : 123 ) ers .
figures 123 and 123 show the accuracy / coverage curves for the hyperlink and title / heading classi ( cid : 123 ) ers , respectively .
as before , these curves show the aggregate results for
all four test sets in our cross - validation run .
as we discussed earlier , one of the aspects that distinguishes learning in hy - pertext from learning in at - text domains is that hypertext provides multiple , somewhat independent sources of evidence for the meaning of a given piece of text .
as we hypothesized , the results in figures 123 and 123 indicate that these multiple sources of evidence can be potentially combined to make better pre -
consider , for example , the accuracy of the department predictions made by the hyperlink classi ( cid : 123 ) ers .
whereas the full - text classi ( cid : 123 ) ers are only 123% accu - rate at full coverage , the hyperlink classi ( cid : 123 ) ers are 123% accurate .
moreover , the department accuracy / coverage curve for the hyperlink classi ( cid : 123 ) ers is uniformly superior to the curve for the full - text classi ( cid : 123 ) ers .
the reason for this di ( cid : 123 ) er - ence in accuracy is that although our data set includes few department pages from which to generalize , it includes many hyperlinks that point to department pages .
thus the hyperlink classi ( cid : 123 ) ers have relatively large samples of data from which to learn the word statistics of hyperlinks that point to department pages , and similarly they have a fairly large number of hyperlinks on which to base their prediction when classifying a page after training .
the title / heading classi ( cid : 123 ) ers also illustrate cases in which using a hypertext - based representation for page classi ( cid : 123 ) cation can result in better predictive accu - racy than simply using a at - text representation .
the title / heading classi ( cid : 123 ) ers curve for both the faculty and research project classes , for example , are better than the corresponding curves for the full - text classi ( cid : 123 ) ers at coverage levels of 123% and less .
one explanation for this result is that titles and headings pro - vide something of a summary of a given page and thus tend to contain words that are highly predictive of the pages class .
123 first - order text classi ( cid : 123 ) cation
as noted previously , the hypertext structure of the web can be thought of as a graph in which web pages are the nodes of the graph and hyperlinks are the edges .
the methods for classifying web pages that we discussed in the previous sections consider the words in either a single node of the graph or in a set of edges impinging on the same node .
however , these methods do not allow us to learn models that take into account such features as the pattern of connectivity around a given page , or the words occurring in neighboring pages .
it might be pro ( cid : 123 ) table to learn , for example , a rule of the form \a page is a course home page if it contains the words textbook and ta and is linked to a page that contains the word assignment . " rules of this type , that are able to represent general characteristics of a graph , can be concisely represented using
a ( cid : 123 ) rst - order representation .
in this section , we consider the task of learning to classify pages using a learner that is able to induce ( cid : 123 ) rst - order rules .
the learning algorithm that we use in this section is quinlans foil algorithm ( 123 , 123 ) .
foil is a greedy covering algorithm for learning function - free horn clauses 123 .
foil induces each horn clause by beginning with an empty tail and using a hill - climbing search to add literals to the tail until the clause covers only ( mostly ) positive instances .
the evaluation function used for the hill - climbing search is an information - theoretic measure .
the representation we provide to the learning algorithm consists of the fol - lowing background relations : ( cid : 123 ) has word ( page ) : this set of relations indicate which words occur in which pages .
each boolean relation indicates the pages in which the word word occurs .
a distinct relation is used for each allowed word ( e . g .
has apple , has study , etc . ) .
the vocabulary for this set includes stemmed 123 words that have at least 123 occurrences but that do not occur in more than 123% of the training - set pages .
these two constraints were selected with the intention of assembling a vocabulary of reasonable size that would likely include the words with the most discrimination power .
we had between 123 and 123 of these predicates in each of the cross - validation runs .
since we do not know a priori which subsets of pages it will pro ( cid : 123 ) table to describe in learned rules , we do not select the vocabulary using mutual information , as we did with our statistical text classi ( cid : 123 ) ers .
( cid : 123 ) link to ( page , page ) : this relation represents the hyperlinks that interconnect
the pages in the data set .
we apply foil to learn a separate set of clauses for six of the seven classes considered in the previous section 123 .
we do not learn a description of the other class , but instead treat it as a default class .
when classifying test instances , we calculate an associated measure of con - ( cid : 123 ) dence along with each prediction .
we calculate these con ( cid : 123 ) dence values for two reasons .
first , we use them to resolve conicting predictions from our six
123 we use the terms clause and rule interchangeably 123 stemming refers to the process of heuristically reducing words to their root form .
for example the words compute , computers and computing would be stemmed to the root comput .
123 there is a version of foil speci ( cid : 123 ) cally designed for multi - class problems such as ours .
we found , however , that the inductive bias of this version is not well suited to our particular task .
independently learned rule sets .
second , we are interested in measuring how the accuracy of our learned rule sets varies as we adjust their coverage .
we use the following procedure to calculate the con ( cid : 123 ) dence of each of our predictions .
first , we estimate the accuray of each of our learned clauses by calculating an m - estimate ( 123 ) of the rules accuracy over the training exam - ples .
the m - estimate of a rules accuracy is de ( cid : 123 ) ned as follows :
mestimate accuracy =
nc + mp n + m
where nc is the number of instances correctly classi ( cid : 123 ) ed by the rule , n is the total number of instances classi ( cid : 123 ) ed by the rule , p is a prior estimate of the rules accuracy , and m is a constant called the equivalent sample size which determines how heavily p is weighted relative to the observed data .
in our experiments , we set m = 123 and we set p to the proportion of instances in the training set that belong to the target class .
we then use these scores to sort the clauses in order of descending accuracy .
123 to integrate the predictions of our six independently learned classi ( cid : 123 ) ers , we use the following procedure : ( cid : 123 ) if no classi ( cid : 123 ) er had a rule that matched the given page , then we predict other ( cid : 123 ) if only one classi ( cid : 123 ) er had a matching rule , then we predict the associated class with con ( cid : 123 ) dence corresponding to the rules score .
the other class is predicted with con ( cid : 123 ) dence of one minus this score .
( cid : 123 ) if more than one classi ( cid : 123 ) er has a matching rule for the given example , then we predict each class with con ( cid : 123 ) dence equal to the score of its best matching rule divided by the total number of classi ( cid : 123 ) ers that had matching rules .
the other class is predicted with a con ( cid : 123 ) dence value that would make the total con ( cid : 123 ) dence sum to one .
with con ( cid : 123 ) dence 123 .
123 . 123 experimental evaluation
for the experiments reported here , we used release 123 of foil with the default settings .
as with the experiments in section 123 , we use a four - fold cross - validation methodology .
the resulting accuracy / coverage plot for each class is shown in figure 123
comparing these results to those in figure 123 , one can see that although the ( cid : 123 ) rst - order rules generally provide lower coverage than the statistical classi ( cid : 123 ) ers , they provide superior accuracy for several classes .
figure 123 shows three of the rules 123 learned by foil in its various cross -
123 this change does not a ( cid : 123 ) ect the classi ( cid : 123 ) cations made by a learned set of clauses .
it a ( cid : 123 ) ects only our con ( cid : 123 ) dence associated with each prediction .
123 throughout the article , we use a prolog - like syntax for learned rules .
the symbol
accuracy / coverage tradeo ( cid : 123 ) for foil page classi ( cid : 123 ) ers .
validation runs .
the learned rule for course shown here illustrates the power of a ( cid : 123 ) rst - order representation .
this rule classi ( cid : 123 ) es a page as the home page for a course if it passes three groups of tests :
( 123 ) the page has the word instructor , but doesnt have the word good .
( 123 ) the page contains a hyperlink to a page which does not contain any
hyperlinks to other pages .
( 123 ) this linked page contains the word assign .
the sample rule learned for the student class comes from the cross - validation run leaving pages from the university of washington out of the training set .
notice that this rule refers to a page ( bound to the variable b ) that has two common ( cid : 123 ) rst names on it ( paul and jame , the stemmed version of james ) .
this rule ( and similar rules learned with the other three training sets ) illustrates that foil has learned to exploit \student directory " pages in order to identify student home pages .
for example , when washington is the test set , all of the correct applications of the rule bind b to a page entitled \graduate students at uw cs&e " .
similarly , the faculty rule will not classify a page as faculty unless there is a page containing the stemmed variant of faculty that points into the given page .
: - represents the implication operator , with the head of the rule on the left side of the operator and the body on the right side .
constants , such as the names of our ontology classes and relations , start with lowercase letters .
variables start with
student ( a ) : - not ( has data ( a ) ) , not ( has comment ( a ) ) , link to ( b , a ) , has jame ( b ) ,
has paul ( b ) , not ( has mail ( b ) ) .
training set : 123 pos , 123 neg; test set : 123 pos , 123 neg
faculty ( a ) : - has professor ( a ) , has ph ( a ) , link to ( b , a ) , has faculti ( b ) .
training set : 123 pos , 123 neg; test set : 123 pos , 123 neg
course ( a ) : - has instructor ( a ) , not ( has good ( a ) ) , link to ( a , b ) , not ( link to ( b , 123 ) ) ,
training set : 123 pos , 123 neg; test set : 123 pos , 123 neg
a few of the rules learned by foil for classifying pages .
all three of these rules show how web - page classi ( cid : 123 ) cation is di ( cid : 123 ) erent from ordinary text classi ( cid : 123 ) cation in that neighboring pages may provide strong ev - idence about the class of a given page .
learning methods which can use this information e ( cid : 123 ) ectively should perform better than standard techniques in this
123 combining learners
the previous experiments show that the best representation for page clas - si ( cid : 123 ) cation depends on the class .
this observation suggests that it might be pro ( cid : 123 ) table to combine the predictions made by our four classi ( cid : 123 ) ers .
in this sec - tion , we describe and evaluate a simple approach to this task .
the method that we employ for combining the predictions of our classi ( cid : 123 ) ers takes advantage of the fact that each classi ( cid : 123 ) er produces a measure of con - ( cid : 123 ) dence along with each prediction .
the method we use is a simple voting scheme that uses con ( cid : 123 ) dence values as tie - breakers .
that is , given the predic - tions made by our four classi ( cid : 123 ) ers for a given web page , we predict the class that has a plurality of the votes made by the individual classi ( cid : 123 ) ers , if there is one .
if no class has a plurality , then we select the class associated with the highest con ( cid : 123 ) dence prediction .
in order to ensure that the con ( cid : 123 ) dence measures output by our di ( cid : 123 ) erent classi - ( cid : 123 ) ers are comparable , we calibrate each classi ( cid : 123 ) er by inducing a mapping from its output scores to the probability of a prediction being correct .
we do this by partitioning the scores produced by each classi ( cid : 123 ) er into bins and then mea - suring the training - set accuracy of the scores that fall into each bin .
accuracy / coverage tradeo ( cid : 123 ) for combined classi ( cid : 123 ) ers with vocabulary size of
123 . 123 experimental evaluation
figure 123 shows the accuracy / coverage curves for the voting predictors .
by com - paring this ( cid : 123 ) gure to the accuracy / coverage curves for the full - text classi ( cid : 123 ) ers shown in figure 123 one can see that , in general , more accurate predictions are achieved by considering evidence other than full - text when classifying pages .
at high levels of coverage , the voting classi ( cid : 123 ) ers are more accurate than the full - text classi ( cid : 123 ) ers for the course and department classes .
additionally , the re - search project predictions made by the voting classi ( cid : 123 ) er are signi ( cid : 123 ) cantly more accurate than the full - text predictions , although the coverage attained by the voting classi ( cid : 123 ) er is not as good .
although figure 123 indicates that predictive accuracy is helped in some cases by combining multiple classi ( cid : 123 ) ers , the results of this experiment are somewhat disappointing .
the accuracy / coverage curves for the voting classi ( cid : 123 ) ers are not uniformly better than the corresponding curves of the constituent classi ( cid : 123 ) ers .
ideally , we would like the accuracy / coverage curve for each class to be as good or better than the best counterpart curve among the constituent classi ( cid : 123 ) ers .
we believe that the results shown in figure 123 are disappointing because our method for combining the predictions of multiple classi ( cid : 123 ) ers is overly simple .
speci ( cid : 123 ) cally , we believe that the method fails to accurately map classi ( cid : 123 ) cation scores to estimated accuracies .
interestingly , we have observed that the voting method performs much better when our statistical classi ( cid : 123 ) ers are limited to very small vocabularies .
figure 123 shows the accuracy / coverage curves for
accuracy / coverage tradeo ( cid : 123 ) for combined classi ( cid : 123 ) ers with vocabulary size of
voting when we use statistical classi ( cid : 123 ) ers trained with a vocabulary size of 123 words .
in comparing this ( cid : 123 ) gure to our baseline full - text classi ( cid : 123 ) er ( figure 123 ) , one can see that the curves produced by the small - vocabulary voting method are generally superior to the full - text classi ( cid : 123 ) er curves .
moreover , the small - vocabulary voting classi ( cid : 123 ) ers achieved this result using constituent classi ( cid : 123 ) ers that were not as accurate as their 123 - word vocabulary counterparts .
in future work , we plan to consider alternative combining functions that might be better able to exploit the specialized areas of expertise exhibited by our
123 identifying multi - page segments
as discussed in section 123 , our representational assumption is that each class instance in the knowledge base corresponds to some contiguous segment of hypertext on the web .
this allows , for example , that a particular student might be represented on the web by a single web page , or by a cluster of interlinked web pages centered around their home page .
in the experiments reported thus far , we have e ( cid : 123 ) ectively made a simpler as - sumption : that each instance is represented by a single web page .
in fact , in labeling our training data , we encountered a variety of students ( and instances of other ontology classes ) that were described by several interlinked web pages
rather than a single page .
in these cases we hand labeled the primary home page as student , and labeled any interlinked pages associated with the same student as other .
to remove this simplifying assumption we must develop methods for identify - ing sets of interlinked pages that represent a single knowledge base instance .
in this section we present a set of hand - written heuristics that identify groups of related pages and also identify the \primary " home page in the group .
we show here that classi ( cid : 123 ) cation accuracy in the previous sections is signi ( cid : 123 ) cantly improved when these heuristics are used to group pages and to automatically assign the label other to non - primary pages , to ( cid : 123 ) t the assumption we made while hand labeling the data .
consider the web pages of a prototypical faculty member .
she might have a main page ( http : / / www . my . edu / user / jdoe / index . html ) , a page listing her publications ( http : / / www . my . edu / user / jdoe / pubs . html ) , and a page de - scribing her research interests ( http : / / www . my . edu / user / jdoe / work / research .
our working assumption about entity - web relationships indicates that we should recognize that these pages correspond to a single entity , identify the best representative page for that entity , classify that page as a faculty , and classify the rest of the pages as other .
we accomplish this by solving two sub - tasks : grouping related pages together , and identifying the most representative page of a group .
spertus ( 123 ) identi ( cid : 123 ) es regularities in url structure and naming , and presents several heuristics for discovering page groupings and identifying representa - tive home page .
we use a similar , slightly expanded , approach .
although one could imagine trying to learn these heuristics from examples , in the following experiment we have instead provided these rules by hand .
the most obvious groupings that can be extracted from a url are based on di - rectory structure pre ( cid : 123 ) xes .
key directory components of a url indicate a log - ical grouping of web pages into an entity .
for example , given the url http : / / www . my . edu / user / jdoe / research . html , we can deduce the existence of an entity corresponding to the url pre ( cid : 123 ) x http : / / www . my . edu / user / jdoe / , because the keyword / user / in the penultimate directory position typically in - dicates the presence of a person entity in the directory space denoted by jdoe .
other typical penultimate pre ( cid : 123 ) x markers are / faculty / , / people / , / home / , and / projects / .
three ultimate pre ( cid : 123 ) x markers ( in unix - style globbing pat - tern ) are / cs ? ? ? / , / www / and / ( cid : 123 ) * / , the ( cid : 123 ) rst being a typical indicator of a course , and the last being a typical indicator of the username of a person or or - ganization .
our algorithm groups urls by their longest directory pre ( cid : 123 ) x that
matches one of these given patterns .
in the event that no pattern matches , the entire directory pre ( cid : 123 ) x is used for the grouping .
in our example above , the three urls would each have the entity pre ( cid : 123 ) x as http : / / www . my . edu / user / jdoe / , and thus would be grouped together .
applying these grouping heuristics results in sets of web pages that are con - jectured to represent a single ontology entity .
from these sets , we identify the single primary page that is most representative of that entity .
usually this corresponds to the \home page " of the entity .
thus , we take any page that has the ( cid : 123 ) lename pattern \index . html " , \home . html " , \homepage . html " , or \cs ? ? ? . html " and label it the primary page .
additionally , any page in which the complete url is the directory pre ( cid : 123 ) x , ( for example , the url http : / / www . my . edu / user / jdoe / ) or one in which the ( cid : 123 ) lename matches the directory above it ( as in http : / / www . my . edu / user / jdoe / jdoe . html ) is also identi - ( cid : 123 ) ed as a primary page .
all pages that do not match any of these patterns in a group , are classi ( cid : 123 ) ed automatically as other .
in the event that no page in a group matches any of these heuristics , the page with the highest ( non - other ) classi ( cid : 123 ) cation con ( cid : 123 ) dence is labeled the primary page .
in our example , http : / / www . my . edu / user / jdoe / index . html would be classi ( cid : 123 ) ed as faculty ( assuming our classi ( cid : 123 ) er was correct ) , and the other pages would be classi - ( cid : 123 ) ed as other regardless of the classi ( cid : 123 ) er prediction .
a precise de ( cid : 123 ) nition of the algorithm used is given in appendix c .
123 . 123 experimental evaluation
the impact of using the url heuristics with the original full - text page clas - si ( cid : 123 ) er is summarized in figure 123
comparing these curves to figure 123 one can see the striking increase in accuracy for any given level of coverage across all classes .
also note some degradation in total coverage .
this occurs because some pages that were previously correctly classi ( cid : 123 ) ed have been misidenti ( cid : 123 ) ed as being \secondary " pages .
123 section summary
this section focused on the task of recognizing class instances by web page classi ( cid : 123 ) cation .
we showed that , because hypertext provides much redundant information , web pages can be classi ( cid : 123 ) ed using several sources of information : the full text of pages , the text in titles and headings , the text associated with hyperlinks , text in neighboring pages , and the ( cid : 123 ) le organization represented in urls .
our experiments suggest that none of these approaches alone is su ( cid : 123 ) cient for recognizing instances of ontology classes with high accuracy .
in the experiments described in section 123 , we used both full - text classi ( cid : 123 ) ers and
accuracy / coverage tradeo ( cid : 123 ) for the full - text classi ( cid : 123 ) er after the application of url heuristics .
url heuristics .
we also showed in this section that one promising line of research is to combine the predictions of multiple classi ( cid : 123 ) ers that use di ( cid : 123 ) erent sources of evidence .
123 learning to recognize relation instances
in the previous section we discussed the task of learning to extract instances of ontology classes from the web .
our approach to this task assumed that the class instances of interest are represented by whole web pages or by clusters of web pages .
in this section , we discuss the task of learning to recognize relations of interest that exist among extracted class instances .
the hypothe - sis underlying our approach is that relations among class instances are often represented by hyperlink paths in the web .
thus , the task of learning to rec - ognize instances of such relations involves inducing rules that characterize the prototypical paths of the relation .
for example , an instance of the instructors of relation might be represented by a hyperlink directly from the home page of a course to the home page of the instructor , as described by the following rule :
instructors of ( a , b ) : - course ( a ) , person ( b ) , link to ( a , b ) .
here , the variables a and b represent web pages , the literals course ( b ) and
person ( a ) represent the predicted classi ( cid : 123 ) cations of the pages , and the literal link to ( a , b ) tests for the existence of a hyperlink from page a to page b .
123 problem representation
because this task involves discovering hyperlink paths of unknown and variable size , we employ a learning method that uses a ( cid : 123 ) rst - order representation for its learned rules .
speci ( cid : 123 ) cally , the algorithm we have developed for this task is based on the foil algorithm ( 123 , 123 ) which we used for page classi ( cid : 123 ) cation in section 123 .
we discuss our algorithm in more detail below .
the problem representation we use for this relation learning tasks consists of the following background relations : ( cid : 123 ) class ( page ) : for each class in the set of page classes considered in section 123 , the class relation lists the pages that represent instances of class .
for pages in the training set , the instances of these relations are determined using the actual classes of the pages .
for pages in the test set , however , we use the predicted page classes given by the classi ( cid : 123 ) ers discussed in section 123
since the web ! kb system has access only to predicted page classes , our test set conditions are representative of those the system faces .
( cid : 123 ) link to ( hyperlink , page , page ) : this relation represents web hyperlinks .
for a given hyperlink , the ( cid : 123 ) rst argument of the relation speci ( cid : 123 ) es an identi ( cid : 123 ) er for the hyperlink , the second argument speci ( cid : 123 ) es the page in which the hyperlink is located , and the third argument indicates the page to which the hyperlink ( cid : 123 ) has word ( hyperlink ) : this set of relations indicates the words that are found in the anchor ( i . e . , underlined ) text of each hyperlink .
the vocabulary for this set of relations includes words that occur at least n times ( we set n = 123 in our experiments ) in the hyperlinks of the training set .
note that whereas the has word relations used in section 123 describes web pages , the set used here characterizes hyperlinks .
( cid : 123 ) all words capitalized ( hyperlink ) : the instances of this relation are those hy - perlinks in which all of the words in the anchor text start with a capital ( cid : 123 ) has alphanumeric word ( hyperlink ) : the instances of this relation are those hyperlinks which contain a word with both alphabetic and numeric charac - ters ( e . g . , i teach cs123 ) .
( cid : 123 ) has neighborhood word ( hyperlink ) : this set of relations indicates the words that are found in the \neighborhood " of each hyperlink .
the neighborhood of a hyperlink includes words in a single paragraph , list item , table entry , title or heading in which the hyperlink is contained .
the vocabulary for this set of relations includes the 123 most frequently occurring words in
each training set , except for words on a stoplist .
we learn de ( cid : 123 ) nitions for the following target relations from the data set de - scribed in section 123 : members of project ( page , page ) , instructors of course ( page , page ) , and department of person ( page , page ) .
in addition to the positive in - stances for these relations , our training sets include approximately 123 , 123 negative examples .
we form the set of negative training instances for each target relation by enumerating each pair of non - other pages from the same university that is not a positive instance of the target relation .
this selection criterion results in a sample of negative instances that is biased toward con - nected pairs of pages and is small enough to allow reasonable learning times .
for the department of person relation , we augment the negative instances with each person ( department pair which is not a positive instance .
these additional negative instances preclude the learner from learning the trivial ( and wrong ) rule that every person is a member of every department .
123 learning methods
as stated above , the algorithm we use for learning relation rules is similar to foil in that it uses a greedy covering approach to learn a set of horn clauses .
the primary di ( cid : 123 ) erences between our method and foil are twofold .
first , unlike foil our method does not simply use hill - climbing when searching for the next clause to add to a concept de ( cid : 123 ) nition .
second , our method uses a di ( cid : 123 ) erent evaluation function for this search process .
we discuss each of these di ( cid : 123 ) erences in turn .
as described in section 123 , foil constructs clauses using a hill - climbing search through a space of candidate literals .
we have found that , for our relation - learning tasks , such a hill - climbing strategy is unable to learn rules for paths consisting of more than one hyperlink .
the search process that our method employs instead consists of two phases .
in the ( cid : 123 ) rst phase , the \path " part of the clause is learned , and in the second phase , additional literals are added to the clause using a hill - climbing search .
our algorithm for constructing the path part of a clause is a variant of richards and mooneys relational path ( cid : 123 ) nding method ( 123 ) .
this method is designed to alleviate the basic weakness of hill - climbing search , namely that to learn good de ( cid : 123 ) nitions it is often necessary to take a step in the search space which does not exhibit any immediate gain .
the basic idea underlying relational path ( cid : 123 ) nding is that a relational problem domain can be thought of as a directed graph in which the nodes are the domains constants and the edges correspond to rela - tions which hold among constants .
the relational - path ( cid : 123 ) nding algorithm tries to ( cid : 123 ) nd a small number of prototypical paths in this graph that characterize
input : training set of negative and uncovered positive instances
for each uncovered positive instance
( cid : 123 ) nd a path ( up to bounded length ) using the background relations select the most common path prototype for which clause search hasnt generalize the path into an initial clause do hill - climbing to re ( cid : 123 ) ne the clause if hill - climbing fails to ( cid : 123 ) nd an acceptable clause , backtrack to step 123
return : learned clause
the procedure for learning a clause in our deterministic variant of relational
finding a path in the background relations .
on the left is shown a graph of constants linked by a single binary relation .
this graph can be thought of as representing web pages connected by hyperlinks .
suppose the pair hp123 , p123i is an un - covered positive instance .
path ( cid : 123 ) nding proceeds by expanding the subgraphs around the two constants until an intersection is detected , and then returning the path that links the two constants .
the instances of the target relation .
figure 123 provides an overview of our path ( cid : 123 ) nding procedure for learning a single clause .
this procedure is iterated until a complete de ( cid : 123 ) nition has been learned .
the ( cid : 123 ) rst step in the method is to ( cid : 123 ) nd the shortest path of a bounded length ( when one exists ) for each positive instance ( of the target relation ) that has not been covered by a previously learned clause .
this process , illustrated in figure 123 involves expanding a subgraph around each of the constants in the instance .
each subgraph is expanded by ( cid : 123 ) nding all constants which can be reached using an instance of one of the background relations to connect to a constant at the frontier of the subgraph .
after ( cid : 123 ) nding such a path for each uncovered positive instance , the most com -
find path for each positive instance
return most common path
finding the most common path for a set of positive instances .
given the graph shown in figure 123 , suppose that the positive instances are hp123 , p123i , hp123 , p123i , hp123 , p123i , and hp123 , p123i .
our algorithm ( cid : 123 ) nds the shortest path for each instance and then returns the most common path prototype .
in this example the ( cid : 123 ) rst three instances have the same path prototype , whereas the instance hp123 , p123i has di ( cid : 123 ) erent one ( notice the direction of the hyperlinks ) .
this path prototype is converted into an initial clause .
mon path prototype is used for the initial clause .
123 a path prototype speci ( cid : 123 ) es the number of hyperlinks in the path and their directions , but it does not reference the particular pages and hyperlinks in any particular instance .
the notion of the most common path prototype is illustrated in figure 123
the initial clause is formed by replacing each constant in the path with a unique variable .
this clause is then further re ( cid : 123 ) ned by a simple hill - climbing search , such as that used in foil .
if the hill - climbing search fails to ( cid : 123 ) nd an accept - able clause , then the procedure backtracks by removing the last selected path prototype from the list of candidates and then trying the next most common
we further bias the search for clauses by initializing each one with the classes of the pair of pages in the relation .
for example , when learning clauses for the target relation members of project ( a , b ) , we initialize the tail of each clause with the literal research project ( a ) and person ( b ) .
this bias takes advantage of domain knowledge which is present in the ontology given to the web ! kb
the second di ( cid : 123 ) erence between our relation - learning algorithm and foil is that whereas foil uses an information - theoretic measure to guide its hill - climbing search , our method , like d ( cid : 123 ) zeroski and bratkos m - foil ( 123 ) , uses m - estimates of a clauses error to guide its construction .
we have found that using this evaluation function causes the algorithm to learn fewer , more general clauses
123 if the method is constrained from learning recursive de ( cid : 123 ) nitions , the path for each positive instance needs to be found only once since it will not change as clauses are added for the target relation .
in this case , before learning each new clause the algorithm needs only to update counts indicating the number of instances covered by each path prototype .
than when foils information gain measure is used .
123 experimental evaluation
we evaluate our approach to learning relation rules using the data and four - fold cross - validation methodology described in section 123
on each iteration , we learn the target relations using training instances from three of the univer - sities in our data set , and test learned clauses using instances from the fourth
figure 123 shows a learned clause for each of the instructors of , department of , and members of project relations .
on average , there were 123 , 123 , and 123 clauses learned for these target concepts respectively .
along with each rule , we show how well the rule classi ( cid : 123 ) ed test - set instances .
each of these rules was learned on more than one of the training sets , therefore the test - set statistics represent aggregates over the four test sets .
the rules learned for the instructors of relation are the simplest among the three target relations .
the learned rule shown for this relation , for example , matches cases in which a course page has a hyperlink pointing to a person page .
the rule shown for the members of project relation is more interesting .
it describes members of project instances in which the projects home page points to an intermediate page which points to personal home pages .
the hyperlink from the project page to the intermediate page must have the word \people " near it .
this rule covers cases in which the members of a research project are listed on a subsidiary \members " page instead of on the home page of the project .
the rule shown for the department of relation involves a three - hyperlink path that links a department home page to a personal home page .
the rule requires that the word \graduate " occur near the second hyperlink in the path .
in this case , the algorithm has learned to exploit the fact that departments often have a page that serves as a graduate student directory , and that any student whose home page is pointed to by this directory is a member of the department .
along with each of our predicted relation instances , we calculate an associated con ( cid : 123 ) dence in the prediction .
we can then vary the coverage of our learned rule sets by varying a threshold on these con ( cid : 123 ) dence values .
we calculate the con ( cid : 123 ) dence of each prediction by considering where most of the uncertainty in the prediction lies : in the page classi ( cid : 123 ) cations that are tested by each learned clause .
the con ( cid : 123 ) dence measure for a predicted relation instance is simply the product of the con ( cid : 123 ) dence measures for the page classi ( cid : 123 ) cations that factor into the relation prediction .
using these con ( cid : 123 ) dence measures , figure 123 shows the test - set accuracy / coverage
instructors of ( a , b ) : - course ( a ) , person ( b ) , link to ( c , b , a ) .
test set : 123 pos , 123 neg
department of ( a , b ) : - person ( a ) , department ( b ) , link to ( c , d , a ) , link to ( e , f , d ) ,
link to ( g , b , f ) , has neighborhood word graduate ( e ) .
test set : 123 pos , 123 neg
members of project ( a , b ) : - research project ( a ) , person ( b ) , link to ( c , a , d ) ,
link to ( e , d , b ) , has neighborhood word people ( c ) .
test set : 123 pos , 123 neg
a few of the rules learned for recognizing relation instances .
accuracy / coverage tradeo ( cid : 123 ) for learned relation rules .
curves for the three target relations .
the accuracy levels of all three rule sets are fairly high .
the members of project rules are better than 123% accurate at coverage levels of up to about 123% .
the instructors of rules are over 123% accurate at coverage levels of 123% and above .
the department of rules are at least 123% accurate at coverage levels of up to 123% .
the limited coverage levels of the learned rules is due primarily to the limited coverage of our page clas - si ( cid : 123 ) ers .
note that all of the learned rules include literals which test predicted page classi ( cid : 123 ) cations .
as figure 123 shows , the coverage exhibited by our page classi ( cid : 123 ) ers is below 123% for most classes .
123 learning to extract text fields
in some cases , the information we want to extract will not be represented by web pages or relations among pages , but by small fragments of text embedded in pages .
for example , given a personal home page , we might be interested in extracting the persons name .
this type of task is commonly called informa - tion extraction .
this section discusses our approach to learning rules for such information extraction tasks .
we have developed an information extraction learning algorithm called srv for \sequence rules with validation . " srv is a ( cid : 123 ) rst - order learner in the spirit of foil .
it shares foils top - down approach and gain metric , but is designed with the information extraction problem in mind .
consequently , it is limited to a few pre - de ( cid : 123 ) ned predicates , and it encompasses search heuristics speci ( cid : 123 ) c to the information extraction problem .
input to srv is a set of pages , labeled to identify instances of the ( cid : 123 ) eld we want to extract , and a set of features de ( cid : 123 ) ned over tokens .
output is a set of information extraction rules .
the extraction process involves examining every possible text fragment of appropriate size to see whether it matches any of the rules .
as in foil , \growing " a rule in srv means hill - climbing through a space of possible literals , at each step adding a literal that matches as many positive examples as possible while excluding a large number of previously covered negative examples .
when a rule is deemed good enough ( either it covers only positive examples , or further specialization is judged to be unproductive ) , all positive examples matching it are removed from the training set , and the process is repeated .
in our particular domain , a positive example is a labeled text fragment|a sequence of tokens|in one of our training documents; a negative example is any unlabeled token sequence having the same size as some positive example .
during training we assess the goodness of a literal using all such negative examples .
the representation used by our rule learner attempts to express the salient characteristics of positive examples mainly in terms of the individual tokens contained within them and surrounding them .
srv is given as input a set of features de ( cid : 123 ) ned over individual tokens .
these features come in two varieties : simple features map tokens to arbitrary discrete ( but typically boolean ) values; relational features map tokens to other tokens in the same document .
an ex - ample simple feature is capitalized .
an example relational feature is next token which , given a token , returns the token immediately following it .
let f = wi; ( cid : 123 ) ( cid : 123 ) ( cid : 123 ) ; wj be a fragment of text , an unbroken sequence of tokens ( wi )
from some document .
at each step in rule growth , a literal is generated from one of four templates : ( cid : 123 ) length ( relop , n ) : constrains the length of f .
relop is one of f<; >; =g and n is an integer .
for example , the literal length ( < , 123 ) means jfj < 123 , where jfj is the number of tokens in f .
123 ( cid : 123 ) some ( var , path , feat , value ) : posits a feature - value test for some token in the sequence .
var is a variable , path is a list of relational features , feat is a simple feature and value is a legal value of feat .
for example , the literal some ( b , ( ) , capitalized , true ) asserts that f contains a capitalized token and binds this token to the variable b .
each distinct variable in a rule must bind to a distinct token in a matching fragment .
in logical terms , if in some other literal in the current rule srv has introduced the variable a and now makes the above assertion , there is an implicit assertion of inequality between a
123a; b 123 f : a 123= b ^ capitalized ( b ) = true
the path argument , which is empty in the above example , is used to exploit relational structure in the domain ( see below ) .
( cid : 123 ) position ( var , from , relop , n ) : constrains the position of a token bound by a some - literal in the current rule .
from is either start or end , relop is one of f<; >; =g , and n is an integer .
for example , the literal position ( a , start , < , 123 ) asserts that the token bound to a is either the ( cid : 123 ) rst or second in f .
in logic , we might write this 123a 123 f : index ( a ) index ( start ( f ) ) < 123 ^ ( cid : 123 ) ( cid : 123 ) ( cid : 123 ) , where the ellipsis ( ( cid : 123 ) ( cid : 123 ) ( cid : 123 ) ) stands for whatever other assertions are made about a in the ( cid : 123 ) relpos ( var123 , var123 , relop , n ) : constrains the relative position an ordering of two tokens bound by di ( cid : 123 ) erent variables in the same rule .
relop is one of f<; >; =g , and n is an integer .
for example , the literal relpos ( a , b , = , 123 ) means token b immediately follows token a .
in logic : 123a; b 123 f : index ( b ) index ( a ) = 123 ^ ( cid : 123 ) ( cid : 123 ) ( cid : 123 ) .
like foil , srv can exploit relational structure in the domain .
for srv , the only possible form of relational structure is that relating tokens to each other .
the most obvious example is the successor relation , which connects adjacent tokens , but more interesting kinds of structure can be exploited , such as syn - tactic structure .
the path argument to the some - predicate takes a list of rela - tional features which posits a relationship between the token bound to the vari - able ( which is in f ) and the token reached by composing the relational features ( which need not be in f ) .
the feature - value test is applied to the \indirect " token .
for example , the literal some ( a , ( next token next token ) , numeric , true ) might be rendered in logic as 123a 123 f : numeric ( next token ( next token ( a ) ) ) = true .
123 note that all literals added to a rule implicitly refer to some fragment f , so we omit the fragment variable from srv literals for the sake of conciseness .
ownername ( fragment ) : - some ( b , ( ) , in title , true ) ,
some ( b , ( prev token ) , word , \gmt " ) , some ( a , ( ) , longp , true ) , some ( b , ( ) , word , unknown ) , some ( b , ( ) , quadrupletonp , false )
an extraction rule for name of home page owner .
the english rendering of this rule is , \a sequence of two tokens , one of which ( a ) is in a html title ( cid : 123 ) eld and longer than four characters , the other of which ( b ) is preceded by the token gmt , is unknown from training , and is not a four - character token . " this is a high - accuracy rule , achieving 123 correct out of 123 matched on a validation set .
initially , the learner may only use paths of length zero or one; whenever a non - empty path is used in a some predicate , the system makes longer paths available .
in this way , the computational expense that this facility entails is kept under control .
123 experimental evaluation
as in the previous experiments , we followed the leave - one - university - out method - ology , repeatedly holding the pages belonging to one of the four universities out for testing and training on the remaining three .
the data set for the present experiment consists of all person pages in the data set .
the unit of measurement in this experiment is an individual page .
if srvs most con ( cid : 123 ) dent prediction on a page corresponds exactly to some instance of the page owners name , or if it makes no prediction for a page containing no name , its behavior is counted as correct .
otherwise , it is counted as an error .
last - modified : wednesday , 123 - jun - 123 123 : 123 : 123 gmt
<title> bruce randall
bruce randall donald<br>
an example html fragment which the rule in figure 123 matches .
in this case , the fragment bruce randall in the title is extracted .
note that this is an erroneous prediction since it misses the last name of the person .
figures 123 and 123 show a learned rule and its application to a test case .
figure 123 shows the accuracy - coverage curve for srv on the name - extraction task .
under the criteria described above , it achieves 123% accuracy when all pages are processed .
a full 123% of the ( cid : 123 ) les did not contain their owners
accuracy / coverage tradeo ( cid : 123 ) using srv for name extraction .
a prediction on a ( cid : 123 ) le that does not contain a name is counted as an error .
names , however , and a large part of the learners error is because of spurious predictions over these ( cid : 123 ) les .
if we consider only the pages containing names , srvs performance is 123% .
123 related work
there are several signi ( cid : 123 ) cant bodies of research that are related to the tasks and methods discussed in this article .
in this section we briey review the main areas of related work .
123 document classi ( cid : 123 ) cation
our work is related to research in document classi ( cid : 123 ) cation , such as that re - ported at recent text retrieval conferences ( trec ) ( 123 , 123 ) .
a wide variety of methods have been applied to the document - classi ( cid : 123 ) cation task .
the tfidf approach to information retrieval is the basis for the rocchio classi ( cid : 123 ) cation algorithm which has become a standard baseline algorithm for text classi ( cid : 123 ) cation ( 123 , 123 , 123 ) .
its \word - vector " approach involves describing classes with a vector of weights , where each weight indicates how important the corresponding word is to the class .
this representation has been used with
many di ( cid : 123 ) erent learning algorithms , including memory based reasoning ( 123 ) , neural networks ( 123 , 123 ) , linear discriminant analysis ( 123 ) , logistic regression ( 123 ) , widrow - ho ( cid : 123 ) and the exponentiated gradient ( eg ) algorithm ( 123 ) .
another useful line of research in text classi ( cid : 123 ) cation comes from basic ideas in probability and information theory .
bayes rule has been the starting point for a number of classi ( cid : 123 ) cation algorithms ( 123 , 123 , 123 , 123 , 123 , 123 ) , and the minimum description length principle has been used as the basis of an algorithm as
another line of research has been to use symbolic learning methods for text classi ( cid : 123 ) cation .
numerous studies have used algorithms such as decision trees , swap - 123 , ripper and charade can be found in ( 123 , 123 , 123 , 123 , 123 , 123 , 123 , 123 , 123 , 123 ) .
these studies indicate that these algorithms are quite competitive with statistical -
the problem that we are addressing is related to the traditional informa - tion extraction task , such as the research done in the message understanding ( muc ) ( 123 , 123 ) community .
the work in the muc community has considered problems such as extracting symbolic descriptions of terrorist attacks from news articles , constructing case frames that indicate ( cid : 123 ) elds such as the per - petrator , victim , etc .
one key di ( cid : 123 ) erence between this work and the research reported here is that we are concerned with extracting information from hy - pertext , whereas the muc work has focused on ordinary at text .
in addition , our approach relies heavily on machine learning methods that can be trained to extract information , whereas most early work in the muc community relied on hand - crafted methods for extracting information .
recently , the problem of using machine - learning methods to induce information - extraction routines has received more attention .
palka ( 123 ) and autoslog ( 123 ) are machine learning systems which learn extraction patterns from col - lections of parsed documents that have been annotated to identify fragments of interest .
these patterns are then reviewed and manually installed into a larger information extraction system .
autoslog - ts ( 123 ) removes the require - ment that documents be annotated .
crystal ( 123 ) and rapier ( 123 ) both demonstrate that machine learning techniques can be used to learn rules that perform extraction autonomously .
crystal is a covering algorithm which takes parsed , annotated sentences as input and produces rules for extracting from novel sentences .
rapier uses ideas from relational learning and relaxes somewhat the reliance on syntactic pre - processing .
starting with maximally speci ( cid : 123 ) c extraction patterns , both systems
learn by dropping constraints and merging patterns .
this contrasts with the general - to - speci ( cid : 123 ) c approach introduced here .
several researchers have explored the problem of text extraction from the web and other internet sources .
one example is ila ( 123 ) , a system designed to learn the semantics of the human - readable output of online databases by comparing it with information whose is already known .
shopbot ( 123 ) , a bargain hunting agent , is designed to learn patterns from html to support the extraction of pricing information from online commerical catalogs .
shopbot is one solution to the general problem of \wrapper induction " ( 123 , 123 , 123 ) , learning extraction patterns for highly regular sources .
at the same time , ideas that have proven useful for general text have also been shown to work well for web pages .
web - foot ( 123 ) is a modi ( cid : 123 ) cation of crystal in which parsed sentence fragments are replaced by segments of html .
whisk ( 123 ) combines the capabilities of crystal and webfoot in a system that is able to learn extraction patterns for semi - structured or free text .
123 extracting semantic information from hypertext
several other research groups have considered the semantic information that can be automatically inferred and extracted from hypertext .
spertus ( 123 ) presents a set of heuristics that relate hypertext conventions to semantic re - lationships .
speci ( cid : 123 ) cally , she considers relationships that can often be inferred from hyperlink structure , ( cid : 123 ) le system organization , and html page structure .
monge and elkan ( 123 ) have developed a system that ( cid : 123 ) nds the web page for a paper given a bibliographic citation to it .
part of the task performed by this system is to ( cid : 123 ) nd the personal home page and the publications page of an author starting from the home page of the persons institution .
for this task , monge and elkan use search - control rules which are somewhat similar to the relation - recognition rules we learned in section 123
their rules look for certain keywords in hyperlinks to decide which ones to follow in the search .
whereas their rules are hand - coded for a speci ( cid : 123 ) c task , our work considers the problem of learning such rules for arbitrary relations .
pirolli et al .
( 123 ) consider the task of classifying pages into functional categories such as head , index and reference .
they characterize the classes using features such as ( cid : 123 ) le size , number of incoming and outgoing hyperlinks , average depth of children pages in the hyperlink graph , etc .
whereas our work has not directly involved learning functional classes of pages , we have observed that our ( cid : 123 ) rst - order learners for both page and relation classi ( cid : 123 ) cation often implicitly learn such functional categories .
recall , for example , that our learned ( cid : 123 ) rst - order rules for recognizing student pages prominently exploited the class of person
index pages .
the features we use also di ( cid : 123 ) er somewhat from those of pirolli et al . , but common to both approaches is the central importance of vector - based text similarity and hyperlink connectivity .
123 extracting knowledge bases from the web
other groups have worked on extracting propositional knowledge - base infor - mation from the web .
luke et al .
( 123 ) have proposed an extension to html called shoe whereby web page authors can encode ontological information on their pages .
the have also developed a system , expose , that extracts shoe - encoded information from web pages , and stores it in a local knowledge base .
their hope is that a library of standard ontologies will come into common usage , enabling agents such as expose to learn the information encoded on
the start information server ( 123 ) provides a natural language interface to a knowledge base collected from the web .
the knowledge base contains meta - information about the content of the web , so that a query to start returns relevant hypertext segments .
start builds its knowledge base by discovering mostly manually added natural language annotations on web pages .
the most signi ( cid : 123 ) cant recent development in this area is the advent of extensible markup language ( xml ) ( 123 ) .
whereas html is designed to describe the layout of information in a page , xml can be used to describe information about the contents of the page .
as with shoe , web page authors can use xml to encode ontological information about their pages .
since xml is a world wide web consortium standard , however , it is sure to be widely used .
we believe that methods for annotating the contents of web pages , such as shoe and xml , can assist with the task of extracting knowledge bases from the web , but do not obviate the need for our web ! kb approach .
there are two notable limitations of approaches such as shoe and xml .
first , they are of no use when web page authors do not employ them .
second , they presuppose a universal ontology .
that is , since individual web page authors are responsible for annotating web pages , the success of these approaches hinges on the extent to which authors employ standard , shared ontologies in a consistent manner .
moreover , ontological decisions are largely in the hands of web page authors in this approach .
there may be cases where the ontological categories used to describe a given web page are not appropriate or relevant categories for the tasks to which an extracted knowledge base will be applied .
in the web ! kb approach , on the other hand , these ontological decisions can be made by the users of the system .
one interesting way in the xml and web ! kb approaches can potentially be combined , is by exploiting xml - annotated pages as pre - labeled training data .
that is , web ! kb could learn
to predict the xml annotations associated with a page , using the non - xml elements of the page as input features .
we plan to explore this issue in future
123 web agents
the web ! kb system described here is an example of a web agent that browses the web , extracting information as it goes .
many other web agents have been developed over the past few years , including several that involve some form of learning .
however , the vast majority of these systems use learn - ing to improve their ability to retrieve text information , rather that to extract computer - understandable information .
for example , joachims et al .
( 123 ) de - scribe a web agent called webwatcher that serves as a tour guide for users browsing the web .
webwatcher learns to suggest appropriate hyperlinks given users interests , based on the hyperlinks followed by previous users with similar interests .
as such , it involves learning to classify hyperlinks ( a task similar to the work reported here on learning to extract relational information .
a system with a similar goal is letizia ( 123 ) , which learns the interests of a single user , in contrast to webwatcher which learns from a community of users .
syskill and webert ( 123 ) o ( cid : 123 ) ers a more restricted way of browsing than webwatcher and letizia .
starting from a manually constructed index page for a particular topic , the user can rate hyperlinks o ( cid : 123 ) this page .
the system uses the ratings to learn a user speci ( cid : 123 ) c topic pro ( cid : 123 ) le that can be used to suggest unexplored hyperlinks on the page .
syskill and webert can also use search engines like lycos to retrieve pages by turning the topic pro ( cid : 123 ) le into a query .
lira ( 123 ) works in an o ( cid : 123 ) - line setting .
a general model of one users interest is learned by asking the user to rate pages .
lira uses the model to browse the web o ( cid : 123 ) - line and returns a set of pages that match the users interest .
one related system that is closer in spirit to our work is shakes et al . s ( 123 ) ahoy system , which attempts to locate the home page of a person , given information such as the persons name , organizational a ( cid : 123 ) liation etc .
ahoy uses knowledge of home page placement conventions to search for personal home pages , and in fact learns these conventions from experience .
123 conclusions and future work
we began this article with a goal and a thesis .
the goal is to automatically create a large knowledge base whose content mirrors that of the world wide .
the thesis is that one can automatically create knowledge bases from the web by ( cid : 123 ) rst using machine learning algorithms to create information extrac - tion methods for each of the desired types of knowledge , and then applying
these methods to extract probabilistic , symbolic statements directly from web
this article provides support for our thesis by proposing and testing a variety of machine learning algorithms for information extraction , and by describing the web ! kb system that incorporates the learned information extractors to browse web sites and populate a knowledge base .
as shown in section 123 and elsewhere , our system has achieved an accuracy of better than 123% at coverage levels of approximately 123% when using these learned information extractors to populate its university knowledge base while browsing new web sites .
these results provide encouraging initial support for our thesis , and suggest many routes for future research .
we have explored a variety of learning methods for this task , including statisti - cal bag - of - words classi ( cid : 123 ) ers , ( cid : 123 ) rst - order rule learners , and multi - strategy learn - ing methods .
we have found that statistical bag of words methods , derived from document classi ( cid : 123 ) cation methods in information retrieval , work well for classifying individual web pages .
however , these methods do not take advan - tage of the special hypertext structure available on the web .
therefore , we de - veloped ( cid : 123 ) rst - order learning algorithms both for learning to classify pages and learning to recognize relations among several pages .
these ( cid : 123 ) rst - order methods are capable of describing patterns that occur across multiple web pages , their hyperlinks , and speci ( cid : 123 ) c words that appear on these pages and hyperlinks .
our experiments indicate that these methods tend to have higher accuracy than the bag of words classi ( cid : 123 ) ers , though they frequently provide lower coverage .
in addition to these ( cid : 123 ) rst - order learning methods that \look outward " from the page to consider its neighbors , we also have developed methods that \look inward " to consider the detailed structure of hypertext and speci ( cid : 123 ) c text frag - ments within a single web page .
the srv algorithm described in section 123 learns relational rules that extract speci ( cid : 123 ) c types of text ( cid : 123 ) elds within a web page , such as a persons name .
we believe that the toolbox of methods we have described here will be ap - plicable to a wide range of problem domains .
for new domains , however , we may apply and combine the methods in ways not explored in this article .
for example , in current work in a new problem domain , we are using page classi - ( cid : 123 ) ers to recognize instances of a particular relation ( the economic sector of a company ) , whereas in the work described here we used page classi ( cid : 123 ) ers to rec - ognize class instances .
in short , the most appropriate method for recognizing instances for a particular class or relation will depend on how these instances tend to be represented in the web .
based on the initial results reported here , we are optimistic about the future prospects for automatically constructing and maintaining a symbolic knowl - edge base by interpreting hypertext on the web .
key questions remain , how -
for example , what level of accuracy can be achieved by learned proce - dures for extracting information from the web , and what level of accuracy will be required of them ? for some tasks the required accuracy will be quite high ( e . g . , for an intelligent system that automatically invests money on behalf of its user ) .
however , for tasks such as information retrieval on the web , the system need only be su ( cid : 123 ) ciently accurate to outperform the current keyword - based retrieval systems that have no real notion of an ontology .
although further research toward stronger learning methods is warranted , we conjecture that there will be a steady stream of applications where even an approximately correct knowledge base will outperform current keyword retrieval methods .
a second type of question for our system is how much e ( cid : 123 ) ort will be required to train the system for each new ontology , or for each extension to the grow - ing ontology ? in the experiments reported here , the system was trained using thousands of hand - labeled web pages that were collected at a cost of approx - imately one or two person - weeks of e ( cid : 123 ) ort .
in newer work we are beginning to explore methods for reducing the dependence on hand labeled data .
below is a list of these and other research opportunities that merit further research : ( cid : 123 ) develop learning methods that exploit the hierarchical relationships that exist among classes in the hierarchy .
for example , in recent work we have shown that the accuracy of our bayesian bag of words classi ( cid : 123 ) er can be improved by using the class hierarchy to obtain more accurate estimates of class conditional word probabilities ( 123 ) .
( cid : 123 ) use the vast pool of unlabeled web pages to supplement the available hand - labeled data to improve learning accuracy .
recently we have shown that the em algorithm can be used to combine labeled and unlabeled data to boost accuracy ( 123 ) .
we are also exploring the combination of em with pool - based training for active learning in which the learner requests labels for speci ( cid : 123 ) c web pages whose label will be especially helpful ( 123 ) .
( cid : 123 ) co - training multiple classi ( cid : 123 ) ers .
for example , consider a problem setting in which one web page classi ( cid : 123 ) er examines the words on the page , and a second classi ( cid : 123 ) er examines instead the words on the incoming hyperlinks to that page .
in recent work , we have proposed a method by which each classi ( cid : 123 ) er acts as a trainer for the other , and we have provided initial experiments and theoretical analysis showing the promise of this approach ( 123 ) .
( cid : 123 ) exploit more linguistic structure .
we plan to explore ways in which noun , verb , and prepositional phrases extracted from the text can be used as features for information extraction .
we have conducted preliminary exper - iments that show improved accuracy in some cases when our bag of words representation is augmented by these extracted phrases ( 123 ) .
we conjecture that such linguistic features will be even more useful for tasks with few words , such as classifying individual hyperlinks .
( cid : 123 ) explore multiple strategies for learning to extract text ( cid : 123 ) elds from web pages .
we have developed a number of approaches to this task ( 123 , 123 , 123 ) , including multi - strategy learning ( 123 ) .
( cid : 123 ) integrate statistical bag - of - words methods into ( cid : 123 ) rst - order learning tasks .
we have begun developing methods that augment ( cid : 123 ) rst - order learning with the ability to use bag - of - words classi ( cid : 123 ) ers to invent new predicates for char - acterizing the pages and hyperlinks referenced in learned rules ( 123 ) .
( cid : 123 ) exploit more html structure .
we plan to investigate the utility of repre - senting the html structure of pages when learning rules for relation classi - ( cid : 123 ) cation and information extraction .
we have investigated one approach to representing html structure and exploiting it for learning tasks ( 123 ) .
( cid : 123 ) learn regularities over the growing knowledge base .
we plan to use learning methods to discover interesting regularities over the facts that have been extracted from the web , and to use these learned facts to improve future fact extraction .
for example , in the university knowledge base we might expect to learn how to predict the department of a faculty member based on the department of her student advisees .
( cid : 123 ) extend the ontology to new problem domains .
we are currently applying our methods to the task of extracting information about companies from
a assumptions about how class and relation instances are rep -
in this appendix we provide a formal treatment of the assumptions we make about how class and relation instances can be represented in the web .
let a web page p be a sequence of tokens , ( tp words and html tags .
de ( cid : 123 ) ne the function page ( tp page p in which a sequence of tokens resides .
n ) , where the tokens are e ) so that it returns the
some tokens represent hyperlinks .
let the predicate hyperlink ( tp the ith token in page p is a hyperlink , and let the function range ( tp the page that is pointed to by a given hyperlink .
i ) be true if i ) return
we de ( cid : 123 ) ne a relation linked ( u; v ) that represents the cases where there is a direct hyperlink from u to v , or where there is a path from u to v following the directed edges of hyperlinks : ( 123 ) 123w such that linked ( u; w ) and linked ( w; v ) .
i such that hyperlink ( tu
i ) = true and range ( tu
i ) = v , or
we de ( cid : 123 ) ne a relation connected ( u; v ) that represents the cases where there is a path from u to v following the undirected edges of hyperlinks : ( 123 ) 123w such that connected ( u; w ) and connected ( w; v ) .
i such that hyperlink ( tu i such that hyperlink ( tv
i ) = true and range ( tu i ) = true and range ( tv
i ) = v , or i ) = u , or
let us de ( cid : 123 ) ne a segment of hypertext as follows :
( 123 ) a segment can consist of a subsequence of tokens in a page , ( tp
where 123 ( cid : 123 ) s ( cid : 123 ) e ( cid : 123 ) n .
( 123 ) a segment can consist of a page itself , p = ( tp ( 123 ) a segment can consist of a rooted subgraph of pages : p = p123 ( fpi j 123pj 123
p; linked ( pj; pi ) g .
here , p123 represents the root of the subgraph .
we de ( cid : 123 ) ne a relation contains ( u; v ) that holds between two segments , u and v under the following conditions :
( 123 ) both u and v are pages or sequences of tokens within pages , tu
graph , and page ( u ) 123 v ,
( 123 ) u is a either a page or a sequence of tokens within a page , v is a rooted ( 123 ) both u and v are rooted graphs , and u ( cid : 123 ) v .
finally , let the predicate modelu ( v ) be true when the segment v satis ( cid : 123 ) es an
arbitrary statistical model representing vs relatedness to u .
now , using these de ( cid : 123 ) nitions , we state our assumptions about how class and relation instances can be represented on the web .
( cid : 123 ) we assume that each instance of an ontology class is represented by one or ( cid : 123 ) we assume that each instance r ( a , b ) of a relation r is represented in one of three ways .
let sa be the segment representing a and sb be the segment representing b .
then r ( a , b ) can be represented by :
more hypertext segments as de ( cid : 123 ) ned above .
( 123 ) connected ( sa; sb ) , ( 123 ) contains ( sa; sb ) , or ( 123 ) modelb ( sa ) = true .
b obtaining more evenly distributed scores from naive bayes
while naive bayes often provides accurate classi ( cid : 123 ) cations , it presents problems when one wants to interpret the score for each class as an estimate of un - certainty .
per - class scores for the winning class tend to gravitate toward 123 and scores for the losing class tend toward 123 .
often the e ( cid : 123 ) ect is so strong that oating - point round - o ( cid : 123 ) error causes the probability to be calculated as exactly 123 for the winning class and 123 for the others .
these extreme values are an artifact of the independence assumption .
if for each word , the value of pr ( wjc ) between di ( cid : 123 ) erent classes di ( cid : 123 ) ers by one order of magnitude , then the ( cid : 123 ) nal probabilities will di ( cid : 123 ) er by as many orders of magnitude as there are words in the document .
class - conditional word probabilities would be much more similar across classes if word dependencies were taken into account .
we would like scores that accurately reect the uncertainty in each predic - tion and enable us to sensibly compare the scores of multiple documents .
we attempt to counter the extreme values , while still avoiding the complexity of modeling word - dependencies , in two steps .
first , instead of using the product of the word likelihoods , we use the geometric mean of the likelihoods .
this approach is closely related to the concept of perplexity in language modeling for speech recognition ( 123 ) .
perplexity is a measure of the likelihood of some data given a model , where the likelihood is normalized for the length of the data .
we begin with naive bayes ( eq .
123 ) , rewrite the sum to an equivalent expression that sums over all words in the vocabulary t instead of just the words in the document ( eq .
b . 123 ) , take the log , ( eq .
b . 123 ) , and divide by the number of words in the document ( eq .
this results in the log of the geometric mean of the word likelihoods , plus a term for the class prior .
pr ( wijc ) = pr ( c )
/ log ( pr ( c ) ) +
n ( wi; d ) log ( pr ( wijc ) )
if we interpret n ( wi; d ) =n as pr ( wijd ) , the right - hand term of this expression
is the negative cross entropy ( 123 ) between the distribution of words induced
by the document with the distribution of words induced by the class :
thus , the second term speci ( cid : 123 ) es that the class c with the highest score will be the one with the lowest cross entropy|the class that could \compress " the document most e ( cid : 123 ) ciently .
this expression results in scores for each class that vary smoothly , without tendencies toward extreme values .
cross entropy in equation b . 123 can be intuitively understood as the average number of bits necessary to encode a word from the document using an en - coding that is optimal for the distribution of words independently drawn from the class .
cross entropy does not , however , account for the varying di ( cid : 123 ) culty of encoding di ( cid : 123 ) erent documents|some documents are more complex , and in - herently require more bits on average to encode .
we want scores that can be sensibly compared between documents .
a way to account for di ( cid : 123 ) erences be - tween documents is to use kulback - leibler divergence|that is , to subtract the average number of bits it would take to encode the document using its optimal encoding ( assuming again , that the words are independent of one an - other ) .
this results in an expression that can be intuitively understood as the average number of extra bits required because we are using a subopti - mal encoding instead of the optimal encoding .
we modify the second term of equation b . 123 so that it expresses the kl divergence score for each class :
we also normalize the scores across all classes so that they sum to a con - stant .
this normalization also has the e ( cid : 123 ) ect of increasing our con ( cid : 123 ) dence in the classi ( cid : 123 ) cation of documents with high word entropy .
this is intuitively de - sirable because high - entropy documents have more unique words , which can be considered as stronger evidence , and more likely to result in a correct clas -
note that the modi ( cid : 123 ) cations to 123 do not change the ordering of class estimates for a given document .
consequently , the classi ( cid : 123 ) cations made by naive bayes are not a ( cid : 123 ) ected .
these modi ( cid : 123 ) cations only serve to provide well - distributed ,
note that none of the changes since straightforward naive bayes in equation 123 has changed the scored ordering of di ( cid : 123 ) erent classes for the same document| they have not changed classi ( cid : 123 ) cation that would have resulted from naive
they have only served to provide well - distributed , comparable scores .
c the url grouping algorithm
in this appendix , we present the details of the algorithm used to identify multi - page segments .
as discussed in section 123 , we use the regularities in url structure and naming to group related pages together , and to identify the any primary home pages in each group .
in the algorithm below , all wildcards must match some text .
the wildcard * does not match across directory boundaries , but the wildcard @ does .
the wildcard ? matches a single digit .
the wildcard variable %123 does not match ( cid : 123 ) inputs : a set of web pages , each with a url , a tentative classi ( cid : 123 ) cation and ( cid : 123 ) for each web page , identify its group : ( cid : 123 ) the group is the longest pre ( cid : 123 ) x ( indicated in parentheses ) when the url
matches any of the patterns :
( cid : 123 ) if no pre ( cid : 123 ) x matches , the group is the complete directory portion of the ( cid : 123 ) for each group , identify at least one primary page : ( cid : 123 ) a primary page is any page which url matches :
( cid : 123 ) if no page in the group matches one of these patterns , then the page with the highest score for any non - other class is a primary page .
( cid : 123 ) change the classi ( cid : 123 ) cation of all non - primary pages to other .
( cid : 123 ) outputs : the ( cid : 123 ) nal classi ( cid : 123 ) cation and score of each web page .
