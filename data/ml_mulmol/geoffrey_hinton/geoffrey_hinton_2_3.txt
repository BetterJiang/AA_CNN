deep and recurrent neural networks ( dnns and rnns respectively ) are powerful mod - els that were considered to be almost impos - sible to train using stochastic gradient de - scent with momentum .
in this paper , we show that when stochastic gradient descent with momentum uses a well - designed random initialization and a particular type of slowly increasing schedule for the momentum pa - rameter , it can train both dnns and rnns ( on datasets with long - term dependencies ) to levels of performance that were previously achievable only with hessian - free optimiza - tion .
we nd that both the initialization and the momentum are crucial since poorly initialized networks cannot be trained with momentum and well - initialized networks per - form markedly worse when the momentum is absent or poorly tuned .
our success training these models suggests that previous attempts to train deep and re - current neural networks from random initial - izations have likely failed due to poor ini - tialization schemes .
furthermore , carefully tuned momentum methods suce for dealing with the curvature issues in deep and recur - rent network training objectives without the need for sophisticated second - order methods .
deep and recurrent neural networks ( dnns and rnns , respectively ) are powerful models that achieve high performance on dicult pattern recognition prob - lems in vision , and speech ( krizhevsky et al . , 123; hinton et al . , 123; dahl et al . , 123; graves , 123 ) .
although their representational power is appealing , the diculty of training dnns has prevented their
proceedings of the 123 th international conference on ma - chine learning , atlanta , georgia , usa , 123
w&cp volume 123
copyright 123 by the author ( s ) .
widepread use until fairly recently .
dnns became the subject of renewed attention following the work of hinton et al .
( 123 ) who introduced the idea of greedy layerwise pre - training .
this approach has since branched into a family of methods ( bengio et al . , 123 ) , all of which train the layers of the dnn in a sequence using an auxiliary objective and then ne - tune the entire network with standard optimization methods such as stochastic gradient descent ( sgd ) .
more recently , martens ( 123 ) attracted considerable attention by showing that a type of truncated - newton method called hessian - free optimization ( hf ) is capa - ble of training dnns from certain random initializa - tions without the use of pre - training , and can achieve lower errors for the various auto - encoding tasks con - sidered by hinton & salakhutdinov ( 123 ) .
recurrent neural networks ( rnns ) , the temporal ana - logue of dnns , are highly expressive sequence mod - els that can model complex sequence relationships .
they can be viewed as very deep neural networks that have a layer for each time - step with parame - ter sharing across the layers and , for this reason , they are considered to be even harder to train than dnns .
recently , martens & sutskever ( 123 ) showed that the hf method of martens ( 123 ) could eectively train rnns on articial problems that exhibit very long - range dependencies ( hochreiter & schmidhuber , 123 ) .
without resorting to special types of memory units , these problems were considered to be impossi - bly dicult for rst - order optimization methods due to the well known vanishing gradient problem ( bengio et al . , 123 ) .
sutskever et al .
( 123 ) and later mikolov et al .
( 123 ) then applied hf to train rnns to per - form character - level language modeling and achieved
recently , several results have appeared to challenge the commonly held belief that simpler rst - order methods are incapable of learning deep models from random initializations .
the work of glorot & ben - gio ( 123 ) , mohamed et al .
( 123 ) , and krizhevsky et al .
( 123 ) reported little diculty training neural networks with depths up to 123 from certain well - chosen
123work was done while the author was at the university
on the importance of initialization and momentum in deep learning
random initializations .
notably , chapelle & erhan ( 123 ) used the random initialization of glorot & ben - gio ( 123 ) and sgd to train the 123 - layer autoencoder of hinton & salakhutdinov ( 123 ) , and were able to surpass the results reported by hinton & salakhutdi - nov ( 123 ) .
while these results still fall short of those reported in martens ( 123 ) for the same tasks , they indicate that learning deep networks is not nearly as hard as was previously believed .
the rst contribution of this paper is a much more thorough investigation of the diculty of training deep and temporal networks than has been previously done .
in particular , we study the eectiveness of sgd when combined with well - chosen initialization schemes and various forms of momentum - based acceleration .
we show that while a denite performance gap seems to exist between plain sgd and hf on certain deep and temporal learning problems , this gap can be elimi - nated or nearly eliminated ( depending on the prob - lem ) by careful use of classical momentum methods or nesterovs accelerated gradient .
in particular , we show how certain carefully designed schedules for the constant of momentum , which are inspired by var - ious theoretical convergence - rate theorems ( nesterov , 123; 123 ) , produce results that even surpass those re - ported by martens ( 123 ) on certain deep - autencoder training tasks .
for the long - term dependency rnn tasks examined in martens & sutskever ( 123 ) , which rst appeared in hochreiter & schmidhuber ( 123 ) , we obtain results that fall just short of those reported in that work , where a considerably more complex ap - proach was used .
our results are particularly surprising given that mo - mentum and its use within neural network optimiza - tion has been studied extensively before , such as in the work of orr ( 123 ) , and it was never found to have such an important role in deep learning .
one explanation is that previous theoretical analyses and practical bench - marking focused on local convergence in the stochastic setting , which is more of an estimation problem than an optimization one ( bottou & lecun , 123 ) .
in deep learning problems this nal phase of learning is not nearly as long or important as the initial transient phase ( darken & moody , 123 ) , where a better ar - gument can be made for the benecial eects of mo -
in addition to the inappropriate focus on purely local convergence rates , we believe that the use of poorly de - signed standard random initializations , such as those in hinton & salakhutdinov ( 123 ) , and suboptimal meta - parameter schedules ( for the momentum con - stant in particular ) has hampered the discovery of the true eectiveness of rst - order momentum methods in deep learning .
we carefully avoid both of these pit - falls in our experiments and provide a simple to under - stand and easy to use framework for deep learning that
is surprisingly eective and can be naturally combined with techniques such as those in raiko et al .
( 123 ) .
we will also discuss the links between classical mo - mentum and nesterovs accelerated gradient method ( which has been the subject of much recent study in convex optimization theory ) , arguing that the latter can be viewed as a simple modication of the former which increases stability , and can sometimes provide a distinct improvement in performance we demonstrated in our experiments .
we perform a theoretical analysis which makes clear the precise dierence in local be - havior of these two algorithms .
additionally , we show how hf employs what can be viewed as a type of mo - mentum through its use of special initializations to conjugate gradient that are computed from the up - date at the previous time - step .
we use this property to develop a more momentum - like version of hf which combines some of the advantages of both methods to further improve on the results of martens ( 123 ) .
momentum and nesterovs
the momentum method ( polyak , 123 ) , which we refer to as classical momentum ( cm ) , is a technique for ac - celerating gradient descent that accumulates a velocity vector in directions of persistent reduction in the ob - jective across iterations .
given an objective function f ( ) to be minimized , classical momentum is given by :
vt+123 = vt " rf ( t ) t+123 = t + vt+123
where " > 123 is the learning rate , 123 ( 123 , 123 ) is the mo - mentum coecient , and rf ( t ) is the gradient at t .
since directions d of low - curvature have , by deni - tion , slower local change in their rate of reduction ( i . e . , d>rf ) , they will tend to persist across iterations and be amplied by cm .
second - order methods also am - plify steps in low - curvature directions , but instead of accumulating changes they reweight the update along each eigen - direction of the curvature matrix by the in - verse of the associated curvature .
and just as second - order methods enjoy improved local convergence rates , polyak ( 123 ) showed that cm can considerably accel - erate convergence to a local minimum , requiring pr - times fewer iterations than steepest descent to reach the same level of accuracy , where r is the condition number of the curvature at the minimum and is set
to ( pr 123 ) / ( pr + 123 ) .
nesterovs accelerated gradient ( abbrv .
nag; nes - terov , 123 ) has been the subject of much recent at - tention by the convex optimization community ( e . g . , cotter et al . , 123; lan , 123 ) .
like momentum , nag is a rst - order optimization method with better convergence rate guarantee than gradient descent in
on the importance of initialization and momentum in deep learning
in particular , for general smooth ( non - strongly ) convex functions and a deterministic gradient , nag achieves a global convergence rate of o ( 123 / t 123 ) ( versus the o ( 123 / t ) of gradient descent ) , with constant proportional to the lipschitz coecient of the derivative and the squared euclidean distance to the solution .
while nag is not typically thought of as a type of momentum , it indeed turns out to be closely re - lated to classical momentum , diering only in the pre - cise update of the velocity vector v , the signicance of which we will discuss in the next sub - section .
speci - cally , as shown in the appendix , the nag update may be rewritten as :
vt+123 = vt " rf ( t + vt ) t+123 = t + vt+123
while the classical convergence theories for both meth - ods rely on noiseless gradient estimates ( i . e . , not stochastic ) , with some care in practice they are both applicable to the stochastic setting .
however , the the - ory predicts that any advantages in terms of asymp - totic local rate of convergence will be lost ( orr , 123; wiegerinck et al . , 123 ) , a result also conrmed in ex - periments ( lecun et al . , 123 ) .
for these reasons , interest in momentum methods diminished after they had received substantial attention in the 123s .
and be - cause of this apparent incompatibility with stochastic optimization , some authors even discourage using mo - mentum or downplay its potential advantages ( lecun et al . , 123 ) .
however , while local convergence is all that matters in terms of asymptotic convergence rates ( and on cer - tain very simple / shallow neural network optimization problems it may even dominate the total time ) , in practice , the transient phase of convergence ( darken & moody , 123 ) , which occurs before ne lo - cal convergence sets in , seems to matter a lot more for optimizing deep neural networks .
in this transient phase of learning , directions of reduction in the ob - jective tend to persist across many successive gradient estimates and are not completely swamped by noise .
although the transient phase of learning is most no - ticeable in training deep learning models , it is still no - ticeable in convex objectives .
the convergence rate of stochastic gradient descent on smooth convex func - tions is given by o ( l / t + / pt ) , where is the variance in the gradient estimate and l is the lip - shits coecient of rf .
in contrast , the convergence rate of an accelerated gradient method of lan ( 123 ) ( which is related to but dierent from nag , in that it combines nesterov style momentum with dual aver - aging ) is o ( l / t 123 + / pt ) .
thus , for convex objec - tives , momentum - based methods will outperform sgd in the early or transient stages of the optimization where l / t is the dominant term .
however , the two methods will be equally eective during the nal stages
terov accelerated gradient
( top ) classical momentum ( bottom ) nes -
of the optimization where / pt is the dominant term ( i . e . , when the optimization problem resembles an es -
the relationship between cm and nag
from eqs .
123 - 123 we see that both cm and nag compute the new velocity by applying a gradient - based correc - tion to the previous velocity vector ( which is decayed ) , and then add the velocity to t .
but while cm com - putes the gradient update from the current position t , nag rst performs a partial update to t , comput - ing t + vt , which is similar to t+123 , but missing the as yet unknown correction .
this benign - looking dif - ference seems to allow nag to change v in a quicker and more responsive way , letting it behave more sta - bly than cm in many situations , especially for higher values of .
indeed , consider the situation where the addition of vt results in an immediate undesirable increase in the objective f .
the gradient correction to the ve - locity vt is computed at position t + vt and if vt is indeed a poor update , then rf ( t + vt ) will point back towards t more strongly than rf ( t ) does , thus providing a larger and more timely correction to vt than cm .
123 for a diagram which illustrates this phenomenon geometrically .
while each iteration of nag may only be slightly more eective than cm at correcting a large and inappropriate velocity , this dierence in eectiveness may compound as the al - gorithms iterate .
to demonstrate this compounding , we applied both nag and cm to a two - dimensional oblong quadratic objective , both with the same mo - mentum and learning rate constants ( see g .
123 in the appendix ) .
while the optimization path taken by cm exhibits large oscillations along the high - curvature ver - tical direction , nag is able to avoid these oscillations almost entirely , conrming the intuition that it is much more eective than cm at decelerating over the course of multiple iterations , thus making nag more tolerant of large values of compared to cm .
in order to make these intuitions more rigorous and
on the importance of initialization and momentum in deep learning
help quantify precisely the way in which cm and nag dier , we analyzed the behavior of each method when applied to a positive denite quadratic objective q ( x ) = x>ax / 123 + b>x .
we can think of cm and nag as operating independently over the dierent eigendi - rections of a .
nag operates along any one of these directions equivalently to cm , except with an eective value of that is given by ( 123 " ) , where is the
q ( x ) = q ( u>y ) = y>uu>du u>y / 123 + b>u>y = p as p ( y ) =pn
the rst step of this argument is to reparameterize q ( x ) in terms of the coecients of x under the basis of eigenvectors of a .
note that since a = u>du for a diagonal d and orthonormal u ( as a is symmetric ) , we can reparameterize q ( x ) by the matrix transform u and optimize y = u x using the objective p ( y ) y>dy / 123 + c>y , where c = u b .
we can further rewrite i=123 ( p ) i ( ( y ) i ) , where ( p ) i ( t ) = it123 / 123+ ( c ) it and i > 123 are the diagonal entries of d ( and thus the eigenvalues of a ) and correspond to the curva - ture along the associated eigenvector directions .
as shown in the appendix ( proposition 123 ) , both cm and nag , being rst - order methods , are invariant to these kinds of reparameterizations by orthonormal transformations such as u .
thus when analyzing the behavior of either algorithm applied to q ( x ) , we can in - stead apply them to p ( y ) , and transform the resulting sequence of iterates back to the default parameteriza - tion ( via multiplication by u123 = u> ) .
theorem 123 .
let p ( y ) = pn
i=123 ( p ) i ( ( y ) i ) such that ( p ) i ( t ) = it123 / 123 + cit .
let " be arbitrary and xed .
denote by cm x ( , p , y , v ) and cm v ( , p , y , v ) the pa - rameter vector and the velocity vector respectively , ob - tained by applying one step of cm ( i . e . , eq .
123 and then eq .
123 ) to the function p at point y , with velocity v , momentum coecient , and learning rate " .
dene n agx and n agv analogously .
then the following holds for z 123 ( x , v ) :
cm z ( , ( p ) 123 , ( y ) 123 , ( v ) 123 )
cm z ( , ( p ) n , ( y ) n , ( v ) n ) cm z ( ( 123 123 " ) , ( p ) 123 , ( y ) 123 , ( v ) 123 )
cm z ( , p , y , v ) =123 n agz ( , p , y , v ) =123
cm z ( ( 123 n " ) , ( p ) n , ( y ) n , ( v ) n )
see the appendix .
the theorem has several implications .
first , cm and nag become equivalent when " is small ( when " 123 for every eigenvalue of a ) , so nag and cm are distinct only when " is reasonably large .
when " is relatively large , nag uses smaller eective momentum for the high - curvature eigen - directions , which prevents
oscillations ( or divergence ) and thus allows the use of a larger than is possible with cm for a given " .
deep autoencoders
the aim of our experiments is three - fold .
first , to investigate the attainable performance of stochastic momentum methods on deep autoencoders starting from well - designed random initializations; second , to explore the importance and eect of the schedule for the momentum parameter assuming an optimal xed choice of the learning rate " ; and third , to compare the performance of nag versus cm .
for our experiments with feed - forward nets , we fo - cused on training the three deep autoencoder prob - lems described in hinton & salakhutdinov ( 123 ) ( see sec .
a . 123 for details ) .
the task of the neural net - work autoencoder is to reconstruct its own input sub - ject to the constraint that one of its hidden layers is of low - dimension .
this bottleneck layer acts as a low - dimensional code for the original input , similar to other dimensionality reduction techniques like princi - ple component analysis ( pca ) .
these autoencoders are some of the deepest neural networks with pub - lished results , ranging between 123 and 123 layers , and have become a standard benchmarking problem ( e . g . , martens , 123; glorot & bengio , 123; chapelle & er - han , 123; raiko et al . , 123 ) .
see the appendix for
because the focus of this study is on optimization , we only report training errors in our experiments .
test error depends strongly on the amount of overtting in these problems , which in turn depends on the type and amount of regularization used during training .
while regularization is an issue of vital importance when de - signing systems of practical utility , it is outside the scope of our discussion .
and while it could be ob - jected that the gains achieved using better optimiza - tion methods are only due to more exact tting of the training set in a manner that does not generalize , this is simply not the case in these problems , where under - trained solutions are known to perform poorly on both the training and test sets ( undertting ) .
the networks we trained used the standard sigmoid nonlinearity and were initialized using the sparse ini - tialization technique ( si ) of martens ( 123 ) that is described in sec .
each trial consists of 123 , 123 parameter updates on minibatches of size 123
no reg - ularization is used .
the schedule for was given by the following formula :
t = min ( 123 123log123 ( bt / 123c+123 ) , max )
( 123 , 123 , 123 , 123 , 123 ) .
this schedule was mo - tivated by nesterov ( 123 ) who advocates using what amounts to t = 123 123 / ( t + 123 ) after some manipulation
on the importance of initialization and momentum in deep learning
123n 123n 123n 123n
123m 123m 123m 123m sgdc
table 123
the table reports the squared errors on the problems for each combination of max and a momentum type ( nag , cm ) .
when max is 123 the choice of nag vs cm is of no consequence so the training errors are presented in a single column .
for each choice of max , the highest - performing learning rate is used .
the column sgdc lists the results of chapelle & erhan ( 123 ) who used 123m sgd steps and tanh networks .
the column hf lists the results of hf without l123 regularization , as described in sec .
123; and the column hf lists the results of martens ( 123 ) .
table 123
the eect of low - momentum netuning for nag .
the table shows the training squared errors before and after the momentum coecient is reduced .
during the pri - mary ( transient ) phase of learning we used the optimal momentum and learning rates .
( see appendix ) , and by nesterov ( 123 ) who advocates a constant t that depends on ( essentially ) the con - dition number .
the constant t achieves exponential convergence on strongly convex functions , while the 123 123 / ( t + 123 ) schedule is appropriate when the function is not strongly convex .
the schedule of eq .
123 blends these proposals .
for each choice of max , we report the learning rate that achieved the best training error .
given the schedule for , the learning rate " was chosen from ( 123 , 123 , 123 , 123 , 123 , 123 ) in order to achieve the lowest nal error training error after our xed number of updates .
table 123 summarizes the results of these experiments .
it shows that nag achieves the lowest published results on this set of problems , including those of it also shows that larger values of max tend to achieve better performance and that nag usually outperforms cm , especially when max is 123 and 123 .
most surprising and importantly , the results demonstrate that nag can achieve results that are comparable with some of the best hf results for training deep autoencoders .
note that the previ - ously published results on hf used l123 regularization , so they cannot be directly compared .
however , the table also includes experiments we performed with an improved version of hf ( see sec .
123 ) where weight decay was removed towards the end of training .
we found it benecial to reduce to 123 ( unless is 123 , in which case it is unchanged ) during the nal 123 parameter updates of the optimization without reducing the learning rate , as shown in table 123
appears that reducing the momentum coecient al - lows for ner convergence to take place whereas oth - erwise the overly aggressive nature of cm or nag
would prevent this .
this phase shift between opti - mization that favors fast accelerated motion along the error surface ( the transient phase ) followed by more careful optimization - as - estimation phase seems consis - tent with the picture presented by darken & moody ( 123 ) .
however , while asymptotically it is the second phase which must eventually dominate computation time , in practice it seems that for deeper networks in particular , the rst phase dominates overall computa - tion time as long as the second phase is cut o before the remaining potential gains become either insigni - cant or entirely dominated by overtting ( or both ) .
it may be tempting then to use lower values of from the outset , or to reduce it immediately when progress in reducing the error appears to slow down .
however , in our experiments we found that doing this was detri - mental in terms of the nal errors we could achieve , and that despite appearing to not make much progress , or even becoming signicantly non - monotonic , the op - timizers were doing something apparently useful over these extended periods of time at higher values of .
a speculative explanation as to why we see this be - havior is as follows .
while a large value of allows the momentum methods to make useful progress along slowly - changing directions of low - curvature , this may not immediately result in a signicant reduction in er - ror , due to the failure of these methods to converge in the more turbulent high - curvature directions ( which is especially hard when is large ) .
nevertheless , this progress in low - curvature directions takes the optimiz - ers to new regions of the parameter space that are characterized by closer proximity to the optimum ( in the case of a convex objective ) , or just higher - quality local minimia ( in the case of non - convex optimiza - tion ) .
thus , while it is important to adopt a more careful scheme that allows ne convergence to take place along the high - curvature directions , this must be done with care .
reducing and moving to this ne convergence regime too early may make it dicult for the optimization to make signicant progress along the low - curvature directions , since without the benet of momentum - based acceleration , rst - order methods are notoriously bad at this ( which is what motivated the use of second - order methods like hf for deep learn -
on the importance of initialization and momentum in deep learning
si scale multiplier
table 123
the table reports the training squared error that is attained by changing the scale of the initialization .
random initializations
the results in the previous section were obtained with standard logistic sigmoid neural networks that were initialized with the sparse initialization technique ( si ) described in martens ( 123 ) .
in this scheme , each ran - dom unit is connected to 123 randomly chosen units in the previous layer , whose weights are drawn from a unit gaussian , and the biases are set to zero .
the in - tuitive justication is that the total amount of input to each unit will not depend on the size of the previ - ous layer and hence they will not as easily saturate .
meanwhile , because the inputs to each unit are not all randomly weighted blends of the outputs of many 123s or 123s of units in the previous layer , they will tend to be qualitatively more diverse in their response to inputs .
when using tanh units , we transform the weights to simulate sigmoid units by setting the biases to 123 and rescaling the weights by 123 .
we investigated the performance of the optimization as a function of the scale constant used in si ( which defaults to 123 for sigmoid units ) .
we found that si works reasonably well if it is rescaled by a factor of 123 , but leads to noticeable ( but not severe ) slow down when scaled by a factor of 123
when we used the factor 123 / 123 or 123 we did not achieve sensible results .
recurrent neural networks
echo - state networks ( esns ) is a family of rnns with an unusually simple training method : their hidden - to - output connections are learned from data , but their re - current connections are xed to a random draw from a specic distribution and are not learned .
despite their simplicity , esns with many hidden units ( or with units with explicit temporal integration , like the lstm ) have achieved high performance on tasks with long range dependencies ( ? ) .
in this section , we inves - tigate the eectiveness of momentum - based methods with esn - inspired initialization at training rnns with conventional size and standard ( i . e . , non - integrating ) neurons .
we nd that momentum - accelerated sgd can successfully train such rnns on various articial datasets exhibiting considerable long - range temporal dependencies .
this is unexpected because rnns were believed to be almost impossible to successfully train on such datasets with rst - order methods , due to var - ious diculties such as vanishing / exploding gradients ( bengio et al . , 123 ) .
while we found that the use of momentum signicantly improved performance and robustness , we obtained nontrivial results even with standard sgd , provided that the learning rate was set low enough .
spectral radius of 123
123n ( 123 , 123 ) 123n ( 123 , 123 ) 123n ( 123 , 123 )
average of outputs
table 123
the rnn initialization used in the experiments .
the scale of the vis - hid connections is problem dependent .
each task involved optimizing the parameters of a ran - domly initialized rnn with 123 standard tanh hidden units ( the same model used by martens & sutskever ( 123 ) ) .
the tasks were designed by hochreiter & schmidhuber ( 123 ) , and are referred to as training problems .
see sec .
a . 123 of the appendix for details .
esn - based initialization
as argued by jaeger & haas ( 123 ) , the spectral ra - dius of the hidden - to - hidden matrix has a profound eect on the dynamics of the rnns hidden state ( with a tanh nonlinearity ) .
when it is smaller than 123 , the dynamics will have a tendency to quickly for - get whatever input signal they may have been ex - posed to .
when it is much larger than 123 , the dy - namics become oscillatory and chaotic , allowing it to generate responses that are varied for dierent input histories .
while this allows information to be retained over many time steps , it can also lead to severe explod - ing gradients that make gradient - based learning much more dicult .
however , when the spectral radius is only slightly greater than 123 , the dynamics remain os - cillatory and chaotic while the gradient are no longer exploding ( and if they do explode , then only slightly so ) , so learning may be possible with a spectral ra - dius of this order .
this suggests that a spectral radius of around 123 may be eective .
to achieve robust results , we also found it is essential to carefully set the initial scale of the input - to - hidden connections .
when training rnns to solve those tasks that possess many random and irrelevant distractor in - puts , we found that having the scale of these connec - tions set too high at the start led to relevant informa - tion in the hidden state being too easily overwritten by the many irrelevant signals , which ultimately led the optimizer to converge towards an extremely poor local minimum where useful information was never re - layed over long distances .
conversely , we found that if this scale was set too low , it led to signicantly slower learning .
having experimented with multiple scales we found that a gaussian draw with a standard deviation of 123 achieved a good balance between these con - cerns .
however , unlike the value of 123 for the spectral radius of the dynamics matrix , which worked well on all tasks , we found that good choices for initial scale of the input - to - hidden weights depended a lot on the particular characteristics of the particular task ( such
on the importance of initialization and momentum in deep learning
as its dimensionality or the input variance ) .
indeed , for tasks that do not have many irrelevant inputs , a larger scale of the input - to - hidden weights ( namely , 123 ) worked better , because the aforementioned dis - advantage of large input - to - hidden weights does not apply .
see table 123 for a summary of the initializations used in the experiments .
finally , we found centering ( mean subtraction ) of both the inputs and the outputs to be important to reliably solve all of the training problems .
see the appendix for more details .
experimental results
we conducted experiments to determine the e - cacy of our initializations , the eect of momentum , and to compare nag with cm .
every learning trial used the aforementioned initialization , 123 , 123 param - eter updates and on minibatches of 123 sequences , and the following schedule for the momentum co - ecient : = 123 for the rst 123 parameter , after which = 123 , where 123 can take the fol - lowing values ( 123 , 123 , 123 , 123 ) .
for each 123 , we use the empirically best learning rate chosen from ( 123 , 123 , 123 , 123 ) .
the results are presented in table 123 , which are the av - erage loss over 123 dierent random seeds .
instead of re - porting the loss being minimized ( which is the squared error or cross entropy ) , we use a more interpretable zero - one loss , as is standard practice with these prob - lems .
for the bit memorization , we report the frac - tion of timesteps that are computed incorrectly .
and for the addition and the multiplication problems , we report the fraction of cases where the rnn the error in the nal output prediction exceeded 123 .
our results show that despite the considerable long - range dependencies present in training data for these problems , rnns can be successfully and robustly trained to solve them , through the use of the initial - ization discussed in sec .
123 , momentum of the nag type , a large 123 , and a particularly small learning rate ( as compared with feedforward networks ) .
our results also suggest that with larger values of 123 achieve bet - ter results with nag but not with cm , possibly due to nags tolerance of larger 123s ( as discussed in sec
although we were able to achieve surprisingly good training performance on these problems using a suf - ciently strong momentum , the results of martens & sutskever ( 123 ) appear to be moderately better and more robust .
they achieved lower error rates and their initialization was chosen with less care , although the initializations are in many ways similar to ours .
no - tably , martens & sutskever ( 123 ) were able to solve these problems without centering , while we had to use centering to solve the multiplication problem ( the other problems are already centered ) .
this suggests that the initialization proposed here , together with the method of martens & sutskever ( 123 ) , could achieve
even better performance .
but the main achievement of these results is a demonstration of the ability of momentum methods to cope with long - range tempo - ral dependency training tasks to a level which seems sucient for most practical purposes .
moreover , our approach seems to be more tolerant of smaller mini - batches , and is considerably simpler than the partic - ular version of hf proposed in martens & sutskever ( 123 ) , which used a specialized update damping tech - nique whose benets seemed mostly limited to training rnns to solve these kinds of extreme temporal depen -
momentum and hf
truncated newton methods , that include the hf method of martens ( 123 ) as a particular example , work by optimizing a local quadratic model of the objective via the linear conjugate gradient algorithm ( cg ) , which is a rst - order method .
while hf , like all truncated - newton methods , takes steps computed using partially converged calls to cg , it is naturally accelerated along at least some directions of lower cur - vature compared to the gradient .
it can even be shown ( martens & sutskever , 123 ) that cg will tend to fa - vor convergence to the exact solution to the quadratic sub - problem rst along higher curvature directions ( with a bias towards those which are more clustered together in their curvature - scalars / eigenvalues ) .
while cg accumulates information as it iterates which allows it to be optimal in a much stronger sense than any other rst - order method ( like nag ) , once it is terminated , this information is lost .
thus , standard truncated newton methods can be thought of as per - sisting information which accelerates convergence ( of the current quadratic ) only over the number of itera - tions cg performs .
by contrast , momentum methods persist information that can inform new updates across an arbitrary number of iterations .
one key dierence between standard truncated new - ton methods and hf is the use of hot - started calls to cg , which use as their initial solution the one found at the previous call to cg .
while this solution was com - puted using old gradient and curvature information from a previous point in parameter space and possi - bly a dierent set of training data , it may be well - converged along certain eigen - directions of the new quadratic , despite being very poorly converged along others ( perhaps worse than the default initial solution of ~ 123 ) .
however , to the extent to which the new local quadratic model resembles the old one , and in partic - ular in the more dicult to optimize directions of low - curvature ( which will arguably be more likely to per - sist across nearby locations in parameter space ) , the previous solution will be a preferable starting point to 123 , and may even allow for gradually increasing levels of convergence along certain directions which persist
on the importance of initialization and momentum in deep learning
add t = 123 mul t = 123
mem - 123 t = 123 mem - 123 t = 123
123m 123m 123m
table 123
each column reports the errors ( zero - one losses; sec .
123 ) on dierent problems for each combination of 123 and momentum type ( nag , cm ) , averaged over 123 dierent random seeds .
the biases column lists the error attainable by learning the output biases and ignoring the hidden state .
this is the error of an rnn that failed to establish communi - cation between its inputs and targets .
for each 123 , we used the xed learning rate that gave the best performance .
in the local quadratic models across many updates .
the connection between hf and momentum methods can be made more concrete by noticing that a single step of cg is eectively a gradient update taken from the current point , plus the previous update reapplied , just as with nag , and that if cg terminated after just 123 step , hf becomes equivalent to nag , except that it uses a special formula based on the curvature matrix for the learning rate instead of a xed constant .
the most eective implementations of hf even employ a decay constant ( martens & sutskever , 123 ) which acts analogously to the momentum constant .
thus , in this sense , the cg initializations used by hf allow us to view it as a hybrid of nag and an exact second - order method , with the number of cg iterations used to compute each update eectively acting as a dial between the two extremes .
inspired by the surprising success of momentum - based methods for deep learning problems , we experimented with making hf behave even more like nag than it al - ready does .
the resulting approach performed surpris - ingly well ( see table 123 ) .
for a more detailed account of these experiments , see sec .
a . 123 of the appendix .
if viewed on the basis of each cg step ( instead of each update to parameters ) , hf can be thought of as a peculiar type of rst - order method which approx - imates the objective as a series of quadratics only so that it can make use of the powerful rst - order cg method .
so apart from any potential benet to global convergence from its tendency to prefer certain direc - tions of movement in parameter space over others , per - haps the main theoretical benet to using hf over a rst - order method like nag is its use of cg , which , while itself a rst - order method , is well known to have strongly optimal convergence properties for quadrat - ics , and can take advantage of clustered eigenvalues to accelerate convergence ( see martens & sutskever ( 123 ) for a detailed account of this well - known phe - nomenon ) .
however , it is known that in the worst case that cg , when run in batch mode , will converge asymptotically no faster than nag ( also run in batch mode ) for certain specially designed quadratics with very evenly distributed eigenvalues / curvatures .
thus it is worth asking whether the quadratics which arise during the optimization of neural networks by hf are such that cg has a distinct advantage in optimizing
them over nag , or if they are closer to the aforemen - tioned worst - case examples .
to examine this question we took a quadratic generated during the middle of a typical run of hf on the curves dataset and compared the convergence rate of cg , initialized from zero , to nag ( also initialized from zero ) .
figure 123 in the ap - pendix presents the results of this experiment .
while this experiment indicates some potential advantages to hf , the closeness of the performance of nag and hf suggests that these results might be explained by the solutions leaving the area of trust in the quadratics be - fore any extra speed kicks in , or more subtly , that the faithfulness of approximation goes down just enough as cg iterates to oset the benet of the acceleration
martens ( 123 ) and martens & sutskever ( 123 ) demonstrated the eectiveness of the hf method as a tool for performing optimizations for which previ - ous attempts to apply simpler rst - order methods had failed .
while some recent work ( chapelle & erhan , 123; glorot & bengio , 123 ) suggested that rst - order methods can actually achieve some success on these kinds of problems when used in conjunction with good initializations , their results still fell short of those re - ported for hf .
in this paper we have completed this picture and demonstrated conclusively that a large part of the remaining performance gap that is not addressed by using a well - designed random initializa - tion is in fact addressed by careful use of momentum - based acceleration ( possibly of the nesterov type ) .
we showed that careful attention must be paid to the mo - mentum constant , as predicted by the theory for local and convex optimization .
momentum - accelerated sgd , despite being a rst - order approach , is capable of accelerating directions low - curvature just like an approximate newton method such as hf .
our experiments support the idea that this is important , as we observed that the use of stronger momentum ( as determined by ) had a dra - matic eect on optimization performance , particularly for the rnns .
moreover , we showed that hf can be viewed as a rst - order method , and as a generalization of nag in particular , and that it already derives some of its benets through a momentum - like mechanism .
on the importance of initialization and momentum in deep learning
lecun , y . , bottou , l . , orr , g . , and muller , k .
ecient backprop .
neural networks : tricks of the trade , pp
martens , j .
deep learning via hessian - free optimization .
in proceedings of the 123th international conference on machine learning ( icml ) , 123
martens , j .
and sutskever , i .
learning recurrent neural networks with hessian - free optimization .
in proceedings of the 123th international conference on machine learn - ing ( icml ) , pp .
123 , 123
martens , j .
and sutskever , i .
training deep and recurrent networks with hessian - free optimization .
neural net - works : tricks of the trade , pp .
123 , 123
mikolov , tomas , sutskever ,
ilya , deoras , anoop , le , hai - son , kombrink , stefan , and cernocky , j .
word language modeling with neural networks .
preprint ( http : / / www .
cz / imikolov / rnnlm / char
mohamed , a . , dahl , g . e . , and hinton , g .
acoustic mod - eling using deep belief networks .
audio , speech , and language processing , ieee transactions on , 123 ( 123 ) : 123 123 , jan
nesterov , y .
a method of solving a convex program - ming problem with convergence rate o ( 123 / sqr ( k ) ) .
soviet mathematics doklady , 123 : 123 , 123
nesterov , y .
introductory lectures on convex optimization :
a basic course , volume 123
springer , 123
orr , g . b .
dynamics and algorithms for stochastic search .
polyak , b . t .
some methods of speeding up the convergence of iteration methods .
ussr computational mathematics and mathematical physics , 123 ( 123 ) : 123 , 123
raiko , tapani , valpola , harri , and lecun , yann .
deep learning made easier by linear transformations in percep - trons .
in nips 123 workshop on deep learning and unsupervised feature learning , sierra nevada , spain ,
sutskever , i . , martens , j . , and hinton , g .
generating text with recurrent neural networks .
in proceedings of the 123th international conference on machine learning , icml 123 , pp .
123 , june 123
wiegerinck , w . , komoda , a . , and heskes , t .
stochas - tic dynamics of learning with momentum in neural net - works .
journal of physics a : mathematical and general ,
