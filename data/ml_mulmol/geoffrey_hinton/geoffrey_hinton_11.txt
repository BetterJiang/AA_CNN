introduction .
123 natural images .
123 . 123 the dataset .
123 . 123 properties .
123 the zca whitening transformation .
123 . 123 motivation .
123 . 123 whitening lters .
123 . 123 whitened data .
123 rbms
123 . 123 training rbms .
123 123 . 123 deep belief networks ( dbns ) .
123 123 . 123 gaussian - bernoulli rbms .
123 learning visible variances .
123 123 . 123 measuring performance .
123 123 feed - forward neural networks
123 . 123 training gaussian - bernoulli rbms 123 . 123 visualizing lters
123 learning a generative model of images
123 motivation .
123 123 previous work .
123 initial attempts .
123 123 deleting directions of variance .
123 123 training on patches of images .
123 123 . 123 merging rbms trained on patches
123 training rbms on 123x123 images 123 learning visible standard deviations 123 second layer of features
123 object classication experiments
123 the labeled subset .
123 123 methods
123 parallelizing the training of rbms
introduction .
123 123 the algorithm .
123 implementation .
123 123 . 123 writer threads .
123 123 . 123 reader threads .
123 123 results .
123 123 . 123 communication cost analysis .
123 123 other algorithms
a the zca whitening transformation
b feed - forward neural networks
c labeler instruction sheet
d cifar - 123 class structure
in this work we describe how to train a multi - layer generative model of natural images .
we use a dataset of millions of tiny colour images , described in the next section .
this has been attempted by several groups but without success ( 123 , 123 ) .
the models on which we focus are rbms ( restricted boltzmann machines ) and dbns ( deep belief networks ) .
these models learn interesting - looking lters , which we show are more useful to a classier than the raw pixels .
we train the classier on a labeled subset that we have collected and call the cifar - 123 dataset .
123 natural images
123 . 123 the dataset
the tiny images dataset on which we based all of our experiments was collected by colleagues at mit and nyu over the span of six months; it is described in detail in ( 123 ) .
they assembled it by searching the web for images of every non - abstract english noun in the lexical database wordnet ( 123 , 123 ) .
they used several search engines , including google , flickr , and altavista and kept roughly the rst 123 results for each search term .
after collecting all the images for a particular search term , they removed perfect duplicates and images in which an excessively large portion of the pixels were white , as they tended to be synthetic gures rather than natural images .
the search term used to nd an image provides it with a rough label , although it is extremely unreliable due to the nature of online image search technology .
in total , the dataset contains 123 million colour images downscaled to 123 123 and spread out across 123 search terms .
most of our experiments with unsupervised learning were performed on a subset of about 123 million images .
real images have various properties that other datasets do not .
many of these properties can be made apparent by examining the covariance matrix of the tiny images dataset .
figures 123 and 123 show this
the main diagonal and its neighbours demonstrate the most apparent feature of real images : pixels are strongly correlated to nearby pixels and weakly correlated to faraway pixels .
various other properties can be observed as well , for example :
the green value of one pixel is highly correlated to the green value of a neighbouring pixel , but
slightly less correlated to the blue and red values of the neighbouring pixel .
the images tend to be symmetric about the vertical and horizontal .
for example , the colour of the top - left pixel is correlated to the colour of the top - right pixel and the bottom - left pixel .
this kind of symmetry can be observed in all pixels in the faint anti - diagonals of the covariance matrix .
it is probably caused by the way people take photographs making the ground plane horizontal and centering on the main object .
figure 123 : the covariance matrix of the tiny images dataset .
white indicates high values , black indicates low values .
all values are positive .
pixels in the 123 123 images are indexed in row - major order .
the matrix appears split into nine squares because the images have three colour channels .
the rst 123 indices represent the values of the red channel , the next 123 the values of the green channel , and the last 123 the values of the blue channel .
figure 123 : the covariance matrix of the red channel of the tiny images dataset .
this is a magnication of the top - left square of the matrix in figure 123 .
as an extension of the above point , pixels are much more correlated with faraway pixels in the
same row or column than with faraway pixels in a dierent row or column .
123 the zca whitening transformation
as mentioned above , the tiny images exhibit strong correlations between nearby pixels .
in particular , two - way correlations are quite strong .
when learning a statistical model of images , it might be nice to force the model to focus on higher - order correlations rather than get distracted by modelling two - way correlations .
the hypothesis is that this might make the model more likely to discover interesting regularities in the images rather than merely learn that nearby pixels are similar . 123
one way to force the model to ignore second - order structure is to remove it .
luckily this can be done with a data preprocessing step that just consists of multiplying the data matrix by a whitening matrix .
after the transformation , it will be impossible to predict the value of one pixel given the value of only one other pixel , so any statistical model would be wise not to try .
the transformation is described in
123 . 123 whitening lters
using the notation of appendix a , where w is the whitening matrix , each row wi of w can be thought of as a lter that is applied to the data points by taking the dot product of the lter wi and the data point xj .
if , as in our case , the data points are images , then each lter has exactly as many pixels as do the images , and so it is natural to try to visualize these lters to see the kinds of transformations they
123here when we say pixel , we are really referring to a particular colour channel of a pixel .
the transformation we will describe decorrelates the value of a particular colour channel in a particular pixel from the value of another colour channel in another ( or possibly the same ) pixel .
it does not decorrelate the values of all three colour channels in one pixel from the values of all three in another pixel .
figure 123 : whitening lters .
( a ) lters for the red , green , and blue components of pixel ( 123 , 123 ) .
( b ) lters for pixel ( 123 , 123 ) .
although surely impossible to discern on a printed page , the lter in ( a ) actually has some sup - port on the horizontally opposite side of the image , conrming once again that natural images tend to
entail .
figure 123 shows some whitening lters visualized in this way .
as mentioned , they are highly local because natural images have strong correlations between nearby pixels and weak correlations between faraway pixels .
figure 123 shows the dewhitening lters , which are the rows of w 123
applying these lters to a whitened image yields the original image .
123 . 123 whitened data
figure 123 shows some images after being transformed by w .
predictably , the transformation preserves edge information but sets to zero pixels in regions of relatively uniform colour .
an rbm ( restricted boltzmann machine ) is a type of graphical model in which the nodes are partitioned into two sets : visible and hidden .
each visible unit ( node ) is connected to each hidden unit , but there are no intra - visible or intra - hidden connections .
figure 123 illustrates this .
rbms are explored in ( 123 , 123 ) .
an rbm with v visible units and h hidden units is governed by the following energy function :
e ( v , h ) = v ( cid : 123 )
v is the binary state vector of the visible units , h is the binary state vector of the hidden units , vi is the state of visible unit i , hj is the state of hidden unit j , wij is the real - valued weight between visible unit i and hidden unit j ,
figure 123 : the dewhitening lters that correspond to the whitening lters of figure 123 .
i is the real - valued bias into visible unit i ,
j is the real - valued bias into hidden unit j .
a probability is associated with conguration ( v , h ) as follows :
p ( v , h ) =
intuitively , congurations with low energy are assigned high probability and congurations with high energy are assigned low probability .
the sum in the denominator is over all possible visible and hidden congurations , and is thus extremely hard to compute when the number of units is large .
the probability of a particular visible state conguration v is derived as follows :
p ( v ) = ( cid : 123 )
at a very high - level , the rbm training procedure consists of xing the states of the visible units v at some desired conguration and then nding settings of the parameters ( the weights and biases ) such that p ( v ) is large .
the hope is that the model will use the hidden units to generalize and to extract meaningful features from the data , and hence p ( u ) will also be large for u drawn from the same distribution as v .
we now derive a few other distributions that are entailed by equation ( 123 ) .
the formula for p ( h ) is
entirely analogous to that of p ( v ) :
figure 123 : the result of whitening .
figure 123 : the restricted boltzmann machine architecture .
we can also derive some simple conditional expressions : p ( v|h ) = p ( v , h )
p ( h|v ) = p ( v , h )
we can also derive a closed - form expression for p ( vk = 123|h ) , the probability of a particular visible unit being on given a hidden conguration .
to do this , we introduce the notation
p ( vk = 123 , vi ( cid : 123 ) =k , h )
to denote the probability of the conguration in which visible unit k has state 123 , the rest of the visible units have state vi ( cid : 123 ) =k , and the hidden units have state h .
given this , we have
p ( vk = 123|h ) = p ( vk = 123 , h )
123 + e ( pv
p ( hk = 123|v ) =
so as can be expected from figure 123 , we nd that the probability of a visible unit turning on is independent of the states of the other visible units , given the states of the hidden units .
likewise , the hidden states are independent of each other given the visible states .
this property of rbms makes sampling extremely ecient , as one can sample all the hidden units simultaneously and then all the visible units simultaneously .
j=123 hj wkj +bv
p ( vk = 123 , vi ( cid : 123 ) =k , h )
123 + e ( ph
j=123 hj wkj +bv
j=123 hj wkj +bv
j=123 hj wkj +bv
j=123 hj wkj +bv
j=123 hj wkj +bv
j=123 hj wkj +bv
j=123 hj bh
j=123 hj bh
j=123 vihj wij +pv j=123 vihj wij +pv
123 . 123 training rbms given a set of c training cases ( vc|c ( 123 , .
, c ) ) , the goal is to maximize the average log probability of the set under the model ' s distribution :
we attempt to do this with gradient descent .
dierentiating with respect to a weight wij , we have
log p ( vc ) =
first consider the rst term :
log p ( vc ) =
g ee ( vc , g ) e ( vc , g )
notice that the term data vector vc .
this is easy to compute since we know vc using equation ( 123 ) .
is just the expected value of vc
i gj given that v is clamped to the i and we can compute the expected value of gj
turning our attention to the second term in equation ( 123 ) :
g ee ( vc , g ) vc g ee ( vc , g )
g ee ( u , g ) e ( u , g )
is the expected value of uigj under the model ' s distribution .
we can here , the term compute uigj by clamping the visible units at the data vector vc , then sampling the hidden units , then sampling the visible units , and repeating this procedure innitely many times .
after innitely many iterations , the model will have forgotten its starting point and we will be sampling from its equilibrium distribution .
however , it has been shown in ( 123 ) that this expectation can be approximated well in nite time by a procedure known as contrastive divergence ( cd ) .
the cd learning procedure approximates ( 123 ) by running the sampling chain for only a few steps .
it is illustrated in figure 123 .
we name cd - n the algorithm that samples the hidden units n + 123 times .
in practice , we use cd - 123 almost exclusively because it produces adequate results .
cd - 123 learning amounts to lowering the energy that the model assigns to training vectors and raising the energy of the model ' s reconstructions of those training vectors .
it has the potential pitfall that places in the energy surface that are nowhere near data do not get explicitly modied by the algorithm , although they are aected by the changes in parameters that cd - 123 induces .
renaming gs to hs , the update rule for weight wij is
wij = w ( edata ( vihj ) emodel ( vihj ) )
figure 123 : the cd - n learning procedure .
to estimate emodel ( vihj ) , initialize the visible units at the data and alternately sample the hidden and then the visible units .
use the observed value of vihj at the ( n + 123 ) st sample as the estimate .
figure 123 : the dbn architecture .
the second - layer rbm is trained on the activities of the hidden units of the rst - layer rbm , given the data , and keeping w123 xed .
where w is the weight learning rate hyperparameter , edata is the expectation under the model ' s dis - tribution when the the visible units are clamped to the data , and emodel is the expectation under the model ' s distribution when the visible units are unclamped .
as discussed above , emodel is approximated
the update rules for the biases are similarly derived to be
i = bv ( edata ( vi ) emodel ( vi ) ) j = bh ( edata ( hj ) emodel ( hj ) ) .
123 . 123 deep belief networks ( dbns )
deep belief networks extend the rbm architecture to multiple hidden layers , where the weights in layer l are trained by keeping all the weights in the lower layers constant and taking as data the activities of the hidden units at layer l 123
so the dbn training algorithm trains the layers greedily and in sequence .
layer l is trained after layer l 123
if one makes the size of the second hidden layer the same as the size of the rst hidden layer and initializes the weights of the second from the weights of the rst , it can be proven that training the second hidden layer while keeping the rst hidden layer ' s weights constant improves the log likelihood of the dataunder the model ( 123 ) .
figure 123 shows a two - layer dbn
looking at the dbn as a top - down generative model , jensen ' s inequality tells us that
log p ( v|w123 , w123 ) ( cid : 123 )
q ( h123|v ) log p ( v , h123|w123 , w123 )
for any distribution q ( h123|v ) .
in particular , we may set q ( h123|v ) = p ( h123|v , w123 ) and get
log p ( v|w123 , w123 ) ( cid : 123 ) p ( h123|v , w123 ) log p ( v , h123|w123 , w123 ) p ( h123|v , w123 ) log p ( v|h123 , w123 ) p ( h123|w123 ) p ( h123|v , w123 ) log p ( h123|w123 ) + ( cid : 123 ) p ( h123|v , w123 ) log p ( h123|w123 ) + ( cid : 123 )
p ( h123|v , w123 ) log p ( h123|w123 )
p ( h123|v , w123 ) log p ( h123|w123 ) + log p ( v|w123 ) .
p ( h123|v , w123 ) log p ( v|h123 , w123 ) p ( h123|v , w123 ) log p ( v|w123 )
if we initialize w123 at w123 , then the rst two terms cancel out and so the bound is tight .
training the second layer of the dbn while keeping w123 xed amounts to maximizing
p ( h123|v , w123 ) log p ( h123|w123 )
which is the rst term in equation ( 123 ) .
since the other terms stay constant , when we train the second hideen layer we are increasing the bound on the log probability of the data .
since the bound is initially tight due to our initialization of w123 , we must also be increasing the log probability of the data .
we can extend this reasoning to more layers with the caveat that the bound is no longer tight as we initialize w123 after learning w123 and w123 , and so we may increase the bound while lowering the actual log probability of the data .
the bound is also not tight in the case of gaussian - bernoulli rbms , which we discuss next , and which we use to model tiny images .
rbms and dbns have been shown to be capable of extracting meaningful features when trained on
other vision datasets , such as hand - written digits and faces ( ( 123 , 123 ) ) .
123 . 123 gaussian - bernoulli rbms
an rbm in which the visible units can only take on binary values is , at best , very inconvenient for modeling real - valued data such as pixel intensities .
to model real - valued data , we replace the model ' s energy function with
j hj v ( cid : 123 )
e ( v , h ) =
this type of model is explored in ( 123 , 123 ) .
here , vi denotes the now real - valued activity of visible unit vi .
notice that here each visible unit adds a parabolic ( quadratic ) oset to the energy function , where i controls the width of the parabola .
this is in contrast to the binary - to - binary rbm energy function ( 123 ) , to which each visible unit adds only a linear oset .
the signicance of this is that in the binary - to - binary case , a visible unit cannot precisely express its preference for a particular value .
this is the reason why adapting a binary - to - binary rbm to model real values , by treating the visible units ' activation probabilities as their activations , is a bad idea . 123
123the model we use is also dierent from the product of uni - gauss experts presented in ( 123 ) .
in that model , a gaussian is associated with each hidden unit .
given a data point , each hidden unit uses its posterior to stochastically decide whether or not to activate its gaussian .
the product of all the activated gaussians ( also a gaussian ) is used to compute the reconstruction of the data given the hidden units ' activities .
the product of uni - gauss experts model also uses the hidden units to model the variance of the gaussians , unlike the gaussian rbm model which we use .
however , we show in section 123 . 123 how to learn the variances of the gaussians in the model we use .
given the energy function ( 123 ) , we can derive the distribution p ( v|h ) as follows :
j hj +pv
j hj + 123
j hj +pv j hj +pv
j hj + vi
j hj + 123
j=123 hj wij ) 123
j=123 hj wij ) 123
j=123 hj wij ) 123
j=123 hj wij ) 123
hj wij du j=123 hj wij i j=123 hj wij i
j=123 hj wij
j=123 hj wij ) 123i ( vibv
j=123 hj wij )
j=123 hj wij )
which we recognize as the v - dimensional gaussian distribution with diagonal covariance given by
and mean in dimension i given by
as before , we can compute p ( hk = 123|v ) as follows : p ( v , hk = 123 , hj ( cid : 123 ) =k , )
p ( hk = 123|v ) =
ee ( v , gk=123 , g ) + e
hj wij +pv hj wij +pv
j ( cid : 123 ) =k hj bh
j ( cid : 123 ) =k hj bh
which is the same as in the binary - visibles case except here the real - valued visible activity vi is scaled by the reciprocal of its standard deviation i .
123 . 123 training gaussian - bernoulli rbms
the training procedure for a gaussian - bernoulli rbm is identical to that of an ordinary rbm .
as in that case , we take the derivative shown in equation ( 123 ) .
we nd that
ee ( vc , g ) = c ( cid : 123 ) g ee ( vc , g ) e ( vc , g )
ee ( u , g ) = 123
which we estimate , as before , using cd .
123 . 123 learning visible variances
recall that the energy function of a gaussian - bernoulli rbm is
j hj v ( cid : 123 )
e ( v , h ) =
we attempt to maximize the log probability of the data vectors
log p ( v ) = log
the rst term is the negative of the free energy that the model assigns to vector v , and it can be expanded as follows :
f ( v ) = log ( cid : 123 )
j hj +pv j hj +pv j hj +pv
123 + ebh
123 + ebh
the second - last step is justied by the fact that each hj is either 123 or 123
the derivative of f ( v ) with respect to i is
likewise , the derivative with respect to log
which is just the expected value of
where aj is the real - valued , deterministic activation probability of hidden unit j given the visible vector
123 + ebh
123 + ebh
g ee ( u , g ) ( cid : 123 ) ( uibv g ee ( u , g ) du is
j=123 gj wij ui
under the model ' s distribution .
therefore , the update rule for i is
where is the learning rate hyperparameter .
as for weights , we use cd - 123 to approximate the expecta - tion under the model .
123 . 123 visualizing lters
there is an intuitive way to interpret the weights of a gaussian - bernoulli rbm trained on images , and that is to look at the lters that the hidden units apply to the image .
each hidden unit is connected with some weight to each pixel .
if we arrange these weights on a 123 123 grid , we obtain a visualization of the lter applied by the hidden unit .
figure 123 shows this type of visualization of 123 dierent hidden units .
in creating these visualizations , we use intensity to indicate the strength of the weight .
so a green region in the lter denotes a set of weights that have strong positive connections to the green channel of the pixels .
but a purple region indicates strong negative connections to the green channel of the pixels , since this is the colour produced by setting the red and blue channels to high values and the green channel to a low value .
in this sense , purple is negative green , yellow is negative blue , and turquoise is negative red .
123 . 123 measuring performance ideally , we would like to be able to evaluate p ( v ) for data vector v .
but this is intractable for models with large numbers of hidden units due to the denominator in ( 123 ) .
instead we use the reconstruction error .
the reconstruction error is the squared dierence ( v v ( cid : 123 ) ) 123 between the data vector v , and the vector produced by sampling the hidden units given v to obtain a hidden conguration h , and then sampling the visible units given h to obtain a visible conguration v ( cid : 123 ) .
this is not a very good measure of how well the model ' s probability distribution matches that of the data , because the reconstruction error depends heavily on how fast the markov chain mixes .
123 feed - forward neural networks
in our experiments we use the weights learned by an rbm to initialize feed - forward neural networks which we train with the standard backpropagation algorithm .
in appendix b we give a brief overview of the algorithm .
learning a generative model of images
the major , recurrent theme throughout this work is our search for a good generative model of natural images .
in addition , we seek a model that is capable of extracting useful high - level features from images , such as the locations and orientations of contours .
the hope is that such features would be much more useful to a classier than the raw pixels .
finally , such a model would have some connection to the physical realities of human vision , as the visual cortex contains neurons that detect high - level features such as edges .
123 previous work
one of the authors of the 123 million tiny images dataset unsuccessfully attempted to train the type of model that we are interested in here ( 123 ) .
he was unsuccessful in the sense that the model he trained did not learn interesting lters .
the model learned noisy global lters and point - like identity functions similar to the ones of figure 123 .
another group also attempted to train this type of model on 123 123 colour patches of natural images and came out only with lters that are everywhere uniform or global
we started out by attempting to train an rbm with 123 hidden units on a subset of 123 million images of the tiny images dataset .
the subset was whitened but left otherwise unchanged .
for this experiment we set the variance of each of the visible units to 123 , since that is the variance that the whitening transformation produced .
unfortunately this model developed a lot of lters like the ones in figure 123 .
nothing that could be mistaken for a feature .
123 deleting directions of variance
one theory was that high - frequency noise in the images was making it hard for the model to latch on to the real structure .
it was busy modelling the noise , not the images .
to mitigate this , we decided to remove some of the least signicant directions of variance from the dataset .
we accomplished this by setting to zero those entries of the diagonal matrix d of equation ( a . 123 ) that correspond to the 123 least signicant principal components ( these are the 123 smallest entries of d ) .
this has no discernible eect on the appearance of the images since the 123 directions of variance that remain are far more important .
in support of this claim , figure 123 compares images that have been whitened and then dewhitened with the original lter with those using the new lter that also deletes the 123 least signicant principal components .
figure 123 plots the log - eigenspectrum of the tiny images dataset .
unfortunately , this extra pre - processing step failed to convince the rbm to learn interesting features .
but we nonetheless considered it a sensible step so we kept it for the remainder of our experiments .
figure 123 : meaningless lters learned by an rbm on whitened data .
these lters are in the whitened domain , meaning they are applied by the rbm to whitened images .
figure 123 : the log - eigenspectrum of the tiny images dataset .
the variance in the directions of the 123 least signicant principal components is seen to be several orders of magnitude smaller than that in the direction of the 123 most signicant .
figure 123 : ( a ) the result of whitening and then dewhitening an image with the original whitening lter derived in section 123 .
( b ) the same as ( a ) , but the dewhitening lter also deletes the 123 least - signicant principal components from the dataset as described in section 123 .
notice that the whitened image appears smoother and less noisy in ( b ) than in ( a ) , but the de - whitened image in ( b ) is identical to that in ( a ) .
this conrms that this modied whitening transformation is still invertible , even if not technically so .
figure 123 : segmenting a 123 123 image into 123 123x123 patches .
123 training on patches of images frustrated by the model ' s inability to extract meaningful features , we decided to train on 123 123 patches of the images .
this greatly reduced the data dimensionality and hence the required model complexity , measured in the number of hidden units .
we divided the 123 images into 123 123 patches as shown in figure 123 .
in addition to the patches shown in figure 123 , we created a 123th patch : an 123 subsampled version of the entire 123 123 image .
we trained 123 independent rbms with 123 hidden units on each of these patches; figures 123 and 123 show the lters that they learned .
these are the types of lters that we were looking for edge detectors .
one immediately noticeable pattern among the lters of figure 123 is the rbm ' s anity for low - frequency colour lters and high - frequency black - and - white lters .
one explanation may be that the black - and - white lters are actually wider in the colour dimension , since they have strong connections to all colour channels .
we may also speculate that precise edge position information and rough colour information is sucient to build a good model of natural images .
123 . 123 merging rbms trained on patches
once we have trained 123 of these rbms on the tiny image patches , we can combine them in a very straightforward ( perhaps naive ) way by training a new rbm with 123 ( 123 123 ) hidden units .
we initialize the rst 123 of these hidden units with the weights from the rbm trained on patch #123 , the next 123 with the weights trained on patch #123 , and so forth .
however , each of the hidden units in the big rbm is connected to every pixel in the 123 123 image , so we initialize to 123 the weights that didn ' t exist in the rbms trained on patches ( for example , the weight from a pixel in patch #123 to a hidden unit from an rbm trained on patch #123 ) .
the weights from the hidden units that belonged to the rbm trained on patch #123 ( the subsampled global patch ) are initialized as depicted in figure 123 .
the bias of a visible unit of the big rbm is initialized to the average bias that the unit received among the small
interestingly , this type of model behaves very well , in the sense that the weights don ' t blow up and the lters stay roughly as they were in the rbms trained on patches .
in addition , it is able to reconstruct images much better than the average small rbm is able to reconstruct image patches .
this despite the fact that the patches that we trained on were overlapping , so the visible units in the big rbm must essentially learn to reconcile the inputs from two or three sets of hidden units , each of which comes from a dierent small rbm .
figures 123 and 123 show some of the lters learned by this model ( although in truth , they were for the most part learned by the small rbms ) .
figure 123 shows the reconstruction error as a function of training time .
the reconstruction error up to epoch 123 is the average among the independently - trained small rbms .
the large spike at epoch 123 is the point at which the small rbms were combined into one big rbm .
the merger initially has an adverse eect on the reconstruction error but it very quickly descends below its previous minimum .
figure 123 : filters learned by an rbm trained on the 123x123 patch #123 ( depicted in figure 123 ) of the whitened tiny images dataset .
the rbms trained on the other patches learned similar lters .
figure 123 : filters learned by an rbm trained on 123 123 subsampled versions of the 123 123 whitened tiny image dataset .
figure 123 : how to convert hidden units trained on a globally subsampled 123 123 patch to hidden units to be trained on the entire 123 123 image .
each weight w in the small rbm is duplicated 123 times and divided by 123 in the big rbm .
the weights of the big rbm are untied and free to dierentiate .
123 training rbms on 123x123 images after our successes training models of 123 123 and 123 123 patches , we decided to try with 123 123 images once more .
this time we developed an algorithm for parallelizing the training across all the cpu cores of a machine .
later , we further parallelized across machines on a network , and this algorithm is described in chapter 123
with this new , faster training algorithm we were quickly able to train an rbm with 123 hidden units on the 123 123 whitened images .
a sample of the lters that it learned is shown in figure 123 .
they appear very similar to the lters learned by the rbms trained on patches .
after successfully training this rbm , we decided to try training an rbm on unwhitened data .
we again preprocessed the data by deleting the 123 least - signicant directions of variance , as described in section 123 .
we measured the average standard deviation of the pixels in this dataset to be 123 , so we set the standard deviation of the visible units of the rbm to 123 as well .
a curious thing happens when training on unwhitened data all of the lters go through a point stage before they turn into edge lters .
a sample of such point lters is shown in figure 123 .
in the point stage , the lters simply copy data from the visible units to the hidden units .
the lters remain in this point stage for a signicant amount of time , which can create the illusion that the rbm has nished learning and that further training is futile .
however , the point lters eventually evaporate and in their place form all kinds of edge lters , a sample of which is shown in figure 123 .
the edge lters do not necessarily form at or near the positions of their pointy ancestors , though this is common .
notice that these lters are generally larger than the ones learned by the rbm trained on whitened data ( figure 123 ) .
this is most likely due to the fact that a green pixel in a whitened image can indicate a whole region of green in the unwhitened
123note that these lters are from a dierent rbm than that which produced the point lters pictured in figure 123 .
figure 123 : some of the lters learned by the rbm produced by merging the 123 rbms trained on image patches , as described in section 123 . 123
all of the non - zero weights are in the top - left corner because these hidden units were initialized from the rbm trained on patch #123
compare with the lters of the rbm in figure 123 .
figure 123 : some of the lters learned by the rbm produced by merging the 123 rbms trained on image patches , as described in section 123 . 123
these hidden units were initialized from the rbm trained on the globally subsampled patch , pictured in figure 123 .
notice that the globally noisy lters of figure 123 have developed into entirely new local lters , while the local lters of figure 123 have remained largely
figure 123 : epoch 123 - 123 : the average reconstruction error among the 123 rbms trained on 123 123 image patches .
epochs 123+ : the reconstruction error of the rbm produced by merging the 123 little rbms as described in section 123 . 123
the spike at epoch 123 demonstrates the initial adverse eect that the merger has on the reconstruction error .
the spike between epochs 123 and 123 is the result of increasing the
123 learning visible standard deviations
we then turned our attention to learning the standard deviations of the visible units , as described in section 123 . 123 .
our hope was that the rbm would learn much smaller values for these standard deviations than the true standard deviations of the pixels across the dataset .
the trick to doing this correctly is to set the learning rate of the standard deviations to a suciently low value .
in our experience , it should be about 123 to 123 times smaller than the learning rate of the weights .
failure to do so produces a lot of point lters that never evolve into edge lters .
figure 123 shows a sample of the lters learned by an rbm trained on unwhitened data while also learning the visible standard deviations .
the rbm did indeed learn lower values for the standard deviations than observed in the data; over the course of training the standard deviations came down to about 123 from an initial value of 123 ( although the nal value depends on how long one trains ) .
though the rbm had a separate parameter for the standard deviation of each pixel , all the parameters remained very similar .
the standard deviation of the standard deviations was 123 .
learning the standard deviations improved the rbm ' s reconstruction error tremendously , but it had a qualitatively negative eect on the appearance of the lters .
they became more noisy and more of them remained in the point lter stage .
123 second layer of features
figure 123 shows the features learned by a binary - to - binary rbm with 123 hidden units trained on the 123 - dimensional hidden unit activation probabilities of the rbm trained on unwhitened data .
hidden units in the second - level rbm tend to have strong positive weights to similar features in the rst layer .
the second - layer rbm is indeed extracting higher - level features .
figure 123 : a sample of the lters learned by an rbm with 123 hidden units trained on 123 million 123 123 whitened images .
figure 123 : a random sample of lters from an rbm that only learned point lters .
figure 123 : a sample of the lters learned by an rbm with 123 hidden units trained on 123 million 123 123 unwhitened images .
figure 123 : a sample of the lters learned by an rbm with 123 hidden units on 123 million 123 123 unwhitened images while also learning the standard deviations of the visible units .
notice that the edge lters learned by this rbm have a higher frequency than those learned by the rbm of figure 123 .
this is due to the fact that this rbm has learned to set its visible standard deviations to values lower than 123 , and so its hidden units learned to be more precise .
figure 123 : a visualization of a random sample of 123 lters learned by an rbm trained on the 123 - dimensional hidden unit activation probabilities of the rbm trained on unwhitened data .
every row represents a hidden unit h in the second - level rbm , and in every column are the l - ters of the rst - level rbm to which h has the strongest connections .
the four lters on the left are the ones to which h has the strongest positive connection and the four lters on the right are the ones to which h has the strongest negative connections .
in a few instances we see examples of the rbm favouring a certain edge lter orientation and disfavouring the mirror orientation ( see for example second - last row , columns 123 and 123 ) .
object classication experiments
123 the labeled subset123
we paid students to label a subset of the tiny images dataset .
the labeled subset we collected consists of ten classes of objects with 123 images in each class .
the classes are airplane , automobile ( but not truck or pickup truck ) , bird , cat , deer , dog , frog , horse , ship , and truck ( but not pickup truck ) .
since each image in the dataset already comes with a noisy label ( the search term used to nd the image ) , all we needed the labelers to do was to lter out the mislabeled images .
to that end , each labeler was given a class and asked to examine all the images which were found with that class as the search term .
since the dataset contains only about 123 images per search term , the labelers were also asked to examine all the images which were found with a search term that is a hyponym ( as dened by wordnet ) of the main search term .
as an example , some of the hyponyms of ship are cargo ship , ocean liner , and frigate .
the labelers were instructed to reject images which did not belong to their assigned class .
the criteria for deciding whether an image belongs to a class were as follows123 :
the class name should be high on the list of likely answers to the question what is in this picture ? the image should be photo - realistic .
labelers were instructed to reject line drawings .
the image should contain only one prominent instance of the object to which the class refers .
the object may be partially occluded or seen from an unusual viewpoint as long as its identity is
still clear to the labeler .
the labelers were paid a xed sum per hour spent labeling , so there was no incentive to rush through the task .
furthermore , we personally veried every label submitted by the labelers .
we removed duplicate images from the dataset by comparing images with the l123 norm and using a rejection threshold liberal enough to capture not just perfect duplicates but also re - saved jpegs and the like .
finally , we divided the dataset into a training and test set , the training set receiving a randomly - selected 123 images from
we call this the cifar - 123 dataset , after the canadian institute for advanced research , which funded the project .
in addition to this dataset , we have collected another set 123 images in each of 123 classes .
this we call the cifar - 123 dataset .
the methodology for collecting this dataset was identical to that for cifar - 123
the cifar - 123 classes are mutually exclusive with the cifar - 123 classes , and so they can be used as negative examples for cifar - 123
for example , cifar - 123 has the classes automobile and truck , but neither of these classes includes images of pickup trucks .
cifar - 123 has the class pickup truck .
furthermore , the cifar - 123 classes come in 123 superclasses of ve classes each .
for example , the superclass reptile consists of the ve classes crocodile , dinosaur , lizard , turtle , and snake .
the idea is that classes within the same superclass are similar and thus harder to distinguish than classes that belong to dierent superclasses .
appendix d lists the entire class structure of cifar - 123
all of our experiments were with the cifar - 123 dataset because the cifar - 123 was only very recently
123we thank vinod nair for his substantial contribution to the labeling project .
123the instruction sheet which was handed out to the labelers is reproduced in appendix c .
we compared several methods of classifying the images in the cifar - 123 dataset .
each of these methods used multinomial logistic regression at its output layer , so we distinguish the methods mainly by the input they took :
the raw pixels ( unwhitened ) .
the raw pixels ( whitened ) .
the features learned by an rbm trained on the raw pixels .
the features learned by an rbm trained on the features learned by the rbm of #123
one can also use the features learned by an rbm to initialize a neural network , and this gave us our best results ( this approach was presented in ( 123 ) ) .
the neural net had one hidden layer of logistic units ( f ( x ) = 123 123+ex ) , whose weights to the visible units we initialized from the rbm trained on raw ( unwhitened ) pixels .
we initialized the hidden - to - output weights from the logistic regression model trained on rbm features as input .
so , initially , the output of the neural net was exactly identical to the output of the logistic regression model .
but the net learned to ne - tune the rbm weights to improve generalization performance slightly .
in this fashion it is also possible to initialize two - hidden - layer neural nets with the features learned by two layers of rbms , and so forth .
however , two hidden layers did not give us any improvement over one .
this result is in line with that found in ( 123 ) .
our results are summarized in figure 123 .
each of our models produced a probability distribution over the ten classes , so we took the most probable class as the model ' s prediction .
we found that the rbm features were far more useful in the classication task than the raw pixels .
furthermore , features from an rbm trained on unwhitened data outperformed those from an rbm trained on whitened data .
this may be due to the fact that the whitening transformation xes the variance in every direction at 123 , possibly exaggerating the signicance of some directions which correspond mainly to noise ( although , as mentioned , we deleted the 123 least - signicant directions of variance from the data ) .
the neural net that was initialized with rbm features achieved the best result , just slightly improving on the logistic regression model trained on rbm features .
the gure also makes clear that , for the purpose of classication , the features learned by an rbm trained on the raw pixels are superior to the features learned by a randomly - initialized neural net .
we should also mention that the neural nets initialized from rbm features take many fewer epochs to train than the equivalently - sized randomly - initialized nets , because all the rbm - initialized neural net has to do is ne - tune the weights learned by the rbm which was trained on 123 million tiny images123
figure 123 shows the confusion matrix of the logistic regression model trained on rbm features ( unwhitened ) .
the matrix summarizes which classes get mistaken for which other classes by the model .
it is interesting to note that the animal classes seem to form a distinct cluster from the non - animal classes .
seldom is an animal mistaken for a non - animal , save for the occasional misidentication of a bird as a plane . 123
123the last model performed slightly worse than the second - last model probably because it had roughly 123 parameters and thus had a strong tendency to overt .
the model ' s size also made it slow and very cumbersome to train .
we did not run many instances of it to nd the best setting of the hyperparameters .
123which , admittedly , it took a long time to learn .
123it is a pity we did not have the foresight to include superman as the 123th class .
figure 123 : classication performance on the test set of the various methods tested .
the models were : ( a , b ) logistic regression on the raw , whitened and unwhitened data .
( c , d ) logistic regression on 123 rbm features from an rbm trained on whitened , unwhitened data .
( e ) backprop net with one hidden layer initialized from the 123 features learned by an rbm trained on unwhitened data .
the hidden - out connections were initialized from the model of ( d ) .
( f ) backprop net with one hidden layer of 123 units , trained on unwhitened data and with logistic regression at the output .
( g ) backprop net with one hidden layer of 123 units , trained on unwhitened pixels and with logistic regression at the output .
( h ) logistic regression on 123 rbm features from an rbm trained on the 123 features learned by an rbm trained on unwhitened data .
( i ) backprop net with one hidden layer initialized from the 123 features learned by an rbm trained on the 123 features from an rbm trained on unwhitened data .
the hidden - out connections were initialized from the model of ( h ) .
( j ) backprop net with two hidden layers , the rst initialized as in ( e ) and the second as in ( i ) .
the hidden - out connections were initialized as in ( i ) as well .
figure 123 : confusion matrix for logistic regression on 123 rbm features trained on unwhitened data .
the area of square ( i , j ) indicates the frequency with which an image whose true label is i gets classied as j .
the values in each row sum to 123
this matrix was constructed from the cifar - 123 test set .
notice how frequently a cat is mistaken for a dog , and how infrequently an animal for a non - animal ( or vice versa ) .
parallelizing the training of rbms
here we describe an algorithm for parallelizing the training of rbms .
when both the hidden and visible units are binary , the algorithm is extremely ecient , in that it requires very little communication and hence scales very well .
when the visible units are gaussian the algorithm is less ecient but in the problem we tested , it scales nearly as well as in the binary - to - binary case .
in either case the total amount of communication required scales linearly with the number of machines , while the amount of communication required per machine is constant .
if the machines have more than one core , the work can be further distributed among the cores .
the specic algorithm we will describe is a distributed version of cd - 123 , but the principle remains the same for any variant of cd , including persistent cd ( pcd ) ( 123 ) .
123 the algorithm
recall that ( undistributed ) cd - 123 training consists roughly of the following steps , where there are i visible units and j hidden units :
get the data v = ( v123 , v123 , . . . , vi ) .
compute hidden unit activities h = ( h123 , h123 , . . . , hj ) given the data .
compute visible unit activities ( negative data ) v ( cid : 123 ) = ( v ( cid : 123 ) 123 , . . . , v ( cid : 123 )
i ) given the hidden unit activities
of the previous step .
compute hidden unit activities h ( cid : 123 ) = ( h ( cid : 123 )
123 , . . . , h ( cid : 123 )
j ) given the visible unit activities of the previous
the weight update for weight wij is
if we ' re doing batch training , the weight update is
wij = ( cid : 123 ) vihj v ( cid : 123 ) wij = ( cid : 123 ) < vihj > < v ( cid : 123 )
where <> denotes expectation among the training cases in the batch .
the distributed algorithm parallelizes steps 123 , 123 , and 123 and inserts synchronization points123 after each of these steps so that all the machines proceed in lockstep .
if there are n machines , each machine is responsible for computing 123 / n of the hidden unit activities in steps 123 and 123 and 123 / n of the visible unit activities in step 123
we assume that all machines have access to the whole dataset .
it ' s probably easiest to describe this with a picture .
figure 123 shows which weights each machine cares about ( i . e .
which weights it has to know ) when there are four machines in total .
for k machines , the algorithm proceeds as follows :
123a synchronization point is a section of code that all machines must execute before any machine can proceed beyond
figure 123 : in four - way parallelization , this shows which weights machines ( a ) 123 and ( b ) 123 have to know .
we have divided the visible layer and the hidden layer into four equal chunks arbitrarily .
note that the visible layer does not necessarily have to be equal in size to the hidden layer it ' s just convenient to draw them this way .
the weights have dierent colours because it ' s convenient to refer to them by their colour in the text .
each machine has access to the whole dataset so it knows v = ( v123 , v123 , . . . , vi ) .
each machine k computes its hidden unit activities hk = ( hk
j / k ) given the data v .
note that each machine computes the hidden unit activities of only j / k hidden units .
it does this using the green weights in figure 123 .
123 , . . . , hk
all the machines send the result of their computation in step 123 to each other .
now knowing all the hidden unit activities , each machine computes its visible unit activities
( negative data ) v ( cid : 123 )
k = ( vk ( cid : 123 )
123 , vk ( cid : 123 )
123 , . . . , vk ( cid : 123 )
i / k ) using the purple weights in figure 123 .
all the machines send the result of their computation in step 123 to each other .
now knowing all the negative data , each machine computes its hidden unit activities h ( cid : 123 )
123 , hk ( cid : 123 )
123 , . . . , hk ( cid : 123 )
j / k ) using the green weights in figure 123 .
all the machines send the result of their computation in step 123 to each other .
notice that since each hj is only 123 bit , the cost of communicating the hidden unit activities is very small .
if the visible units are also binary , the cost of communicating the vis is also small .
this is why the algorithm scales particularly well for binary - to - binary rbms .
after step 123 , each machine has enough data to compute < vihj > for all the weights that it cares about .
after step 123 , each machine has enough data to compute < v ( cid : 123 ) j > for all the weights that it cares about .
this is essentially all there is to it .
you ' ll notice that most weights are updated twice ( but on dierent machines ) , because most weights are known to two machines ( in figure 123 notice , for example , that some green weights on machine 123 are purple weights on machine 123 ) .
this is the price of parallelization .
in fact , in our implementation , we updated every weight twice , even the ones that are known to only one machine .
this is a relatively small amount of extra computation , and avoiding it would result in having to do two small matrix multiplications instead of one large one .
wary of oating point nastiness , you might also wonder : if each weight update is computed twice , can we be sure that the two computations arrive at exactly the same answer ? when the visible units are binary , we can .
this is because the oating point operations constitute taking the product of the data matrix with the matrix of hidden activities , both of which are binary ( although they are likely to be stored as oating point ) .
when the visible units are gaussian , however , this really does present a problem .
because we have no control over the matrix multiplication algorithm that our numerical package uses to compute matrix products , and further because each weight may be stored in a dierent location of the weight matrix on each machine ( and the weight matrices may even have slightly dierent shapes on dierent machines ! ) , we cannot be sure that the sequence of oating point operations that compute weight update wij on one machine will be exactly the same as that which compute it on a dierent machine .
this causes the values stored for these weights to diverge on the two machines and requires that we introduce a weight synchronization step to our algorithm .
in practice , the divergence is very small even if all our calculations are done in single - precision oating point , so the weight synchronization step need not execute very frequently .
the weight synchronization step proceeds as follows :
designate the purple weights ( figure 123 ) as the weights of the rbm and forget about the green
each machine k sends to machine k ( cid : 123 ) the slice of its purple weights that machine k ( cid : 123 ) needs to know
in order to ll in its green weights .
notice that each machine must send 123 sending stu around , the total amount of communication does not exceed k123 thus the amount of communication required for weight synchronization is constant in the number of machines , which means that oating point does not manage to spoil the algorithm the algorithm does not require an inordinate amount of correction as the number of machines increases .
k123 th of the weight matrix to k123 machines .
since k machines are k ( size of weight matrix ) .
we ' ve omitted biases from our discussion thus far; that is because they are only a minor nuisance .
the biases are divided into k chunks just like the weights .
each machine is responsible for updating the visible biases corresponding to the visible units on the purple weights in figure 123 and the hidden biases corresponding to the hidden units on the green weights in figure 123 .
each bias is known to only one machine , so its update only has to be computed once .
recall that the bias updates in cd - 123 are
i = ( < vi > < v ( cid : 123 )
j = ( cid : 123 ) < hj > < h ( cid : 123 )
i > ) ,
i denotes the bias of visible unit i and bh
j denotes the bias of hidden unit j .
clearly after step 123 , each machine can compute < vi > .
after step 123 it can compute < hj > .
after step 123 it can compute
and after step 123 it can compute < h ( cid : 123 )
we implemented this algorithm as a c extension to a python program .
the python code initializes the matrices , communication channels , and so forth .
the c code does the actual computation .
we use whatever implementation of blas ( basic linear algebra subprograms ) is available to perform matrix and vector operations .
we use tcp sockets to communicate between machines .
our implementation is also capable of distributing the work across multiple cores of the same machine , in the same manner as described above .
the only dierence is that communication between cores is done via shared memory instead of sockets .
we used the pthreads library to parallelize across cores .
we execute the weight synchronization step after training on each batch of 123 images .
this proved sucient to keep the weights synchronized to within 123 at single precision .
our implementation also computes momentum and weight decay for all the weights .
when parallelizing across k machines , our implementation spawns k 123 writer threads and k 123 reader threads on each machine , in addition to the threads that do the actual computation ( the worker threads ) .
the number of worker threads is a run - time variable , but it is most sensible to set it to the number of available cores on the machine .
123 . 123 writer threads
each writer thread is responsible for sending data to a particular other machine .
associated with each writer thread is a queue .
the worker threads add items to these queues when they have nished their computation .
the writer threads dequeue these items and send them to their target machine .
we have separated communication from computation in this way so that a machine that has everything it needs to continue its computation does not need to delay performing it just because it still has to send some data to another machine .
123 . 123 reader threads
each reader thread is responsible for receiving data from a particular other machine .
the reader thread reads data from its target machine as soon as it arrives .
this setup ensures that no attempt to send data ever blocks because the receiver is still computing .
there is always a thread on the other side that ' s ready to receive .
similarly , since the data is received as soon as it becomes available , no machine ever has to delay receiving data merely because it is still computing .
we have tested our implementation of the algorithm on a relatively large problem 123 visible units and 123 hidden units .
the training data consisted of 123 examples of random binary data ( hopefully no confusion arises from the fact that we have two dierent quantities whose value is 123 ) .
we ran these tests on machines with two dual - core intel xeon 123ghz cpus .
we used intel ' s mkl ( math kernel library ) for matrix operations .
these machines are memory bandwidth - limited so returns diminished when we started running the fourth thread .
we measured our network speed at 123 mb / s , where 123 mb = 123 bytes .
we measured our network latency at 123ms .
our network is such that multiple machines can communicate at the peak speed without slowing each other down .
in all our experiments , the weight synchronization step took no more than four seconds to perform ( two seconds at single precision ) , and these times are included in all our gures .
the rbm we study here takes , at best , several minutes per batch to train ( see figure 123 ) , so the four - second synchronization step is
figures 123 and 123 show the speedup factor when parallelizing across dierent numbers of machines and threads . 123 note that these gures do not show absolute speeds so no comparison between them ( nor between the subgures ) is possible .
figures 123 and 123 show the actual computation times of these rbms on 123 training examples .
not surprisingly , double precision is slower than single precision and smaller minibatch sizes are slower than larger ones .
single precision is much faster initially ( nearly 123x ) but winds up about 123x faster after much parallelization .
there are a couple of other things worth noting .
for binary - to - binary rbms , it is in some cases better to parallelize across machines than across cores .
this eect is impossible to nd with gaussian - to - binary rbms , the cost of communication between machines making itself shown .
the eect is also harder to nd for binary - to - binary rbms when the minibatch size is 123 , following the intuition that the eciency of the algorithm will depend on how frequently the machines have to talk to each other .
the gures also make clear that the algorithm scales better when using double - precision oating point as opposed to single - precision , although single - precision is still faster in all cases .
with binary visible units , the algorithm appears to scale rather linearly with the number of machines .
figure 123 illustrates this vividly . it shows that doubling the number of machines very nearly doubles the performance in all cases . 123 this suggests that the cost of communication is negligible , even in the cases when the minibatch size is 123 and the communication is hence rather fragmented .
when the visible units are gaussian , the algorithm scales just slightly worse .
notice that when the minibatch size is 123 ,
123the numbers for one thread running on one machine were computed using a dierent version of the code one that did not incur all the overhead of parallelization .
the numbers for multiple threads running on one machine were computed using yet a third version of the code one that did not incur the penalty of parallelizing across machines ( i . e .
having to compute each weight update twice ) .
when parallelizing merely across cores and not machines , there is a variant of this algorithm in which each weight only has to be updated once and only by one core , and all the other cores immediately see the new weight after it has been updated .
this variant also reduces the number of sync points from three to two per
123the reason we didn ' t show the speedup factor when using two machines versus one machine on these graphs is that the one - machine numbers were computed using dierent code ( explained in the previous footnote ) and so they wouldn ' t oer a fair comparison .
figure 123 : speedup due to parallelization for a binary - to - binary rbm ( versus one thread running on one machine ) .
( a ) minibatch size 123 , double precision oats , ( b ) minibatch size 123 , double precision oats , ( c ) minibatch size 123 , single precision oats , ( d ) minibatch size 123 , single precision oats .
figure 123 : speedup due to parallelization for a gaussian - to - binary rbm ( versus one thread running on one machine ) .
( a ) minibatch size 123 , double precision oats , ( b ) minibatch size 123 , double precision oats , ( c ) minibatch size 123 , single precision oats , ( d ) minibatch size 123 , single precision oats .
figure 123 : time to train on 123 examples of random binary data ( binary - to - binary rbm ) .
( a ) mini - batch size 123 , double precision oats , ( b ) minibatch size 123 , double precision oats , ( c ) minibatch size 123 , single precision oats , ( d ) minibatch size 123 , single precision oats .
figure 123 : time to train on 123 examples of random real - valued data ( gaussian - to - binary rbm ) .
( a ) minibatch size 123 , double precision oats , ( b ) minibatch size 123 , double precision oats , ( c ) minibatch size 123 , single precision oats , ( d ) minibatch size 123 , single precision oats .
figure 123 : this gure shows the speedup factor when parallelizing a binary - to - binary rbm across four machines versus two ( blue squares ) and eight machines versus four ( red diamonds ) .
notice that doubling the number of machines very nearly doubles the performance .
the algorithm scales almost as well in the gaussian - to - binary case as in the binary - to - binary case .
when the minibatch size is 123 , the binary - to - binary version scales better than the gaussian - to - binary one .
figure 123 shows that in the gaussian - to - binary case doubling the number machines almost , but not quite , doubles performance .
123 . 123 communication cost analysis
we can analyze the communication cost more formally .
given k machines , we can compute the amount of data transmitted per training batch of 123 examples like this : in steps 123 and 123 , each machine has to send its hidden unit activities to all the other machines .
thus it has to send
123 ( k 123 ) 123 123
in step 123 each machine has to send its visible unit activities to all the other machines .
if the visible units are binary , this is another
thus the total amount of data sent ( equivalently , received ) by all machines is 123 ( k 123 ) mb .
in the gaussian - to - binary case , this number is appropriately larger depending on whether we ' re using single
these sum to
( k 123 ) 123 123
( k 123 ) ( cid : 123 ) 123 123 ( cid : 123 ) = 123 ( k 123 )
figure 123 : this gure shows the speedup factor when parallelizing a gaussian - to - binary rbm across four machines versus two ( blue squares ) and eight machines versus four ( red diamonds ) .
notice that doubling the number of machines very nearly doubles the performance .
number of machines :
data sent ( mb ) ( binary visibles ) :
data sent ( mb ) ( gaussian visibles , single precision ) : data sent ( mb ) ( gaussian visibles , double precision ) :
table 123 : total amount of data sent ( equivalently , received ) by the rbms discussed in the text .
or double precision oats .
in either case , the cost of communication rises linearly with the number of machines .
table 123 shows how much data was transferred by the rbms that we trained ( not including weight synchronization , which is very quick ) .
note that the cost of communication per machine is bounded from above by a constant ( 123mb in this case ) .
so if machines can communicate with each other without slowing down the communication of other machines , the communication cost essentially does not increase with the number of machines .
it looks as though we have not yet reached the point at which the benet of parallelization is outweighed by the cost of communication for this large problem .
but when we used this algorithm to train an rbm on binarized mnist digits ( 123 visible units , 123 hidden units ) , the benets of parallelization disappeared after we added the second machine .
but at that point it was already taking only a few seconds per batch .
123 other algorithms
we ' ll briey discuss a few other algorithms that could be used to parallelize rbm training .
all of these algorithms require a substantial amount of inter - machine communication , so they are not ideal for binary - to - binary rbms .
but for some problems , some of these algorithms require less communication in the gaussian - to - binary case than does the algorithm we have presented .
there is a variant of the algorithm that we have presented that performs the weight synchronization step after each weight update .
due to the frequent weight synchronization , it has the benet of not having to compute each weight update twice , thereby saving itself some computation .
it has a second benet of not having to communicate the hidden unit activities twice .
still , it will perform poorly in most cases due to the large amount of communication required for the weight synchronization step .
but if the minibatch size is suciently large it will outperform the algorithm presented here .
assuming single - precision oats , this variant requires less communication than the algorithm presented here when the following holds :
+ 123mvk 123vh
where m is the minibatch size , v is the number of visible units , h is the number of hidden units , and k is the number of machines .
notice that the right - hand side is just a multiple of the size of the weight matrix .
so , broadly speaking , the variant requires less communication when the weight matrix is small compared to the left - hand side .
just to get an idea for what this means , in the problem that we have been considering ( v = 123 , h = 123 ) , with k = 123 machines the variant would require less communication than the algorithm we presented when the minibatch size is greater than 123
notice , however , that merely adding machines pushes the inequality in a direction favourable to the variant , so it may start to look more attractive depending on the problem and number of machines .
another variant of the algorithm presented here is suitable for training rbms in which there are in this variant , each machine only knows 123 / kth of the data fewer hidden units than visible units .
( the data is partitioned by dimensions , as before ) , where k is the number of machines .
the algorithm proceeds as follows :
knowing only some of the data , no machine can compute the hidden unit activity of any hidden unit .
so instead each machine computes the hidden unit inputs to all the hidden units due to its 123 / kth of the data .
it does this with the purple weights of figure 123 .
each machine sends to each other machine the 123 / kth of the inputs that the receiver cares about .
once all the machines have all the inputs they need to compute their respective hidden unit activities , they all send these activities to each other .
these are binary values so this step is cheap .
each machine computes 123 / kth of the negative data given all the hidden unit activities , again using
the purple weights .
the machines cooperate to compute the hidden unit activities due to the negative data , as in steps
this algorithm trades communicating data for communicating hidden unit inputs .
roughly speaking , if the number of hidden units is less than half of the number of visible units , this is a win .
notice that in this variant , each machine only needs to know the purple weights ( figure 123 ) .
this means that each weight is only stored on one machine , so its update needs to be computed only once .
this algorithm also avoids the weight divergence problem due to oating point imprecision that we have discussed above .
one can also imagine a similar algorithm for the case when there are more hidden units than visible units .
in this algorithm , each machine will know all the data but it will only know the green weights of figure 123 .
thus no machine alone will be able to compute the data reconstruction , but they will cooperate by sending each other visible unit inputs . 123
a third , naive algorithm for distributing rbm training would simply have the dierent machines train on dierent ( mini - ) minibatches , and then send their weight updates to some designated main machine .
this machine would then average the weight updates and send out the new weight matrix to all the other machines .
it does not take much calculation to see that this algorithm would be incredibly slow .
the weight matrix would have to be sent 123 ( k 123 ) times for every minibatch .
123we have actually tested this algorithm on the 123 visible / 123 hidden problem , and it turned out to be about 123% faster than the algorithm presented here , even though in this problem there are more hidden units than visible units .
it appears that the cost of communication is not that great in our situation .
this is the version of the algorithm that we used for training our rbms .
the zca whitening transformation
we can store n d - dimensional data points in the columns of a d n matrix x .
assuming the data points have zero mean , their covariance matrix is given by
n 123 xx t .
we wish to decorrelate the data dimensions from one another .
we can do this with a linear transforma - tion w , which will transform the data matrix x as follows :
y = w x .
in order for w to be a decorrelating matrix , y y t must be diagonal .
however , we can restrict our search only to w s that satisfy
y y t = ( n 123 ) i .
in other words , w s that make the covariance matrix of the transformed data matrix equal to the identity .
there are multiple w s that t this description , so we can restrict our search further by requiring
given these restrictions , we can nd w :
w = w t .
y y t = ( n 123 ) i w xx t w t = ( n 123 ) i
w t w xx t w t = ( n 123 ) w t w 123xx t w t = ( n 123 ) w t
w 123xx t = ( n 123 ) i
w 123 = ( n 123 ) ( xx t ) 123 n 123 ( xx t ) 123
( xx t ) 123
123 is easily found because xx t is symmetric and hence orthogonally diagonalizable .
that is ,
xx t = p dp t
for some orthogonal matrix p and diagonal matrix d
( xx t ) 123
( cid : 123 ) ( cid : 123 ) xx t ( cid : 123 ) 123 ( cid : 123 ) 123 ( cid : 123 ) ( cid : 123 ) p dp t ( cid : 123 ) 123 ( cid : 123 ) 123 = ( cid : 123 ) p d123p t ( cid : 123 ) 123
where d 123
123 is just d with all the elements taken to the power 123
= p d 123
so , w = ( xx t ) 123 123 transforms x in such a way that the resultant data dimensions are uncorrelated with one another and the variance in each dimension is exactly 123
w may also be thought of as rotating x to the space of its principal components , dividing each principal component by the square root of the variance in that direction , and then rotating back to pixel space .
w is called a whitening matrix , and is referred to as the zero components analysis ( zca ) solution to the equation
the dewhitening matrix , w 123 , is given by
y y t = diagonal .
w 123 = p d
123 p t .
feed - forward neural networks
a feed - forward neural network with one hidden layer is shown in figure b . 123
neuron k in layer l receives as input the value
k = bl
k is the bias into neuron k in layer l ,
nl123 is the number of neurons in layer l 123 ,
is the weight between unit i in layer l 123 and unit k in layer l , and is the output of unit i in layer l 123
the neuron then computes its output
k = f ( xl
where f is any dierentiable function of the neuron ' s total input .
the neurons in the data layer just output the data .
finally , we come up with some function
of the output that we would like the neural net to maximize ( this can be seen as just another layer on top of the output layer ) , where l is the number of layers in the neural network .
e should be dierentiable
is readily computable .
figure b . 123 : a feed - forward neural network with one hidden layer .
training the network consists of clamping the data neurons at the data and updating the parameters
( the weights and biases ) in the direction of the gradient .
the derivatives can be computed as follows :
if l = l
is assumed to be readily computable and from this all the other derivatives can be computed ,
working down from the top layer .
this is called the backpropagation algorithm .
labeler instruction sheet
criteria for deciding whether to include an image
the main test is : would you be quite likely to say the category name if asked to give a single basic
category to describe the main object in the image ?
it ' s worse to include one that shouldn ' t be included than to exclude one .
false positives are worse
than false negatives .
if there is more than one object that is roughly equally prominent , reject even if they are all of
the right class .
if it is a line drawing or cartoon , reject .
you can accept fairly photorealistic drawings that have
do not reject just because the viewpoint is unusual or the object is partially occluded ( provided you think you might have assigned the right label without priming ) .
we want ones with unusual
do not reject just because the background is cluttered .
we want some cluttered backgrounds
also , do not reject just because the background is uniform .
do not worry too much about accepting duplicates or near duplicates .
if you are pretty sure it ' s a duplicate , reject it .
but we will eliminate any remaining duplicates later , so including duplicates is not a bad error .
if a category has two meanings ( like mouse ) , only include the main meaning .
if there is doubt
about what this is , then ask .
cifar - 123 class structure
following is the class and superclass structure of the cifar - 123 dataset .
each superclass contains ve classes .
where the name of the class is plural , the labelers were instructed not to reject images in which multiple instances of the object appear .
aquatic mammals
ordinary sh ( excluding trout and atsh and salmon )
food containers
cups , mugs , glasses
fruit and vegetables
household electrical devices
household furniture
large carnivores
large man - made outdoor things
large natural outdoor scenes
large omnivores / herbivores
mid - size mammals
non - insect invertebrates
small mammals
vehicles 123
vehicles 123
