kernel - based learning algorithms work by embedding the data into a euclidean space , and then searching for linear relations among the embedded data points .
the embedding is performed implicitly , by specifying the inner products between each pair of points in the embedding space .
this information is contained in the so - called kernel matrix , a symmetric and positive semidenite matrix that encodes the relative positions of all points .
specifying this matrix amounts to specifying the geometry of the embedding space and inducing a notion of similarity in the input space|classical model selection problems in machine learning .
in this paper we show how the kernel matrix can be learned from data via semidenite programming ( sdp ) techniques .
when applied to a kernel matrix associated with both training and test data this gives a powerful transductive algorithm| using the labeled part of the data one can learn an embedding also for the unlabeled part .
the similarity between test points is inferred from training points and their labels .
importantly , these learning problems are convex , so we obtain a method for learning both the model class and the function without local minima .
furthermore , this approach leads directly to a convex method for learning the 123 - norm soft margin parameter in support vector machines , solving an important open
keywords : kernel methods , learning kernels , transduction , model selection , support vector ma - chines , convex optimization , semidenite programming
c ( cid : 123 ) 123 gert r . g .
lanckriet , nello cristianini , peter bartlett , laurent el ghaoui and michael i .
jordan .
lanckriet , cristianini , bartlett , el ghaoui and jordan
recent advances in kernel - based learning algorithms have brought the eld of machine learning closer to the desirable goal of autonomy|the goal of providing learning systems that require as little intervention as possible on the part of a human user .
in particular , kernel - based algorithms are generally formulated in terms of convex optimization problems , which have a single global optimum and thus do not require heuristic choices of learning rates , starting congurations or other free parameters .
there are , of course , statistical model selection problems to be faced within the kernel approach; in particular , the choice of the kernel and the corresponding feature space are central choices that must generally be made by a human user .
while this provides opportunities for prior knowledge to be brought to bear , it can also be dicult in practice to nd prior justication for the use of one kernel instead of another .
it would be desirable to explore model selection methods that allow kernels to be chosen in a more automatic way based on data .
it is important to observe that we do not necessarily need to choose a kernel function , specifying the inner product between the images of all possible data points when mapped from an input space x to an appropriate feature space f .
since kernel - based learning methods extract all information needed from inner products of training data points in f , the values of the kernel function at pairs which are not present are irrelevant .
so , there is no need to learn a kernel function over the entire sample space to specify the embedding of a nite training data set via a kernel function mapping .
instead , it is sucient to specify a nite - dimensional kernel matrix ( also known as a gram matrix ) that contains as its entries the inner products in f between all pairs of data points .
note also that it is possible to show that any symmetric positive semidenite matrix is a valid gram matrix , based on an inner product in some hilbert space .
this suggests viewing the model selection problem in terms of gram matrices rather than kernel functions .
in this paper our main focus is transduction|the problem of completing the labeling of a partially labeled dataset .
in other words , we are required to make predictions only at a nite set of points , which are specied a priori .
thus , instead of learning a function , we only need to learn a set of labels .
there are many practical problems in which this formulation is natural|an example is the prediction of gene function , where the genes of interest are specied a priori , but the function of many of these genes is unknown .
we will address this problem by learning a kernel matrix corresponding to the entire dataset , a matrix that optimizes a certain cost function that depends on the available labels .
in other words , we use the available labels to learn a good embedding , and we apply it to both the labeled and the unlabeled data .
the resulting kernel matrix can then be used in combination with any of a number of existing learning algorithms that use kernels .
one example that we discuss in detail is the support vector machine ( svm ) , where our methods yield a new transduction method for svms that scales polynomially with the number of test points .
furthermore , this approach will oer us a method to optimize the 123 - norm soft margin parameter for these svm learning algorithms , solving an important open problem .
all this can be done in full generality by using techniques from semidenite programming ( sdp ) , a branch of convex optimization that deals with the optimization of convex functions over the convex cone of positive semidenite matrices , or convex subsets thereof .
any convex set of kernel matrices is a set of this kind .
furthermore , it turns out that many natural cost functions , motivated by error bounds , are convex in the kernel matrix .
a second application of the ideas that we present here is to the problem of combining data from multiple sources .
specically , assume that each source is associated with a kernel function , such that a training set yields a set of kernel matrices .
the tools that we develop in this paper make
learning the kernel matrix with semidefinite programming
it possible to optimize over the coecients in a linear combination of such kernel matrices .
these coecients can then be used to form linear combinations of kernel functions in the overall classier .
thus this approach allows us to combine possibly heterogeneous data sources , making use of the reduction of heterogeneous data types to the common framework of kernel matrices , and choosing coecients that emphasize those sources most useful in the classication decision .
in section 123 , we recall the main ideas from kernel - based learning algorithms , and introduce a variety of criteria that can be used to assess the suitability of a kernel matrix : the hard margin , the 123 - norm and 123 - norm soft margin , and the kernel alignment .
section 123 reviews the basic concepts of semidenite programming .
in section 123 we put these ideas together and consider the optimization of the various criteria over sets of kernel matrices .
for a set of linear combinations of xed kernel matrices , these optimization problems reduce to sdp .
if the linear coecients are constrained to be positive , they can be simplied even further , yielding a quadratically - constrained quadratic program , a special case of the sdp framework .
if the linear combination contains the identity matrix , we obtain a convex method for optimizing the 123 - norm soft margin parameter in support vector machines .
section 123 presents statistical error bounds that motivate one of our cost functions .
empirical results are reported in section 123
vectors are represented in bold notation , e . g . , v 123 rn , and their scalar components in italic script , e . g . , v123; v123; : : : ; vn .
matrices are represented in italic script , e . g . , x 123 rmn .
for a square , symmetric matrix x , x 123 means that x is positive semidenite , while x 123 means that x is positive denite .
for a vector v , the notations v 123 and v > 123 are understood componentwise .
kernel methods
kernel - based learning algorithms ( see , for example , cristianini and shawe - taylor , 123; scholkopf and smola , 123; shawe - taylor and cristianini , 123 ) work by embedding the data into a hilbert space , and searching for linear relations in such a space .
the embedding is performed implicitly , by specifying the inner product between each pair of points rather than by giving their coordinates explicitly .
this approach has several advantages , the most important deriving from the fact that the inner product in the embedding space can often be computed much more easily than the coordinates of the points themselves .
given an input set x , and an embedding space f , we consider a map ' : x ! f .
given two points xi 123 x and xj 123 x , the function that returns the inner product between their images in the space f is known as the kernel function .
denition 123 a kernel is a function k , such that k ( x; z ) = h ' ( x ) ; ' ( z ) i for all x; z 123 x , where ' is a mapping from x to an ( inner product ) feature space f .
a kernel matrix is a square matrix k 123 rnn such that kij = k ( xi; xj ) for some x123; : : : ; xn 123 x and some kernel function k .
the kernel matrix is also known as the gram matrix .
it is a symmetric , positive semidenite i=123 , it completely
matrix , and since it species the inner products between all pairs of points fxign determines the relative positions of those points in the embedding space .
since in this paper we will consider a nite input set x , we can characterize kernel functions
and matrices in the following simple way .
proposition 123 every positive semidenite and symmetric matrix is a kernel matrix .
conversely , every kernel matrix is symmetric and positive semidenite .
lanckriet , cristianini , bartlett , el ghaoui and jordan
notice that , if we have a kernel matrix , we do not need to know the kernel function , nor the implicitly dened map ' , nor the coordinates of the points ' ( xi ) .
we do not even need x to be a vector space; in fact in this paper it will be a generic nite set .
we are guaranteed that the data are implicitly mapped to some hilbert space by simply checking that the kernel matrix is symmetric and positive semidenite .
the solutions sought by kernel - based algorithms such as the support vector machine ( svm ) are
ane functions in the feature space :
f ( x ) = hw; ' ( x ) i + b;
for some weight vector w 123 f .
the kernel can be exploited whenever the weight vector can be expressed as a linear combination of the training points , w = pn i=123 i ' ( xi ) , implying that we can express f as
f ( x ) =
ik ( xi; x ) + b :
for example , for binary classication , we can use a thresholded version of f ( x ) , i . e . , sign ( f ( x ) ) , as a decision function to classify unlabeled data .
if f ( x ) is positive , then we classify x as belonging to class +123; otherwise , we classify x as belonging to class 123
an important issue in applications is that of choosing a kernel k for a given learning task; intuitively , we wish to choose a kernel that induces the \right " metric in the input space .
123 criteria used in kernel methods
kernel methods choose a function that is linear in the feature space by optimizing some criterion over the sample .
this section describes several such criteria ( see , for example , cristianini and shawe - taylor , 123; scholkopf and smola , 123; shawe - taylor and cristianini , 123 ) .
all of these criteria can be considered as measures of separation of the labeled data .
we rst consider the hard margin optimization problem .
denition 123 hard margin given a labeled sample sl = f ( x123; y123 ) ; : : : ; ( xn; yn ) g , the hyperplane ( w; b ) that solves the optimization problem yi ( hw; ' ( xi ) i + b ) 123;
i = 123; : : : ; n;
realizes the maximal margin classier with geometric margin ( cid : 123 ) = 123=kwk123 , assuming it exists .
geometrically , ( cid : 123 ) corresponds to the distance between the convex hulls ( the smallest convex sets
that contain the data in each class ) of the two classes ( bennett and bredensteiner , 123 ) .
by transforming ( 123 ) into its corresponding lagrangian dual problem , the solution is given by
! ( k ) = 123= ( cid : 123 ) 123
= hw; wi
123t e t g ( k ) : 123; t y = 123;
where e is the n - vector of ones , 123 rn , g ( k ) is dened by gij ( k ) = ( k ) ijyiyj = k ( xi; xj ) yiyj , and 123 means i 123; i = 123; : : : ; n .
the hard margin solution exists only when the labeled sample is linearly separable in feature space .
for a non - linearly - separable labeled sample sl , we can dene the soft margin .
we consider the 123 - norm and 123 - norm soft margins .
learning the kernel matrix with semidefinite programming
denition 123 123 - norm soft margin given a labeled sample sl = f ( x123; y123 ) ; : : : ; ( xn; yn ) g , the hyperplane ( w; b ) that solves the optimization problem
hw; wi + c yi ( hw; ' ( xi ) i + b ) 123 i;
i = 123; : : : ; n
i = 123; : : : ; n
realizes the 123 - norm soft margin classier with geometric margin ( cid : 123 ) = 123=kwk123
this margin is also called the 123 - norm soft margin .
as for the hard margin , we can express the solution of ( 123 ) in a revealing way by considering the
corresponding lagrangian dual problem :
! s123 ( k ) = hw; wi + c
123t e t g ( k ) : c 123; t y = 123 :
denition 123 123 - norm soft margin given a labeled sample sl = f ( x123; y123 ) ; : : : ; ( xn; yn ) g , the hyperplane ( w; b ) that solves the optimization problem
hw; wi + c yi ( hw; ' ( xi ) i + b ) 123 i;
i = 123; : : : ; n
i = 123; : : : ; n
realizes the 123 - norm soft margin classier with geometric margin ( cid : 123 ) = 123=kwk123
this margin is also called the 123 - norm soft margin .
again , by considering the corresponding dual problem , the solution of ( 123 ) can be expressed as
! s123 ( k ) = hw; wi + c
123t e t ( cid : 123 ) g ( k ) +
in : 123; t y = 123 :
with a xed kernel , all of these criteria give upper bounds on misclassication probability ( see , for example , chapter 123 of cristianini and shawe - taylor , 123 ) .
solving these optimization problems for a single kernel matrix is therefore a way of optimizing an upper bound on error probability .
in this paper , we allow the kernel matrix to be chosen from a class of kernel matrices .
previous error bounds are not applicable in this case .
however , as we will see in section 123 , the margin ( cid : 123 ) can be used to bound the performance of support vector machines for transduction , with a linearly parameterized class of kernels .
we do not discuss further the merit of these dierent cost functions , deferring to the current literature on classication , where these cost functions are widely used with xed kernels .
our goal is to show that these cost functions can be optimized|with respect to the kernel matrix|in an
lanckriet , cristianini , bartlett , el ghaoui and jordan
finally , we dene the alignment of two kernel matrices ( cristianini et al . , 123 , 123 ) .
given an ( unlabeled ) sample s = fx123; : : : ; xng , we use the following ( frobenius ) inner product between gram matrices , hk123; k123if = trace ( k t denition 123 alignment the ( empirical ) alignment of a kernel k123 with a kernel k123 with respect to the sample s is the quantity
123 k123 ) =pn
i;j=123 k123 ( xi; xj ) k123 ( xi; xj ) .
where ki is the kernel matrix for the sample s using kernel ki .
^a ( s; k123; k123 ) =
phk123; k123ifhk123; k123if
this can also be viewed as the cosine of the angle between two bi - dimensional vectors k123 and k123 , representing the gram matrices .
notice that we do not need to know the labels for the sample s in order to dene the alignment of two kernels with respect to s .
however , when the vector y of f123g labels for the sample is known , we can consider k123 = yyt |the optimal kernel since k123 ( xi; xj ) = 123 if yi = yj and k123 ( xi; xj ) = 123 if yi 123= yj .
the alignment of a kernel k with k123 with respect to s can be considered as a quality measure for k :
^a ( s; k; yyt ) =
phk; kifhyyt ; yytif
= k; yytf
since yyt ; yytf = n123
semidenite programming ( sdp )
in this section we review the basic denition of semidenite programming as well as some important concepts and key results .
details and proofs can be found in boyd and vandenberghe ( 123 ) .
semidenite programming ( nesterov and nemirovsky , 123; vandenberghe and boyd , 123; boyd and vandenberghe , 123 ) deals with the optimization of convex functions over the convex cone123 of symmetric , positive semidenite matrices
p = ' x 123 rpp j x = x t ; x 123 ;
or ane subsets of this cone .
given proposition 123 , p can be viewed as a search space for possible kernel matrices .
this consideration leads to the key problem addressed in this paper|we wish to specify a convex cost function that will enable us to learn the optimal kernel matrix within p using
123 denition of semidenite programming
a linear matrix inequality , abbreviated lmi , is a constraint of the form
f ( u ) : = f123 + u123f123 + : : : + uqfq 123 :
here , u is the vector of decision variables , and f123; : : : ; fq are given symmetric p p matrices .
the notation f ( u ) 123 means that the symmetric matrix f is negative semidenite .
note that such a constraint is in general a nonlinear constraint; the term \linear " in the name lmi merely
s ( cid : 123 ) rd is a convex cone if and only if 123x; y 123 s and 123; 123 , we have x + y 123 s .
learning the kernel matrix with semidefinite programming
emphasizes that f is ane in u .
perhaps the most important feature of an lmi constraint is its convexity : the set of u that satisfy the lmi is a convex set .
an lmi constraint can be seen as an innite set of scalar , ane constraints .
indeed , for a given u , f ( u ) 123 if and only if zt f ( u ) z 123 for every z; every constraint indexed by z is an ane inequality , in the ordinary sense , i . e . , the left - hand side of the inequality is a scalar , composed of a linear term in u and a constant term .
alternatively , using a standard result from linear algebra , we may state the constraint as
123z 123 p : trace ( f ( u ) z ) 123 :
this can be seen by writing down the spectral decomposition of z and using the fact that zt f ( u ) z 123 for every z .
a semidenite program ( sdp ) is an optimization problem with a linear objective , and linear
matrix inequality and ane equality constraints .
denition 123 a semidenite program is a problem of the form
f j ( u ) = f j au = b;
123 + u123f j
123 + : : : + uqf j
j = 123; : : : ; l
where u 123 rq is the vector of decision variables , c 123 rq is the objective vector , and matrices i = ( f j
i ) t 123 rpp are given .
given the convexity of its lmi constraints , sdps are convex optimization problems .
the usefulness of the sdp formalism stems from two important facts .
first , despite the seemingly very specialized form of sdps , they arise in a host of applications; second , there exist interior - point algorithms to solve sdps that have good theoretical and practical computational eciency ( vandenberghe and
one very useful tool to reduce a problem to an sdp is the so - called schur complement lemma;
it will be invoked repeatedly .
lemma 123 ( schur complement lemma ) consider the partitioned symmetric matrix
x = x t = ( cid : 123 ) a b
bt c ;
where a; c are square and symmetric .
if det ( a ) 123= 123 , we dene the schur complement of a in x by the matrix s = c bt a123b .
the schur complement lemma states that if a 123 , then x 123 if and only if s 123
to illustrate how this lemma can be used to cast a nonlinear convex optimization problem as
an sdp , consider the following result :
lemma 123 the quadratically constrained quadratic program ( qcqp )
i = 123; : : : ; m;
lanckriet , cristianini , bartlett , el ghaoui and jordan
with fi ( u ) , ( aiu + bi ) t ( aiu + bi ) ct
i u di , is equivalent to the semidenite programming
( a123u + b123 ) t
( aiu + bi ) t
a123u + b123
t u + d123 + t 123; i u + di 123;
aiu + bi
i = 123; : : : ; m :
this can be seen by rewriting the qcqp ( 123 ) as
t f123 ( u ) 123;
i = 123; : : : ; m :
note that for a xed and feasible u , t = f123 ( u ) is the optimal solution .
the convex quadratic t u + d123 ) ( a123u + b123 ) t i 123 ( a123u + b123 ) 123 is now equivalent to the inequality t f123 ( u ) = ( t + c123 following lmi , using the schur complement lemma 123 :
( a123u + b123 ) t
a123u + b123
t u + d123 + t 123 :
similar steps for the other quadratic inequality constraints nally yield ( 123 ) , an sdp in standard form ( 123 ) , equivalent to ( 123 ) .
this shows that a qcqp can be cast as an sdp .
of course , in practice a qcqp should not be solved using general - purpose sdp solvers , since the particular structure of the problem at hand can be eciently exploited .
the above show that qcqps , and in particular linear programming problems , belong to the sdp family .
an important principle in optimization|perhaps even the most important principle|is that of duality .
to illustrate duality in the case of an sdp , we will rst review basic concepts in duality theory and then show how they can be extended to semidenite programming .
in particular , duality will give insights into optimality conditions for the semidenite program .
consider an optimization problem with n variables and m scalar constraints :
i = 123; : : : ; m;
where u 123 rn .
in the context of duality , problem ( 123 ) is called the primal problem; we denote its optimal value p .
for now , we do not assume convexity .
denition 123 lagrangian the lagrangian l : rn+m ! r corresponding to the minimization problem ( 123 ) is dened as
l ( u; ) = f123 ( u ) + 123f123 ( u ) + : : : + mfm ( u ) :
the i 123 r; i = 123; : : : ; m are called lagrange multipliers or dual variables .
learning the kernel matrix with semidefinite programming
one can now notice that
h ( u ) = max
if fi ( u ) 123; i = 123; : : : ; m
123 l ( u; ) = f123 ( u )
so , the function h ( u ) coincides with the objective f123 ( u ) in regions where the constraints fi ( u ) 123 , in other words , h acts as a i = 123; : : : ; m , are satised and h ( u ) = +123 in infeasible regions .
\barrier " of the feasible set of the primal problem .
thus we can as well use h ( u ) as objective function and rewrite the original primal problem ( 123 ) as an unconstrained optimization problem :
p = min
123 l ( u; ) :
the notion of weak duality amounts to exchanging the \min " and \max " operators in the above formulation , resulting in a lower bound on the optimal value of the primal problem .
strong duality refers to the case when this exchange can be done without altering the value of the result : the lower bound is actually equal to the optimal value p .
while weak duality always hold , even if the primal problem ( 123 ) is not convex , strong duality may not hold .
however , for a large class of generic convex problems , strong duality holds .
lemma 123 weak duality for all functions f123; f123; : : : ; fm in ( 123 ) , not necessarily convex , we can exchange the max and the min and get a lower bound on p :
d = max
u l ( u; ) min
123 l ( u; ) = p :
the objective function of the maximization problem is now called the ( lagrange ) dual function .
denition 123 ( lagrange ) dual function the ( lagrange ) dual function g : rm ! r is dened
g ( ) = min
u l ( u; )
f123 ( u ) + 123f123 ( u ) + : : : + mfm ( u ) :
furthermore g ( ) is concave , even if the fi ( u ) are not convex .
the concavity can easily be seen by considering rst that for a given u , l ( u; ) is an ane function of and hence is a concave function .
since g ( ) is the pointwise minimum of such concave functions , it is concave .
denition 123 lagrange dual problem the lagrange dual problem is dened as
d = max
since g ( ) is concave , this will always be a convex optimization problem , even if the primal is not .
by weak duality , we always have d p , even for non - convex problems .
the value p d is called the duality gap .
for convex problems , we usually ( although not always ) have strong duality at the
d = p;
which is also referred to as a zero duality gap .
for convex problems , a sucient condition for zero duality gap is provided by slaters condition :
lemma 123 slaters condition if the primal problem ( 123 ) is convex and is strictly feasible , i . e . , 123 u123 : fi ( u123 ) < 123; i = 123; : : : ; m , then
p = d :
lanckriet , cristianini , bartlett , el ghaoui and jordan
123 sdp duality and optimality conditions
consider for simplicity the case of an sdp with a single lmi constraint , and no ane equalities :
p = min
ct u subject to f ( u ) = f123 + u123f123 + : : : uqfq 123 :
the general case of multiple lmi constraints and ane equalities can be handled by elimination of the latter and using block - diagonal matrices to represent the former as a single lmi .
the classical lagrange duality theory outlined in the previous section does not directly apply here , since we are not dealing with nitely many constraints in scalar form; as noted earlier , the lmi constraint involves an innite number of such constraints , of the form ( 123 ) .
one way to handle such constraints is to introduce a lagrangian of the form
l ( u; z ) = ct u + trace ( zf ( u ) ) ;
where the dual variable z is now a symmetric matrix , of the same size as f ( u ) .
we can check that such a lagrange function fullls the same role assigned to the function dened in denition 123 for the case with scalar constraints .
indeed , if we dene h ( u ) = maxz123 l ( u; z ) then
h ( u ) = max
z123 l ( u; z ) = ct u if f ( u ) 123;
thus , h ( u ) is a barrier for the primal sdp ( 123 ) , that is , it coincides with the objective of ( 123 ) on its feasible set , and is innite otherwise .
notice that to the lmi constraint we now associate a multiplier matrix , which will be constrained to the positive semidenite cone .
in the above , we made use of the fact that , for a given symmetric matrix f ,
` ( f ) : = sup
is +123 if f has a positive eigenvalue , and zero if f is negative semidenite .
this property is obvious for diagonal matrices , since in that case the variable z can be constrained to be diagonal without loss of generality .
the general case follows from the fact that if f has the eigenvalue decomposition f = u u t , where is a diagonal matrix containing the eigenvalues of f , and u is orthogonal , then trace ( zf ) = trace ( z 123 ) , where z 123 = u t zu spans the positive semidenite cone whenever z
using the above lagrangian , one can cast the original problem ( 123 ) as an unconstrained opti -
p = min
z123 l ( u; z ) :
by weak duality , we obtain a lower bound on p by exchanging the min and max :
d = max
u l ( u; z ) min
z123 l ( u; z ) = p :
the inner minimization problem is easily solved analytically , due to the special structure of the
we obtain a closed form for the ( lagrange ) dual function :
g ( z ) = min
u l ( u; z ) = min
ct u + trace ( zf123 ) +
if ci = trace ( zfi ) ; i = 123; : : : ; q
learning the kernel matrix with semidefinite programming
the dual problem can be explicitly stated as follows :
d = max
u l ( u; z ) = max
trace ( zf123 ) subject to z 123; ci = trace ( zfi ) ; i = 123; : : : ; q : ( 123 )
we observe that the above problem is an sdp , with a single lmi constraint and q ane equalities in the matrix dual variable z .
while weak duality always holds , strong duality may not , even for sdps .
not surprisingly , a slater - type condition ensures strong duality .
precisely , if the primal sdp ( 123 ) is strictly feasible , that is , there exists a u123 such that f ( u123 ) ` 123 , then p = d .
if , in addition , the dual problem is also strictly feasible , meaning that there exists a z 123 such that ci = trace ( zfi ) , i = 123; : : : ; q , then both primal and dual optimal values are attained by some optimal pair ( u; z ) .
in that case , we can characterize such optimal pairs as follows .
in view of the equality constraints of the dual problem , the duality gap can be expressed as
p d = ct u trace ( z f123 ) = trace ( z f ( u ) ) :
a zero duality gap is equivalent to trace ( z f ( u ) ) = 123 , which in turn is equivalent to z f ( u ) = o , where o denotes the zero matrix , since the product of a positive semidenite and a negative semidenite matrix has zero trace if and only if it is zero .
to summarize , consider the sdp ( 123 ) and its lagrange dual ( 123 ) .
if either problem is strictly feasible , then they share the same optimal value .
if both problems are strictly feasible , then the optimal values of both problems are attained and coincide .
in this case , a primal - dual pair ( u; z ) is optimal if and only if
f ( u ) 123; ci = trace ( z fi ) ; zf ( u ) = o :
i = 123; : : : ; q;
the above conditions represent the expression of the general karush - kuhn - tucker ( kkt ) condi - tions in the semidenite programming setting .
the rst three sets of conditions express that u and z are feasible for their respective problems; the last condition expresses a complementarity
for a pair of strictly feasible primal - dual sdps , solving the primal minimization problem is equivalent to maximizing the dual problem and both can thus be considered simultaneously .
al - gorithms indeed make use of this relationship and use the duality gap as a stopping criterion .
a general - purpose program such as sedumi ( sturm , 123 ) handles those problems eciently .
this code uses interior - point methods for sdp ( nesterov and nemirovsky , 123 ) ; these methods have a worst - case complexity of o ( q123p123 : 123 ) for the general problem ( 123 ) .
in practice , problem structure can be exploited for great computational savings : e . g . , when f ( u ) 123 rpp consists of l diagonal blocks of size pi; i = 123; : : : ; l , these methods have a worst - case complexity of o ( q123 ( pl ( vandenberghe and boyd , 123 ) .
algorithms for learning kernels
we work in a transduction setting , where some of the data ( the training set sntr = f ( x123; y123 ) ; : : : ; ( xntr ; yntr ) g ) are labeled , and the remainder ( the test set tnt = fxntr+123; : : : ; xntr+ntg ) are unlabeled , and the
lanckriet , cristianini , bartlett , el ghaoui and jordan
aim is to predict the labels of the test data .
in this setting , optimizing the kernel corresponds to choosing a kernel matrix .
this matrix has the form
k = ( cid : 123 ) ktr ktr;t
tr;t kt ;
where kij = h ' ( xi ) ; ' ( xj ) i , i; j = 123; : : : ; ntr; ntr + 123; : : : ; ntr + nt .
by optimizing a cost function over the \training - data block " ktr , we want to learn the optimal mixed block ktr;t and the optimal \test - data block " kt .
this implies that training and test - data blocks must somehow be entangled : tuning training - data entries in k ( to optimize their embedding ) should imply that test - data entries are automati - cally tuned in some way as well .
this can be achieved by constraining the search space of possible kernel matrices : we control the capacity of the search space of possible kernel matrices in order to prevent overtting and achieve good generalization on test data .
we rst consider a general optimization problem in which the kernel matrix k is restricted to a convex subset k of p , the positive semidenite cone .
we then consider two specic examples .
the rst is the set of positive semidenite matrices with bounded trace that can be expressed as a linear combination of kernel matrices from the set fk123; : : : ; kmg .
that is , k is the set of matrices
in this case , the set k lies in the intersection of a low - dimensional linear subspace with the positive semidenite cone p .
geometrically this can be viewed as computing all embeddings ( for every ki ) , in disjoint feature spaces , and then weighting these .
the set fk123; : : : ; kmg could be a set of initial \guesses " of the kernel matrix , e . g . , linear , gaussian or polynomial kernels with dierent kernel parameter values .
instead of ne - tuning the kernel parameter for a given kernel using cross - validation , one can now evaluate the given kernel for a range of kernel parameters and then optimize the weights in the linear combination of the obtained kernel matrices .
alternatively , the ki could be chosen as the rank - one matrices ki = vivt i , with vi a subset of the eigenvectors of k123 , an initial kernel matrix , or with vi some other set of orthogonal vectors .
a practically important form is the case in which a diverse set of possibly good gram matrices ki ( similarity measures / representations ) has been constructed , e . g . , using heterogeneous data sources .
the challenge is to combine these measures into one optimal similarity measure ( embedding ) , to be used for learning .
the second example of a restricted set k of kernels is the set of positive semidenite matrices with bounded trace that can be expressed as a linear combination of kernel matrices from the set fk123; : : : ; kmg , but with the parameters i constrained to be non - negative .
that is , k is the set of matrices k satisfying
i 123 f123; : : : ; mg
learning the kernel matrix with semidefinite programming
it has two advantages : this further constrains the class of functions that can be represented .
we shall see that the corresponding optimization problem has signicantly reduced computational complexity , and it is more convenient for studying the statistical properties of a class of kernel
as we will see in section 123 , we can estimate the performance of support vector machines for transduction using properties of the class k .
as explained in section 123 , we can use a thresholded version of f ( x ) , i . e . , sign ( f ( x ) ) , as a binary classication decision .
using this decision function , we will prove that the proportion of errors on the test data tn ( where , for convenience , we suppose that training and test data have the same size ntr = nt = n ) is , with probability 123 ( over the random draw of the training set sn and test set tn ) , bounded by
maxf123 yif ( xi ) ; 123g +
pn123 +p123 log ( 123= ) +sc ( k ) n ( cid : 123 ) 123 ! ;
where ( cid : 123 ) is the 123 - norm soft margin on the data and c ( k ) is a certain measure of the complexity of the kernel class k .
for instance , for the class k of positive linear combinations dened above , c ( k ) mc , where m is the number of kernel matrices in the combination and c is the bound on the trace .
so , the proportion of errors on the test data is bounded by the average error on the training set and a complexity term , determined by the richness of the class k and the margin ( cid : 123 ) .
good generalization can thus be expected if the error on the training set is small , while having a large margin and a class k that is not too rich .
the next section presents the main optimization result of the paper : minimizing a generalized performance measure ! c; ( k ) with respect to the kernel matrix k can be realized in a semidenite programming framework .
afterwards , we prove a second general result showing that minimizing ! c; ( k ) with respect to a kernel matrix k , constrained to the linear subspace k = pm i=123 iki with 123 , leads to a quadratically constrained quadratic programming ( qcqp ) problem .
maximizing the margin of a hard margin svm with respect to k , as well as both soft margin cases can then be treated as specic instances of this general result and will be discussed in later sections .
123 general optimization result
in this section , we rst of all show that minimizing the generalized performance measure
! c; ( k ) = max
123t e t ( g ( k ) + i ) : c 123; t y = 123;
with 123 , on the training data with respect to the kernel matrix k , in some convex subset k of positive semidenite matrices with trace equal to c ,
trace ( k ) = c;
can be realized in a semidenite programming framework .
we rst note a fundamental property of the generalized performance measure , a property that
is crucial for the remainder of the paper .
proposition 123 the quantity
! c; ( k ) = max
123t e t ( g ( k ) + i ) : c 123; t y = 123;
is convex in k .
lanckriet , cristianini , bartlett , el ghaoui and jordan
this is easily seen by considering rst that 123t e t ( g ( k ) + i ) is an ane function of k , and hence is a convex function as well .
secondly , we notice that ! c; ( k ) is the pointwise maximum of such convex functions and is thus convex .
the constraints c 123; t y = 123 are obviously problem ( 123 ) is now a convex optimization problem .
the following theorem shows that , for a
suitable choice of the set k , this problem can be cast as an sdp .
theorem 123 given a labeled sample sntr = f ( x123; y123 ) ; : : : ; ( xntr ; yntr ) g with the set of labels denoted y 123 rntr , the kernel matrix k 123 k that optimizes ( 123 ) , with 123 , can be found by solving the following convex optimization problem :
trace ( k ) = c; k 123 k; ( cid : 123 ) g ( ktr ) + intr ( e + + y ) t
t 123ct e 123; e + + y
proof we begin by substituting ! c; ( ktr ) , as dened in ( 123 ) , into ( 123 ) , which yields
123t e t ( g ( ktr ) + intr ) : c 123; t y = 123; trace ( k ) = c;
with c a constant .
assume that ktr 123 , hence g ( ktr ) 123 and g ( ktr ) + intr 123 since 123 ( the following can be extended to the general semidenite case ) .
from proposition 123 , we know that ! c; ( ktr ) is convex in ktr and thus in k .
given the convex constraints in ( 123 ) , the optimization problem is thus certainly convex in k .
we write this as
123t e t ( g ( ktr ) + intr ) ;
c 123; t y = 123; trace ( k ) = c :
we now express the constraint t max 123t e t ( g ( ktr ) + intr ) as an lmi using duality .
in particular , duality will allow us to drop the minimization and the schur complement lemma then yields an lmi .
dene the lagrangian of the maximization problem ( 123 ) by
l ( ; ; ; ) = 123t e t ( g ( ktr ) + intr ) + 123 t + 123yt + 123t ( ce ) ;
where 123 r and ; 123 rntr .
by duality , we have
! c; ( ktr ) = max
123;123; l ( ; ; ; ) = min
l ( ; ; ; ) :
since g ( ktr ) + intr 123 , at the optimum we have
= ( g ( ktr ) + intr ) 123 ( e + + y ) ;
and we can form the dual problem
! c; ( ktr ) = min
( e + + y ) t ( g ( ktr ) + intr ) 123 ( e + + y ) + 123ct e : 123; 123 :
learning the kernel matrix with semidefinite programming
this implies that for any t > 123 , the constraint ! c; ( ktr ) t holds if and only if there exist 123; 123 and such that
( e + + y ) t ( g ( ktr ) + intr ) 123 ( e + + y ) + 123ct e t;
or , equivalently ( using the schur complement lemma ) , such that e + + y
( cid : 123 ) g ( ktr ) + intr ( e + + y ) t
t 123ct e
taking this into account , ( 123 ) can be expressed as
trace ( k ) = c; k 123 k; ( cid : 123 ) g ( ktr ) + intr ( e + + y ) t
t 123ct e 123; e + + y
which yields ( 123 ) .
notice that 123 , diag ( ) 123 , and is thus an lmi; similarly for 123
notice that if k = fk 123g , this optimization problem is an sdp in the standard form ( 123 ) .
of course , in that case there is no constraint to ensure entanglement of training and test - data blocks .
indeed , it is easy to see that the criterion would be optimized with a test matrix kt = o .
consider the constraint k = spanfk123; : : : ; kmg \ fk 123g .
we obtain the following convex
trace ( k ) = c;
which can be written in the standard form of a semidenite program , in a manner analogous to
iki ! = c;
i=123 iki;tr ) + intr e + + y
t 123ct e 123;
( e + + y ) t
lanckriet , cristianini , bartlett , el ghaoui and jordan
to solve this general optimization problem , one has to solve a semidenite programming prob - lem .
general - purpose programs such as sedumi ( sturm , 123 ) use interior - point methods to solve sdp problems ( nesterov and nemirovsky , 123 ) .
these methods are polynomial time .
how - ever , applying the complexity results mentioned in section 123 leads to a worst - case complexity
o ( m + ntr ) 123 ( n123 + n123 positive linear combinations of kernel matrices fk123; : : : ; kmg \ fk 123g :
tr ) ( n + ntr ) 123 : 123 , or roughly o ( m + ntr ) 123n123 : 123 , in this particular case .
consider a further restriction on the set of kernel matrices , where the matrices are restricted to
for this restricted linear subspace of the positive semidenite cone p , we can prove the following
theorem 123 given a labeled sample sntr = f ( x123; y123 ) ; : : : ; ( xntr ; yntr ) g with the set of labels denoted y 123 rntr , the kernel matrix k = pm i=123 iki that optimizes ( 123 ) , with 123 , under the additional constraint 123 can be found by solving the following convex optimization problem , and considering its dual solution :
123t e t ct t y = 123;
i = 123; : : : ; m
where r 123 rm with trace ( ki ) = ri .
proof solving problem ( 123 ) subject to k = pm
i=123 iki , with ki 123 , and the extra constraint
: c123;t y=123
123t e t ( g ( ktr ) + intr ) trace ( k ) = c;
when ! c; ( ktr ) is expressed using ( 123 ) .
we can omit the second constraint , because this is implied by the last two constraints , if ki 123
the problem then reduces to
: c123;t y=123
iki;tr ) + intr )
123t e t ( g ( t r = c;
learning the kernel matrix with semidefinite programming
where ki;tr = ki ( 123 : ntr; 123 : ntr ) .
we can write this as
: 123;t r=c
: c123;t y=123
123t e t diag ( y ) (
: 123;t r=c
: c123;t y=123
: 123;t r=c
: c123;t y=123
: c123;t y=123
: 123;t r=c
iki;tr ) diag ( y ) + intr ! it diag ( y ) ki;trdiag ( y ) t
it g ( ki;tr ) t
it g ( ki;tr ) t ;
with g ( ki;tr ) = diag ( y ) ki;trdiag ( y ) .
the interchange of the order of the minimization and the maximization is justied ( see , e . g . , boyd and vandenberghe , 123 ) because the objective is convex in ( it is linear in ) and concave in , because the minimization problem is strictly feasible in , and the maximization problem is strictly feasible in ( we can skip the case for all elements of y having the same sign , because we cannot even dene a margin in such a case ) .
we thus obtain
: c123;t y=123
: 123;t r=c
it g ( ki;tr ) t : 123;t r=c m : c123;t y=123 " 123t e t : c123;t y=123t e t max i ( cid : 123 ) c
t g ( ki;tr ) :
finally , this can be reformulated as
123t e t ct t y = 123;
i = 123; : : : ; m
which proves the theorem .
this convex optimization problem , a qcqp more precisely , is a special instance of an socp ( second - order cone programming problem ) , which is in turn a special form of sdp ( boyd and vandenberghe , 123 ) .
socps can be solved eciently with programs such as sedumi ( sturm , 123 ) or mosek ( andersen and andersen , 123 ) .
these codes use interior - point methods ( nesterov and nemirovsky , 123 ) which yield a worst - case complexity of o ( mn123 tr ) .
this implies a major improvement compared to the worst - case complexity of a general sdp .
furthermore , the codes simultaneously solve the above problem and its dual form .
they thus return optimal values for the dual variables as well|this allows us to obtain the optimal weights i , for i = 123; : : : ; m .
lanckriet , cristianini , bartlett , el ghaoui and jordan
123 hard margin
in this section , we show how maximizing the margin of a hard margin svm with respect to the kernel matrix can be realized in the semidenite programming framework derived in theorem 123
inspired by ( 123 ) , let us try to nd the kernel matrix k in some convex subset k of positive semidenite matrices for which the corresponding embedding shows maximal margin on the training data , keeping the trace of k constant :
trace ( k ) = c :
note that ! ( ktr ) = ! 123;123 ( ktr ) .
from proposition 123 , we then obtain the following important
corollary 123 the quantity
! ( k ) = max
123t e t g ( k ) : 123; t y = 123;
is convex in k .
so , a fundamental property of the inverse margin is that it is convex in k .
this is essential , since it allows us to optimize this quantity in a convex framework .
the following theorem shows that , for a suitable choice of the set k , this convex optimization problem can be cast as an sdp .
theorem 123 given a linearly separable labeled sample sntr = f ( x123; y123 ) ; : : : ; ( xntr ; yntr ) g with the set of labels denoted y 123 rntr , the kernel matrix k 123 k that optimizes ( 123 ) can be found by solving the following problem :
trace ( k ) = c; k 123 k; ( e + + y ) t
e + + y
proof observe ! ( ktr ) = ! 123;123 ( ktr ) .
apply theorem 123 for c = 123 and = 123
give a large margin on the test data : a test matrix kt = o would optimize the criterion .
if k = fk 123g , there is no constraint to ensure that a large margin on the training data will if we restrict the kernel matrix to a linear subspace k = spanfk123; : : : ; kmg \ fk 123g , we
trace ( k ) = c;
learning the kernel matrix with semidefinite programming
which can be written in the standard form of a semidenite program , in a manner analogous to
iki ! = c;
i=123 iki;tr ) e + + y
( e + + y ) t
notice that the sdp approach is consistent with the bound in ( 123 ) .
the margin is optimized over the labeled data ( via the use of ki;tr ) , while the positive semideniteness and the trace constraint are imposed for the entire kernel matrix k ( via the use of ki ) .
this leads to a general method for learning the kernel matrix with semidenite programming , when using a margin criterion for hard margin svms .
applying the complexity results mentioned in section 123 leads to a worst -
case complexity o ( m + ntr ) 123n123 : 123 when using general - purpose interior - point methods to solve this
furthermore , this gives a new transduction method for hard margin svms .
whereas vapniks original method for transduction scales exponentially in the number of test samples , the new sdp method has polynomial time complexity .
remark .
for the specic case in which the ki are rank - one matrices ki = vivt i , with vi orthonor - mal ( e . g . , the normalized eigenvectors of an initial kernel matrix k123 ) , the semidenite program reduces to a qcqp :
i ) 123; i = 123; : : : ; m
123t e ct t y = 123;
with vi = diag ( y ) vi ( 123 : ntr ) .
this can be seen by observing that , for ki = vivt
123 is equivalent to 123
so , we can apply theorem 123 , with = 123 and c = 123 , where
i vj = ij , we have thatpm
t g ( ki;tr ) = t diag ( y ) vi ( 123 : ntr ) vi ( 123 : ntr ) t diag ( y ) = ( vt
i , with vt
123 hard margin with kernel matrices that are positive linear combinations to learn a kernel matrix from this linear class k , one has to solve a semidenite programming problem : interior - point methods ( nesterov and nemirovsky , 123 ) are polynomial time , but have a worst - case complexity o ( m + ntr ) 123n123 : 123 in this particular case .
we now restrict k to the positive linear combinations of kernel matrices :
lanckriet , cristianini , bartlett , el ghaoui and jordan
assuming positive weights yields a smaller set of kernel matrices , because the weights need not be positive for k to be positive semidenite , even if the components ki are positive semidenite .
moreover , the restriction has benecial computational eects : ( 123 ) the general sdp reduces to a qcqp , which can be solved with signicantly lower complexity o ( mn123 tr ) ; ( 123 ) the constraint can result in improved numerical stability|it prevents the algorithm from using large weights with opposite sign that cancel .
finally , we shall see in section 123 that the constraint also yields better estimates of the generalization performance of these algorithms .
theorem 123 given a labeled sample sntr = f ( x123; y123 ) ; : : : ; ( xntr ; yntr ) g with the set of labels denoted y 123 rntr , the kernel matrix k = pm i=123 iki that optimizes ( 123 ) , with 123 , under the additional constraint 123 can be found by solving the following convex optimization problem , and considering its dual solution :
123t e ct t y = 123;
i = 123; : : : ; m
where r 123 rm with trace ( ki ) = ri .
proof apply theorem 123 for c = 123 and = 123
note once again that the optimal weights i;
i = 123; : : : ; m , can be recovered from the primal - dual solution found by standard software such as sedumi ( sturm , 123 ) or mosek ( andersen and
123 123 - norm soft margin
for the case of non - linearly separable data , we can consider the 123 - norm soft margin cost function in ( 123 ) .
training the svm for a given kernel involves minimizing this quantity with respect to w; b , and , which yields the optimal value ( 123 ) : obviously this minimum is a function of the particular choice of k , which is expressed explicitly in ( 123 ) as a dual problem .
let us now optimize this quantity with respect to the kernel matrix k , i . e . , let us try to nd the kernel matrix k 123 k for which the corresponding embedding yields minimal ! s123 ( ktr ) , keeping the trace of k constant :
trace ( k ) = c :
this is again a convex optimization problem .
theorem 123 given a labeled sample sntr = f ( x123; y123 ) ; : : : ; ( xntr ; yntr ) g with the set of labels denoted y 123 rntr , the kernel matrix k 123 k that optimizes ( 123 ) , can be found by solving the following convex
learning the kernel matrix with semidefinite programming
trace ( k ) = c; k 123 k; ( e + + y ) t
t 123ct e 123; e + + y
proof observe ! s123 ( ktr ) = ! c;123 ( ktr ) .
apply theorem 123 for = 123
again , if k = fk 123g , this is an sdp .
adding the additional constraint ( 123 ) that k is a linear
combination of xed kernel matrices leads to the following sdp :
iki ! = c;
( e + + y ) t
t 123ct e 123; e + + y
remark .
for the specic case in which the ki are rank - one matrices ki = vivt i , with vi or - thonormal ( e . g . , the normalized eigenvectors of an initial kernel matrix k123 ) , the sdp reduces to a qcqp using theorem 123 , with = 123 , in a manner analogous to the hard margin case :
i ) 123; i = 123; : : : ; m
123t e ct t y = 123;
with vi = diag ( y ) vi ( 123 : ntr ) .
solving the original learning problem subject to the extra constraint 123 yields , after applying
theorem 123 , with = 123 :
i = 123; : : : ; m
123t e ct t y = 123;
lanckriet , cristianini , bartlett , el ghaoui and jordan
123 123 - norm soft margin
for the case of non - linearly separable data , we can also consider the 123 - norm soft margin cost function ( 123 ) .
again , training for a given kernel will minimize this quantity with respect to w; b , and and the minimum is a function of the particular choice of k , as expressed in ( 123 ) in dual form .
let us now optimize this quantity with respect to the kernel matrix k :
trace ( k ) = c :
this is again a convex optimization problem , and can be restated as follows .
theorem 123 given a labeled sample sntr = f ( x123; y123 ) ; : : : ; ( xntr ; yntr ) g with the set of labels denoted y 123 rntr , the kernel matrix k 123 k that optimizes ( 123 ) can be found by solving the following
trace ( k ) = c; k 123 k; ( cid : 123 ) g ( ktr ) + 123
( e + + y ) t
c intr e + + y
proof observe ! s123 ( ktr ) = ! 123; ( ktr ) .
apply theorem 123 for c = 123
again , if k = fk 123g , this is an sdp .
moreover , constraining k to be a linear combination
of xed kernel matrices , we obtain
iki ! = c;
i=123 iki;tr ) + 123
c intr e + + y
( e + + y ) t
also , when the ki are rank - one matrices , ki = vivt
i , with vi orthonormal , we obtain a qcqp :
i ) 123; i = 123; : : : ; m
t y = 123;
learning the kernel matrix with semidefinite programming
and , nally , imposing the constraint 123 yields
t y = 123;
i = 123; : : : ; m
following a similar derivation as before : apply theorem 123 with c = 123 , and , for ( 123 ) , observe that 123 is equivalent to pm
i=123 iki 123 if ki = vivt
i and vt
i vj = ij .
123 learning the 123 - norm soft margin parameter = 123=c
this section shows how the 123 - norm soft margin parameter of svms can be learned using sdp or qcqp .
more details can be found in de bie et al .
( 123 ) .
in the previous section , we tried to nd the kernel matrix k 123 k for which the corresponding embedding yields minimal ! s123 ( ktr ) , keeping the trace of k constant .
since in the dual formulation ( 123 ) the identity matrix induced by the 123 - norm formulation appears in exactly the same way as the other matrices ki , we can treat it on the same basis and optimize its weight to obtain the optimal dual formulation , i . e . , to minimize ! s123 ( ktr ) .
since this weight now happens to correspond to the parameter = 123=c , optimizing it corresponds to learning the 123 - norm soft margin parameter and thus has a signicant meaning .
since the parameter = 123=c can be treated in the same way as the weights i , tuning it such that the quantity ! s123 ( ktr; ) is minimized can be viewed as a method for choosing .
first of all , consider the dual formulation ( 123 ) and notice that ! s123 ( ktr; ) is convex in = 123=c ( being the pointwise maximum of ane and thus convex functions in ) .
secondly , since ! 123 leads to ! s123 ( ktr; ) ! 123 , we impose the constraint trace ( k + in ) = c .
this results in the following convex optimization problem :
trace ( k + in ) = c :
according to theorem 123 , this can be restated as follows :
trace ( k + in ) = c; k 123 k; ( cid : 123 ) g ( ktr ) + intr e + + y
( e + + y ) t
lanckriet , cristianini , bartlett , el ghaoui and jordan
again , if k = fk 123g , this is an sdp .
imposing the additional constraint that k is a linear
function of xed kernel matrices , we obtain the sdp
iki + in ! = c;
i=123 iki;tr ) + intr e + + y
( e + + y ) t
and imposing the additional constraint that the ki are rank - one matrices , we obtain a qcqp :
i ) 123; i = 123; : : : ; m
123t e ct t y = 123;
with vi = diag ( y ) vi = diag ( y ) vi ( 123 : ntr ) .
finally , imposing the constraint that 123 yields the
123t e ct t y = 123;
i = 123; : : : ; m
which , as before , is a qcqp .
solving ( 123 ) corresponds to learning the kernel matrix as a positive linear combination of kernel matrices according to a 123 - norm soft margin criterion and simultaneously learning the 123 - norm soft margin parameter = 123=c .
comparing ( 123 ) with ( 123 ) , we can see that this reduces to learning an augmented kernel matrix k 123 as a positive linear combination of kernel matrices and the identity i=123 iki + in , using a hard margin criterion .
however , there is an important dierence : when evaluating the resulting classier , the actual kernel matrix k is used , instead of the augmented k 123 ( see , for example , shawe - taylor and cristianini , 123 ) .
matrix , k 123 = k + in = pm for m = 123 , we notice that ( 123 ) directly reduces to ( 123 ) if k123 123
this corresponds to automatically tuning the parameter = 123=c for a 123 - norm soft margin svm with kernel matrix k123
so , even when not learning the kernel matrix , this approach can be used to tune the 123 - norm soft margin parameter = 123=c automatically .
learning the kernel matrix with semidefinite programming
in this section , we consider the problem of optimizing the alignment between a set of labels and a kernel matrix from some class k of positive semidenite kernel matrices .
we show that , if k is a class of linear combinations of xed kernel matrices , this problem can be cast as an sdp .
this result generalizes the approach presented in cristianini et al .
( 123 , 123 ) .
theorem 123 the kernel matrix k 123 k which is maximally aligned with the set of labels y 123 rntr can be found by solving the following optimization problem :
( cid : 123 ) a k t k in 123 k 123 k;
where in is the identity matrix of dimension n .
proof we want to nd the kernel matrix k which is maximally aligned with the set of labels y :
^a ( s; ktr; yyt ) k 123 k; trace ( k ) = 123 :
this is equivalent to the following optimization problem :
hk; kif = 123 k 123 k; trace ( k ) = 123 :
to express this in the standard form ( 123 ) of a semidenite program , we need to express the quadratic equality constraint hk; kif = 123 as an lmi .
first , notice that ( 123 ) is equivalent to
hk; kif 123 k 123 k :
indeed , we are maximizing an objective which is linear in the entries of k , so at the optimum k = k , the constraint hk; kif = trace ( k t k ) 123 is achieved : hk ; kif = 123
the quadratic inequality constraint in ( 123 ) is now equivalent to
123a : k t k a and trace ( a ) 123 :
indeed , a k t k 123 implies trace ( a k t k ) = trace ( a ) trace ( k t k ) 123 because of linearity of the trace .
using the schur complement lemma , we can express a k t k 123 as an lmi :
a k t k 123 , ( cid : 123 ) a k t
k in 123 :
lanckriet , cristianini , bartlett , el ghaoui and jordan
we can thus rewrite the optimization problem ( 123 ) as
( cid : 123 ) a k t k in 123 k 123 k;
which corresponds to ( 123 ) .
notice that , when k is the set of all positive semidenite matrices , this is an sdp ( an inequality constraint corresponds to a one - dimensional lmi; consider the entries of the matrices a and k as the unknowns , corresponding to the ui in ( 123 ) ) .
in that case , one solution of ( 123 ) is found by simply selecting ktr = c
n yyt , for which the alignment ( 123 ) is equal to one and thus maximized .
adding the additional constraint ( 123 ) that k is a linear combination of xed kernel matrices
hk; kif 123;
which can be written in the standard form of a semidenite program , in a similar way as for ( 123 ) :
remark .
for the specic case where the ki are rank - one matrices ki = vivt i , with vi orthonormal ( e . g . , the normalized eigenvectors of an initial kernel matrix k123 ) , the semidenite program reduces to a qcqp ( see appendix a ) :
i 123; i = 123; : : : ; m
learning the kernel matrix with semidefinite programming
with vi = vi ( 123 : ntr ) .
this corresponds exactly to the qcqp obtained as an illustration in cristianini et al .
( 123 ) , which is thus entirely captured by the general sdp result obtained in this
solving the original learning problem ( 123 ) subject to the extra constraint 123 yields
hk; kif 123;
we can omit the second constraint , because this is implied by the last two constraints , if ki 123
this reduces to
where ki;tr = ki ( 123 : ntr; 123 : ntr ) .
expanding this further yields
= t q;
ij hki; kjif
with qi = ki;tr; yytf = trace ( ki;tryyt ) = trace ( yt ki;try ) = yt ki;try and sij = hki; kjif , where q 123 rm; s 123 rmm .
we used the fact that trace ( abc ) = trace ( bca ) ( if the products are well - dened ) .
we obtain the following learning problem :
t s 123;
which is a qcqp .
in previous sections we have considered the transduction setting , where it is assumed that the covariate vectors for both training ( labeled ) and test ( unlabeled ) data are known beforehand
lanckriet , cristianini , bartlett , el ghaoui and jordan
this setting captures many realistic learning problems , it is also of interest to consider possible extensions of our approach to the more general setting of induction , in which the covariates are known beforehand only for the training data .
consider the following situation .
we learn the kernel matrix as a positive linear combination of normalized kernel matrices ki .
those ki are obtained through the evaluation of a kernel function or through a known procedure ( e . g . , a string - matching kernel ) , yielding ki 123
so , k =pm 123
normalization is done by replacing ki ( k; l ) by ki ( k; l ) =pki ( k; k ) ki ( l; l ) .
in this case , the
extension to an induction setting is elegant and simple .
let ntr be the number of training data points ( all labeled ) .
consider the transduction problem for those ntr data points and one unknown test point , e . g . , for a hard margin svm .
the optimal
i = 123; : : : ; m are learned by solving ( 123 ) :
i = 123; : : : ; m
123t e ct t y = 123;
ntr + 123
even without knowing the test point and the entries of the kis related to it ( column and row ntr + 123 ) , we know that k ( ntr + 123; ntr + 123 ) = 123 because of the normalization .
so , trace ( ki ) = ntr + 123
this allows solving for the optimal weights i = 123; : : : ; m and the optimal svm parameters j = 123; : : : ; ntr and b , without knowing the test point .
when a test point becomes available ,
we complete the kis by computing their ( ntr + 123 ) - th column and row ( evaluate the kernel function or follow the procedure and normalize ) .
combining those ki with weights i yields the nal kernel matrix k , which can then be used to label the test point :
y = sign (
i jki ( xj; x ) ) :
remark : the optimal weights are independent of the number of unknown test points that are considered in this setting .
consider the transduction problem ( 123 ) for l unknown test points instead of one unknown test point :
~ t g ( ki;tr ) ~ ;
i = 123; : : : ; m
123 ~ t e c ~ t ntr + l ~ t y = 123;
ntr+123 and ~ t = ntr+l
i = 123; : : : ; m are the same .
one can see that solving ( 123 ) is equivalent to solving ( 123 ) where the optimal values relate as ~ = ntr+l
ntr+123 t and where the optimal weights
tackling the induction problem in full generality remains a challenge for future work .
obviously , one could consider the transduction case with zero test points , yielding the induction case .
if the weights i are constrained to be nonnegative and furthermore the matrices ki are guaranteed to be positive semidenite , the weights can be reused at new test points .
to deal with induction in a general sdp setting , one could solve a transduction problem for each new test point .
for every
learning the kernel matrix with semidefinite programming
test point , this leads to solving an sdp of dimension ntr + 123 , which is computationally expensive .
clearly there is a need to explore recursive solutions to the sdp problem that allow the solution of the sdp of dimension ntr to be used in the solution of an sdp of dimension ntr + 123
such solutions would of course also have immediate applications to on - line learning problems .
error bounds for transduction
in the problem of transduction , we have access to the unlabeled test data , as well as the labeled training data , and the aim is to optimize accuracy in predicting the test data .
we assume that the data are xed , and that the order is chosen randomly , yielding a random partition into a labeled training set and an unlabeled test set .
for convenience , we suppose here that the training and test sets have the same size .
of course , if we can show a performance guarantee that holds with high probability over uniformly chosen training / test partitions of this kind , it also holds with high probability over an i . i . d .
choice of the training and test data , since permuting an i . i . d .
sample leaves the distribution unchanged .
the following theorem gives an upper bound on the error of a kernel classier on the test data in terms of the average over the training data of a certain margin cost function , together with properties of the kernel matrix .
we focus on the 123 - norm soft margin classier , although our results extend in a straightforward way to other cases , including the 123 - norm soft margin classier .
the 123 - norm soft margin classier chooses a kernel classier f to minimize a weighted combination of a regularization term , kwk123 , and the average over the training sample of the slack variables ,
i = max ( 123 yif ( xi ) ; 123 ) :
we can view this regularized empirical criterion as the lagrangian for the constrained minimization
max ( 123 yif ( xi ) ; 123 )
subject to the upper bound kwk123 123= ( cid : 123 ) 123
fix a sequence of 123n pairs ( x123; y123 ) ; : : : ; ( x123n; y123n ) from xy .
let : f123; : : : ; 123ng ! f123; : : : ; 123ng be a random permutation , chosen uniformly , and let ( xi; yi ) = ( x ( i ) ; y ( i ) ) .
the rst half of this randomly ordered sequence is the training data tn = ( ( x123; y123 ) ; : : : ; ( xn; yn ) ) , and the second half is the test data sn = ( ( xn+123; yn+123 ) ; : : : ; ( x123n; y123n ) ) .
for a function f : x ! r , the proportion of errors on the test data of a thresholded version of f can be written as
er ( f ) =
njfn + 123 i 123n : yif ( xi ) 123gj :
we consider kernel classiers obtained by thresholding kernel expansions of the form
f ( x ) = hw; ' ( x ) i =
where w =p123n
i=123 i ' ( xi ) is chosen with bounded norm ,
ijk ( xi; xj ) = t k
and k is the 123n 123n kernel matrix with kij = k ( xi; xj ) .
lanckriet , cristianini , bartlett , el ghaoui and jordan
let fk denote the class of functions on s of the form ( 123 ) satisfying ( 123 ) , for some k 123 k ,
fk = ( xj 123 !
ikij : k 123 k; t k
where k is a set of positive semidenite 123n 123n matrices .
we also consider the class of kernel expansions obtained from certain linear combinations of a xed set fk123; : : : ; kmg of kernel matrices : dene the class fkc as
and the class fk+
jkj : k 123; j 123 r; trace ( k ) c123=
jkj : k 123; j 123; trace ( k ) c123=
theorem 123 for every ( cid : 123 ) > 123 , with probability at least 123 over the data ( xi; yi ) chosen as above , every function f 123 fk has er ( f ) no more than
maxf123 yif ( xi ) ; 123g +
pn123 +p123 log ( 123= ) +sc ( k ) n ( cid : 123 ) 123 ! ;
c ( k ) = e max
with the expectation over ( cid : 123 ) chosen uniformly from f123g123n .
c ( kc ) = ce max
and this is always no more than cn , and
c ) c min ( cid : 123 ) m; n max
where j is the largest eigenvalue of kj .
notice that the test error is bounded by a sum of the average over the training data of a margin cost function plus a complexity penalty term that depends on the ratio between the trace of the kernel matrix and the squared margin parameter , ( cid : 123 ) 123
the kernel matrix here is the full matrix , combining both test and training data .
the proof of the theorem is in appendix b .
the proof technique for the rst part of the theorem was introduced by koltchinskii and panchenko ( 123 ) , who used it to give error bounds for boosting algorithms .
although the theorem requires the margin parameter ( cid : 123 ) to be specied in advance , it is straight - forward to extend the result to give an error bound that holds with high probability over all values of ( cid : 123 ) .
in this case , the log ( 123= ) in the bound would be replaced by log ( 123= ) + j log ( 123= ( cid : 123 ) ) j and the
learning the kernel matrix with semidefinite programming
constants would increase slightly .
see , for example , proposition 123 and its applications in the work of bartlett ( 123 ) .
the result is presented for the 123 - norm soft margin classier , but the proof uses only two prop - erties of the cost function a 123 ! maxf123 a; 123g : that it is an upper bound on the indicator function for a 123 , and that it satises a lipschitz constraint on ( 123;123 ) .
these conditions are also satised by the cost function associated with the 123 - norm soft margin classier , a 123 ! ( maxf123 a; 123g ) 123 , for b is easier to check than the bound on c ( kb ) .
the rst term in the minimum shows that the set of positive linear combinations of a small set of kernel matrices is not very complex .
the second term shows that if , for each matrix in the set , the largest eigenvalue does not dominate the sum of the eigenvalues ( the trace ) , then the set of positive linear combinations is not too complex , even if the set is large .
in either case , the upper bound is linear in c , the upper bound on the trace of the combined kernel matrix .
the bound on the complexity c ( k+
b ) of the kernel class k+
empirical results
we rst present results on benchmark data sets , using kernels ki that are derived from the same input vector .
the goal here is to explore dierent possible representations of the same data source , and to choose a representation or combinations of representations that yield the best performance .
we compare to the soft margin svm with an rbf kernel , in which the hyperparameter is tuned via cross - validation .
note that in our framework there is no need for cross - validation to tune the corresponding kernel hyperparameters .
moreover , when using the 123 - norm soft margin svm , the methods are directly comparable , because the hyperparameter c is present in both cases .
in the second section we explore the use of our framework to combine kernels that are built using data from heterogeneous sources .
here our main interest is in comparing the combined classier to the best individual classier .
to the extent that the heterogeneous data sources provide complementary information , we might expect that the performance of the combined classier can dominate that of the best individual classier .
123 benchmark data sets
we present results for hard margin and soft margin support vector machines .
we use a kernel matrix k = p123 i=123 iki , where the kis are initial \guesses " of the kernel matrix .
we use a 123 x123 ) d for k123 , a gaussian kernel function k123 ( x123; x123 ) = polynomial kernel function k123 ( x123; x123 ) = ( 123+xt exp ( 123 : 123 ( x123 x123 ) t ( x123 x123 ) = ( cid : 123 ) ) for k123 and a linear kernel function k123 ( x123; x123 ) = xt 123 x123 for k123
afterwards , all ki are normalized .
after evaluating the initial kernel matrices fkig123 i=123 , the weights i=123 are optimized in a transduction setting according to a hard margin , a 123 - norm soft margin and a 123 - norm soft margin criterion , respectively; the semidenite programs ( 123 ) , ( 123 ) and ( 123 ) are solved using the general - purpose optimization software sedumi ( sturm , 123 ) , leading to optimal i=123
next , the weights fig123 i=123 are constrained to be non - negative and optimized according to the same criteria , again in a transduction setting : the second order cone programs ( 123 ) , ( 123 ) and ( 123 ) are solved using the general - purpose optimization software mosek ( andersen and andersen , 123 ) , leading to optimal weights f i=123
for positive weights , we also report results in which the 123 - norm soft margin hyperparameter c is tuned according to ( 123 ) .
empirical results on standard benchmark datasets are summarized in tables 123 , 123 and 123 the wisconsin breast cancer dataset contained 123 incomplete examples which were not used .
the breast
it is worth noting that the rst three columns of these columns are based on an inductive algorithm whereas the last two columns are based on a transductive algorithm .
this may favor the kernel combinations in the last
lanckriet , cristianini , bartlett , el ghaoui and jordan
cancer , ionosphere and sonar data were obtained from the uci repository .
the heart data were obtained from statlog and normalized .
data for the 123 - norm problem data were generated as specied by breiman ( 123 ) .
each dataset was randomly partitioned into 123% training and 123% test sets .
the reported results are the averages over 123 random partitions .
the kernel parameters for k123 and k123 are given in tables 123 , 123 and 123 by d and ( cid : 123 ) respectively .
for each of the kernel matrices , an svm is trained using the training block ktr and tested using the mixed block ktr;t as dened in ( 123 ) .
the margin ( cid : 123 ) ( for a hard margin criterion ) and the optimal soft margin cost s123 ( for soft margin criteria ) are reported for the initial kernel matrices ki , as i;+ki .
furthermore , the average test set accuracy ( tsa ) , the average value for c and the average weights over the 123 partitions are listed .
for comparison , the performance of the best soft margin svm with an rbf ( gaussian ) kernel is reported|the soft margin hyperparameter c and the kernel parameter ( cid : 123 ) for the gaussian kernel were tuned using cross - validation over 123 random partitions of the training set .
well as for the optimal pi
i ki andpi
s123 and !
note that not every ki gives rise to a linearly separable embedding of the training data , in which i ki and i;+ki however , always allow the training of a hard margin svm and its margin is indeed larger than the margin for each of the dierent components ki|this is consistent with the sdp / qcqp i ki and i;+ki is smaller than its value for the individual ki|again consistent with the sdp / qcqp optimizations .
notice that constraining the weights i to be positive results in slightly smaller margins and larger cost functions , as expected .
case no hard margin classier can be found ( indicated with a dash ) .
the matrices pi optimization .
for the soft margin criteria , the optimal value of the cost function for pi furthermore , the number of test set errors for pi i;+ki does often almost as well as pi moreover , the performance of pi
i;+ki is in general comparable in magnitude to the best value achieved among the dierent components ki .
also notice that i ki , and sometimes even better : we can thus achieve a substantial reduction in computational complexity without a signicant loss of performance .
i;+ki is comparable with the best soft margin svm with an rbf kernel .
in making this comparison note that the rbf svm requires tuning of the kernel parameter using cross - validation , while the kernel learning approach achieves a similar eect without cross - validation . 123 moreover , when using the 123 - norm soft margin svm with tuned hyperparameter c , we no longer need to do cross - validation for c .
this leads to a smaller value of the optimal cost function ! s123 ( compared to the case sm123 , with c = 123 ) and performs well on the test set , while oering the advantage of automatically adjusting c .
i ki and pi
i ki andpi
one might wonder why there is a dierence between the sdp and the qcqp approach for the 123 - norm data , since both seem to nd positive weights i .
however , it must be recalled that
two columns and thus the results should be interpreted with caution .
however , it is also worth noting that the transduction is a weak form of transduction that is based only on the norm of the test data point .
the experiments were run on a 123ghz windows xp machine .
we used the programs sedumi to solve the sdp for kernel learning and mosek to solve multiple qps for cross - validated svm and the qcqp for kernel learning with positive weights .
the run time for the sdp is on the order of minutes ( approximately 123 minutes for 123 data points and 123 kernels ) , while the run time for the qp and qcqp is on the order of seconds ( approximately 123 second for 123 data points and 123 kernel , and approximately 123 seconds for 123 data points and 123 kernels ) .
thus , we see that kernel learning with positive weights , which requires only a qcqp solution , achieves an accuracy which is comparable to the full sdp approach at a fraction of the computational cost , and our tentative recommendation is that the qcqp approach is to be preferred .
it is worth noting , however , that special - purpose implementations of sdps that take advantage of the structure of the kernel learning problem may well yield signicant speed - ups , and the recommendation should be taken with caution .
finally , the qcqp approach also compares favorably in terms of run time to the multiple runs of a qp that are required for cross - validation , and should be considered a viable alternative to cross - validation , particularly given the high variance associated with cross - validation in small data sets .
learning the kernel matrix with semidefinite programming
( cid : 123 ) = 123 : 123 123 % 123 %
123 % 123 % 123 %
123 % 123 % 123 %
123 % 123 % 123 %
( cid : 123 ) = 123 : 123
123 % 123 % 123 % 123 % 123 % 123 %
123 % 123 % 123 %
123 % 123 % 123 %
best c / v rbf
kernel matrices pi
table 123 : svms trained and tested with the initial kernel matrices k123; k123; k123 and with the optimal i;+ki .
for hard margin svms ( hm ) , the resulting margin ( cid : 123 ) is given|a dash meaning that no hard margin classier could be found; for soft margin svms ( sm123 = 123 - norm soft margin with c = 123 , sm123 = 123 - norm soft margin with c = 123 and sm123 , c = 123 - norm soft margin with auto tuning of c ) the optimal value of the cost function ! s123 is given .
furthermore , the test - set accuracy ( tsa ) , the average
i ki and pi
s123 or !
weights and the average c - values are given .
for c we used c = pi trace ( ki ) for hm ,
sm123 and sm123
the initial kernel matrices are evaluated after being multiplied by 123
this assures we can compare the dierent ( cid : 123 ) for hm , ! s123 for sm123 , since the resulting kernel matrix has a constant trace ( thus , everything is on the same scale )
s123 for sm123 and !
s123 for sm123 , c but also it allows comparing !
sm123 , c we use c =pi trace ( ki ) + trace ( in ) .
this not only allows comparing the dierent c = 123 for sm123 , we have that tracepm c in is constant in both cases , so again ,
we are on the same scale ) .
finally , the column best c / v rbf reports the performance of the best soft margin svm with rbf kernel , tuned using cross - validation .
s123 between sm123 and sm123 , c ( since we choose
i=123 iki + 123
the values in table 123 are averages over 123 randomizations|for some randomizations the sdp has actually found negative weights , although the averages are positive .
as a further example illustrating the ( cid : 123 ) exibility of the sdp framework , consider the following setup .
let fkig123 i=123 be gaussian kernels with ( cid : 123 ) = 123 : 123; 123 : 123; 123; 123; 123 respectively .
combining those optimally with i 123 for a 123 - norm soft margin svm , with tuning of c , yields the results
lanckriet , cristianini , bartlett , el ghaoui and jordan
( cid : 123 ) = 123 : 123 123 % 123 %
123 % 123 % 123 %
123 % 123 % 123 %
123 % 123 % 123 %
( cid : 123 ) = 123 : 123 123 % 123 %
123 % 123 % 123 %
123 % 123 % 123 %
123 % 123 % 123 %
table 123 : see the caption to table 123 for explanation .
( cid : 123 ) = 123 : 123
123 % 123 % 123 % 123 % 123 % 123 %
123 % 123 % 123 %
123 % 123 % 123 %
best c / v rbf
best c / v rbf
table 123 : see the caption to table 123 for explanation .
accuracies obtained forpi
in table 123|averages over 123 randomizations in 123% training and 123% test sets .
the test set i;+ki are competitive with those for the best soft margin svm with an rbf kernel , tuned using cross - validation .
the average weights show that some kernels are selected and others are not .
eectively we obtain a data - based choice of smoothing parameter without recourse to cross - validation .
learning the kernel matrix with semidefinite programming
123;+ 123;+ 123;+ 123;+ 123;+
tsa sm123 , c tsa best c / v rbf
table 123 : the initial kernel matrices fkig123 respectively .
for c we used c =pi trace ( ki ) +trace ( in ) .
fi;+g123 of the optimal kernel matrix pi
i=123 are gaussian kernels with ( cid : 123 ) = 123 : 123; 123 : 123; 123; 123; 123 i=123 are the average weights i;+ki for a 123 - norm soft margin svm with i 123 and tuning of c .
the average c - value is given as well .
the test set accuracies ( tsa ) of the optimal 123 - norm soft margin svm with tuning of c ( sm123 , c ) and the best crossvalidation soft margin svm with rbf kernel ( best c / v rbf ) are reported .
kernel matrix k =pn
in cristianini et al .
( 123 ) empirical results are given for optimization of the alignment using a i .
the results show that optimizing the alignment indeed improves the generalization power of parzen window classiers .
as explained in section 123 , it turns out that in this particular case , the sdp in ( 123 ) reduces to exactly the quadratic program that is obtained in cristianini et al .
( 123 ) and thus those results also provide support for the general framework presented in the current paper .
123 combining heterogeneous data
123 . 123 reuters - 123 data set
to explore the value of this approach for combining data from heterogeneous sources , we run experiments on the reuters - 123 data set , using two dierent kernels .
the rst kernel k123 is derived as a linear kernel from the \bag - of - words " representation of the dierent documents , capturing information about the frequency of terms in the dierent documents ( salton and mcgill , 123 ) .
k123 is centered and normalized .
the second kernel k123 is constructed by extracting 123 concepts from documents via probabilistic latent semantic analysis ( cai and hofmann , 123 ) .
this kernel can be viewed as arising from a document - concept - term graphical model , with the concepts as hidden nodes .
after inferring the conditional probabilities of the concepts , given a document , a linear kernel is applied to the vector of these probabilistic \concept memberships , " representing each document .
also k123 is then centered and normalized .
the concept - based document information contained in k123 is likely to be partly overlapping and partly complementary to the term - frequency information in k123
although the \bag - of - words " and graphical model representation are clearly heterogeneous , they can both be cast into a homogeneous framework of kernel matrices , allowing the information that they convey to be combined according to k = 123k123 + 123k123
the reuters - 123 dataset consists of reuters newswire stories from 123 ( www . davidlewis .
com / resources / testcollections / reuters123 / ) .
after a preprocessing stage that includes tokenization and stop word removal , 123 word types remained .
we used the modied apte ( \modapte " ) split to split the collection into 123 used and 123 unused documents .
the 123 used documents consist of 123 training documents and 123 test documents .
from the 123 training documents , we randomly select a 123 - document subset as training set for a soft margin support vector machine with c = 123
we train the svm for the binary classication tasks of
lanckriet , cristianini , bartlett , el ghaoui and jordan
distinguishing documents about a certain topic versus those not about that topic .
we restrict our attention to the topics that appear in the most documents ( cf .
cai and hofmann ( 123 ) ; huang ( 123 ) ; eyheramendy et al .
( 123 ) ) ; in particular , we focused on the top ve reuters - 123 topics .
after training the svm on the randomly selected documents using either k123 or k123 , the accuracy is tested on the 123 test documents from the modapte split .
this is done 123 times , i . e . , for 123 randomly chosen 123 - document training sets .
the average accuracies and standard errors are reported in figure 123
after evaluating the performance of k123 and k123 , the weights 123 and 123 are constrained to be non - zero and optimized ( using only the training data ) according to ( 123 ) .
the test set performance of the optimal combination is then evaluated and the average accuracy reported in figure 123
the optimal weights , 123 , do not vary greatly over the dierent topics , with averages of 123 for 123 and 123 for
we see that in four cases out of ve the optimal combination of kernels performs better than either of the individual kernels .
this suggests that these kernels indeed provide complementary information for the classication decision , and that the sdp approach is able to nd a combination that exploits this complementarity .
123 . 123 protein function prediction
here we illustrate the sdp approach for fusing heterogeneous genomic data in order to predict protein function in yeast; see lanckriet et al .
( 123 ) for more details .
the task is to predict functional classications associated with yeast proteins .
we use as a gold standard the functional catalogue provided by the mips comprehensive yeast genome database ( cygd|mips . gsf . de / proj / yeast ) .
the top - level categories in the functional hierarchy produce 123 classes , which contain 123 proteins; the remaining yeast proteins have uncertain function and are therefore not used in evaluating the classier .
because a given protein can belong to several functional classes , we cast the prediction problem as 123 binary classication tasks , one for each functional class .
using this setup , we follow the experimental paradigm of deng et al .
( 123 ) .
the primary input to the classication algorithm is a collection of kernel matrices representing
dierent types of data :
amino acid sequences : this kernel incorporates information about the domain structure of each protein , by looking at the presence or absence in the protein of pfam domains ( pfam .
wustl . edu ) .
the corresponding kernel is simply the inner product between binary vectors describing the presence or absence of one pfam domain .
afterwards , we also construct a richer kernel by replacing the binary scoring with log e - values using the hmmer software toolkit ( hmmer . wustl . edu ) .
moreover , an additional kernel matrix is constructed by applying the smith - waterman ( sw ) pairwise sequence comparison algorithm ( smith and waterman , 123 ) to the yeast protein sequences and applying the empirical kernel map ( tsuda , 123 ) .
protein - protein interactions : this type of data can be represented as a graph , with proteins as nodes and interactions as edges .
such interaction graph allows to establish similarities among proteins through the construction of a corresponding diusion kernel ( kondor and laerty ,
genetic interactions : in a similar way , these interactions give rise to a diusion kernel .
protein complex data : co - participation in a protein complex can be seen as a weak sort of
interaction , giving rise to a third diusion kernel .
learning the kernel matrix with semidefinite programming
figure 123 : classication performance for the top ve reuters - 123 topics .
the height of each bar is proportional to the average test set accuracy for a 123 - norm soft margin svm with c = 123
black bars correspond to using only kernel matrix k123; grey bars correspond to using only kernel matrix k123 , and white bars correspond to the optimal combination
the kernel matrices k123 and k123 are derived from dierent types of data , i . e . , from the \bag - of - words " representation of documents and the concept - based graphical model representation ( with 123 concepts ) of documents respectively .
for c we used c = trace ( k123 ) + trace ( k123 ) = 123
the standard errors across the 123 experiments are approximately 123 or smaller; indeed , all of the depicted dierences between the optimal combination and the individual kernels are statistically signicant except for earn .
lanckriet , cristianini , bartlett , el ghaoui and jordan
expression data : two genes with similar expression proles are likely to have similar functions; accordingly , deng et al .
( 123 ) convert the expression matrix to a square binary interaction matrix in which a 123 indicates that the corresponding pair of expression proles exhibits a pearson correlation greater than 123 .
this can be used to dene a diusion kernel .
also , a richer gaussian kernel is dened directly on the expression proles .
in order to compare the sdp / svm approach to the markov random eld ( mrf ) method of deng et al .
( 123 ) , lanckriet et al .
( 123 ) perform two variants of the experiment : one in which the ve kernels are restricted to contain precisely the same binary information as used by the mrf method , and a second experiment in which the richer pfam and expression kernels are used and the sw kernel is added .
they show that a combined svm classier trained with the sdp approach performs better than an svm trained on any single type of data .
moreover it outperforms the mrf method designed for this data set .
to illustrate the latter , figure 123 presents the average roc scores on the test set when performing ve - fold cross - validation three times .
the gure shows that , for each of the 123 classications , the roc score of the sdp / svm method is better than that of the mrf method .
overall , the mean roc improves from 123 to 123 .
the improvement of the sdp / svm method over the mrf method is consistent and statistically signicant across all 123 classes .
an additional improvement , though not as large and only statistically signicant for nine of the 123 classes , is gained by using richer kernels and adding the sw kernel .
in this paper we have presented a new method for learning a kernel matrix from data .
our approach makes use of semidenite programming ( sdp ) ideas .
it is motivated by the fact that every symmetric , positive semidenite matrix can be viewed as a kernel matrix ( corresponding to a certain embedding of a nite set of data ) , and the fact that sdp deals with the optimization of convex cost functions over the convex cone of positive semidenite matrices ( or convex subsets of this cone ) .
thus convex optimization and machine learning concerns merge to provide a powerful methodology for learning the kernel matrix with sdp .
we have focused on the transductive setting , where the labeled data are used to learn an embedding , which is then applied to the unlabeled part of the data .
based on a new generalization bound for transduction , we have shown how to impose convex constraints that eectively control the capacity of the search space of possible kernels and yield an ecient learning procedure that can be implemented by sdp .
furthermore , this approach leads to a convex method to learn the 123 - norm soft margin parameter in support vector machines , solving an important open problem .
promising empirical results are reported on standard benchmark datasets; these results show that the new approach provides a principled way to combine multiple kernels to yield a classier that is comparable with the best individual classier , and can perform better than any individual kernel .
performance is also comparable with a classier in which the kernel hyperparameter is tuned with cross - validation; our approach achieves the eect of this tuning without cross - validation .
we have also shown how optimizing a linear combination of kernel matrices provides a novel method for fusing heterogeneous data sources .
in this case , the empirical results show a signi - cant improvement of the classication performance for the optimal combination of kernels when compared to individual kernels .
there are several challenges that need to be met in future research on sdp - based learning algo - rithms .
first , it is clearly of interest to explore other convex quality measures for a kernel matrix , which may be appropriate for other learning algorithms .
for example , in the setting of gaussian
learning the kernel matrix with semidefinite programming
figure 123 : classication performance for the 123 functional protein classes .
the height of each bar is proportional to the roc score .
the standard error across the 123 experiments is usually 123 or smaller , so most of the depicted dierences are statistically signi - cant : between black and grey bars , all depicted dierences are statistically signicant , while nine of the 123 dierences between grey and white bars are statistically signicant .
black bars correspond to the mrf method of deng et al . ; grey bars correspond to the sdp / svm method using ve kernels computed on binary data , and white bars corre - spond to the sdp / svm using the enriched pfam kernel and replacing the expression kernel with the sw kernel .
see lanckriet et al .
( 123 ) for more details .
lanckriet , cristianini , bartlett , el ghaoui and jordan
processes , the relative entropy between the zero - mean gaussian process prior p with covariance kernel k and the corresponding gaussian process approximation q to the true intractable posterior process depends on k as
log det k +
traceyt ky + d;
where the constant d is independent of k .
one can verify that d ( pjjq ) is convex with respect to r = k 123 ( see , e . g . , vandenberghe et al . , 123 ) .
minimizing this measure with respect to r , and thus k , is motivated from pac - bayesian generalization error bounds for gaussian processes ( see , e . g . , seeger , 123 ) and can be achieved by solving a so - called maximum - determinant problem ( van - denberghe et al . , 123 ) |an even more general framework that contains semidenite programming as a special case .
second , the investigation of other parameterizations of the kernel matrix is an important topic for further study .
while the linear combination of kernels that we have studied here is likely to be useful in many practical problems|capturing a notion of combining gram matrix \experts " |it is also worth considering other parameterizations as well .
any such parameterizations have to respect the constraint that the quality measure for the kernel matrix is convex with respect to the parameters of the proposed parameterization .
one class of examples arises via the positive denite matrix completion problem ( vandenberghe et al . , 123 ) .
here we are given a symmetric kernel matrix k that has some entries which are xed .
the remaining entries|the parameters in this case|are to be chosen such that the resulting matrix is positive denite , while simultaneously a certain cost function is optimized , e . g . , trace ( sk ) + log det k 123 , where s is a given matrix .
this specic case reduces to solving a maximum - determinant problem which is convex in the unknown entries of k , the parameters of the proposed parameterization .
a third important area for future research consists in nding faster implementations of semidef - inite programming .
as in the case of quadratic programming ( platt , 123 ) , it seems likely that special purpose methods can be developed to exploit the exchangeable nature of the learning prob - lem in classication and result in more ecient algorithms .
finally , by providing a general approach for combining heterogeneous data sources in the setting of kernel - based statistical learning algorithms , this line of research suggests an important role for kernel matrices as general building blocks of statistical models .
much as in the case of nite - dimensional sucient statistics , kernel matrices generally involve a signicant reduction of the data and represent the only aspects of the data that are used by subsequent algorithms .
moreover , given the panoply of methods that are available to accommodate not only the vectorial and matrix data that are familiar in classical statistical analysis , but also more exotic data types such as strings , trees and graphs , kernel matrices have an appealing universality .
it is natural to envision libraries of kernel matrices in elds such as bioinformatics , computational vision , and information retrieval , in which multiple data sources abound .
such libraries would summarize the statistically - relevant features of primary data , and encapsulate domain specic knowledge .
tools such as the semidenite programming methods that we have presented here can be used to bring these multiple data sources together in novel ways to make predictions and decisions .
we acknowledge support from onr muri n123 - 123 - 123 - 123 and nsf grant iis - 123
sincere thanks to tijl de bie for helpful conversations and suggestions , as well as to lijuan cai and thomas hofmann for providing the data for the reuters - 123 experiments .
learning the kernel matrix with semidefinite programming
appendix a .
proof of result ( 123 )
for the case ki = vivt
i , with vi orthonormal , the original learning problem ( 123 ) becomes
expanding this further gives
hk; kif 123;
ktr; yytf = trace ( k ( 123 : ntr; 123 : ntr ) yyt )
ivi ( 123 : ntr ) vi ( 123 : ntr ) t ) yyt )
i yyt )
hk; kif = trace ( k t k )
with vi = vi ( 123 : ntr ) .
we used the fact that trace ( abc ) = trace ( bca ) ( if the products are well - dened ) and that the vectors vi; i = 123; : : : ; n are orthonormal : vt i vj = ij .
furthermore , because
i are the eigenvalues of k .
this implies
the vi are orthogonal , the i in k =pm
k 123 , 123 , i 123;
i = 123; : : : ; m :
lanckriet , cristianini , bartlett , el ghaoui and jordan
using ( 123 ) , ( 123 ) and ( 123 ) in ( 123 ) , we obtain the following optimization problem :
i = 123; : : : ; m;
which yields the result ( 123 ) .
appendix b .
proof of theorem 123 for a function g : x y ! r , dene
^e123g ( x; y ) =
^e123g ( x; y ) =
dene a margin cost function ` : r ! r+ as
123 a 123 < a 123;
if a 123 , a > 123 :
notice that in the 123 - norm soft margin cost function , the slack variable i is a convex upper bound on ` ( yif ( xi ) ) for the kernel classier f , that is ,
maxf123 a; 123g ` ( a ) 123 ( a 123 ) ;
where the last expression is the indicator function of a 123
( 123 ) , and involves the following ve steps :
the proof of the rst part is due to koltchinskii and panchenko koltchinskii and panchenko
step 123
for any class f of real functions dened on x ,
er ( f ) ^e123` ( y f ( x ) ) sup
^e123` ( y f ( x ) ) ^e123` ( y f ( x ) ) :
to see this , notice that er ( f ) is the average over the test set of the indicator function of y f ( x ) 123 , and that ` ( y f ( x ) ) bounds this function .
step 123
for any class g of ( 123; 123 ) - valued functions ,
^e123g ^e123g esup
^e123g ^e123g ! + ! exp ( cid : 123 ) 123n
where the expectation is over the random permutation .
this follows from mcdiarmids inequality .
to see this , we need to dene the random permutation using a set of 123n independent random variables .
to this end , choose 123; : : : ; 123n uniformly at random from the interval ( 123; 123 )
learning the kernel matrix with semidefinite programming
are almost surely distinct .
for j = 123; : : : ; 123n , dene ( j ) = jfi : i jgj , that is , ( j ) is the position of j when the random variables are ordered by size .
it is easy to see that , for any g , ^e123g ^e123g changes by no more than 123=n when one of the i changes .
mcdiarmids bounded dierence inequality ( mcdiarmid , 123 ) implies the result .
step 123
for any class g of ( 123; 123 ) - valued functions ,
^e123g ^e123g ! ^r123n ( g ) +
where ^r123n ( g ) = e supg123g i=123 ( cid : 123 ) ig ( xi; yi ) ; and the expectation is over the independent , uniform , f123g - valued random variables ( cid : 123 ) 123; : : : ; ( cid : 123 ) 123n .
this result is essentially lemma 123 of ( bartlett and mendelson , 123 ) ; that lemma contained a similar bound for i . i . d .
data , but the same argument holds for xed data , randomly permuted .
step 123
if the class f of real - valued functions dened on x is closed under negations , ^r123n ( ` f ) ^r123n ( f ) ; where each f 123 f denes a g 123 ` f by g ( x; y ) = ` ( yf ( x ) ) .
this bound is the contraction lemma of ledoux and talagrand ( 123 ) .
step 123
for the class fk of kernel expansions , notice ( as in the proof of lemma 123 of bartlett
and mendelson ( 123 ) ) that
where ( cid : 123 ) = ( ( cid : 123 ) 123; : : : ; ( cid : 123 ) 123n ) is the vector of rademacher random variables .
combining gives the rst part of the theorem .
for the second part , consider
c ( kc ) = e max
( cid : 123 ) t k ( cid : 123 ) = e max
where the max is over = ( 123; : : : ; m ) for which the matrix k = pm tions k 123 and trace ( k ) c
j=123 jkj satises the condi -
and each trace in the sum is positive , so the supremum must be achieved for trace ( k ) = c
c ( kc ) = ce max
lanckriet , cristianini , bartlett , el ghaoui and jordan
notice that ( cid : 123 ) t k ( cid : 123 ) is no more than k ( cid : 123 ) k123 = n , where is the maximum eigenvalue of k .
using trace ( k ) = c shows that c ( kc ) cn .
finally , for k+
c we have
c ) = e max
= e max
= e max
since each term in the maximum is non - negative , we can replace it with a sum to show that
c ) ce ( cid : 123 ) t 123
alternatively , we can write ( cid : 123 ) t kj ( cid : 123 ) jk ( cid : 123 ) k = jn , where j is the maximum eigenvalue of kj .
this shows that
c ) cn max
