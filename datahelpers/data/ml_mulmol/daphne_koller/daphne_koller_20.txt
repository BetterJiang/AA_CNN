two of the most important threads of work in knowledge representation today are frame - based representation systems ( frss ) and bayesian networks ( bns ) .
frss provide an ex - cellent representation for the organizational structure of large complex domains , but their applicability is limited because of their inability to deal with uncertainty and noise .
bns pro - vide an intuitive and coherent probabilistic representation of our uncertainty , but are very limited in their ability to handle complex structured domains .
in this paper , we provide a lan - guage that cleanly integrates these approaches , preserving the advantages of both .
our approach allows us to provide natural and compact denitions of probability models for a class , in a way that is local to the class frame .
these models can be instantiated for any set of interconnected instances , resulting in a coherent probability distribution over the instance proper - ties .
our language also allows us to represent important types of uncertainty that cannot be accomodated within the frame - work of traditional bns : uncertainty over the set of entities present in our model , and uncertainty about the relationships between these entities .
we provide an inference algorithm for our language via a reduction to inference in standard bayesian networks .
we describe an implemented system that allows most of the main frame systems in existence today to annotate their knowledge bases with probabilistic information , and to use that information in answering probabilistic queries .
frame representation systems ( frss ) are currently the pri - mary technology used for large scale knowledge representa - tion in ai ( 123 , 123 , 123 ) .
their modular organization according to cognitively meaningful entities and their ability to capture patterns common to many individuals provide a convenient language for representing complex structured domain mod - els .
one of the most signicant gaps in the expressive power of this type of framework is its inability to represent and reason with uncertain and noisy information .
uncertainty is unavoidable in the real world : our information is often inac - curate and always incomplete , and only a few of the rules that we use for reasoning are true in all possible cases .
in the propositional setting , this problem has largely been resolved over the past decade by the development of
copyright 123 , american association for articial intelli -
gence ( www . aaai . org ) .
all rights reserved .
probabilistic reasoning systems , and particularly bayesian networks ( 123 ) .
a bayesian network ( bn ) is a representation of a full joint distribution over a set of random variables; it can be used to answer queries about any of its variables given any evidence .
a bn allows a complex distribution to be represented compactly by using the locality of inuence in our model of the world .
but , like all propositional systems , the applicability of bns is largely limited to situations that can be encoded , in advance , using a xed set of attributes .
thus , they are inadequate for large - scale complex kr tasks .
building on our recent work ( 123 , 123 ) , we propose a represen - tation language that integrates frame - representation systems and bayesian networks , thereby providing the rst bridge between these two very different threads of work in kr .
the key component in our representation is the annotation of a frame with a probability model .
this probability model is , broadly speaking , a bn representing a distribution over the possible values of the slots in the frame .
that is , each sim - ple slot in the frame is annotated with a local probability model , representing the dependence of its value on the val - ues of related slots .
for example , in a frame representing a phd student , the value of the slot years - to - graduation may depend on the slot year and the slot chain advisor . picky .
as we can see even from this simple example , by build - ing on standard frs functionality , our approach provides signicantly more expressive power than traditional bns .
for example , by allowing the probability model of a slot to depend on a slot chain , we allow the properties of one in - stance in the model to depend on properties of other related instances .
we can also use the standard class hierarchy of the frs to allow the probability model of a class to be used by multiple instances of that class , and to allow inheritance of probability models from classes to subclasses , using the same mechanism in which slot values are currently inherited .
finally , by making domain individuals rst - class citizens in our framework we can also express a new and important type of uncertainty called structural uncertainty .
we can have a probabilistic model expressing our uncertainty about the set of entities in our model , e . g . , the number of phd students in a department .
we can also represent uncertainty about relations between entities , e . g . , which of several conferences a paper appeared in .
we provide a probabilistic inference algorithm for our language based on an approach known as knowledge - based
model construction .
the algorithm takes a knowledge base in our language , including a set of instances , and generates a standard bn which can then be queried effectively for our beliefs about the value of any slots .
our probability model is expressed using standard frame representation techniques such as facets and value restric - tions .
this property is important , since it allows our approach to be used with virtually any frame system , and thereby to annotate existing kbs with probabilistic information .
particular , we have implemented a system based on our ap - proach , capable of interacting with most existing frss via okbc ( 123 ) , an emerging standard for frs interoperability .
our work is a signcant improvement over previous ap - proaches to combining rst - order logic and bayesian net - works .
most of the attempts in this direction ( e . g . , ( 123 , 123 , 123 ) ) use probabilistic horn clauses as the basic representation .
the choice of horn clauses as an underlying language al - ready dictates some of the properties of the representation , e . g . , its inability to encapsulate an object and its properties within a cognitively meaningful frame .
moreover , the use of structural uncertainty in this framework typically causes combinatorial blowup of the resulting models , leading most approaches to outlaw it entirely .
our framework also over - comes some major limitations of our earlier proposals ( 123 , 123 ) , by allowing both structural uncertainty ( absent in the rst ) and probabilistic dependencies between instances ( absent in it also provides the crucial ability , absent in both , to create complex models containing many instances that are connected to each other in a variety of ways .
123 basic representation
we begin with some basic terminology for frame systems .
the terminology varies widely from system to system .
this paper we adopt the language and basic knowledge model of the okbc protocol ( 123 ) .
the basic unit of discourse in a frame system is a frame .
a frame has a set of slots , each of which may have slot values or llers .
formally , a slot represents a binary relation on frames; if the ller of slot a in frame x is frame y , then the relation ax; y holds .
in general slots may be single - valued or multi - valued .
in this section we assume that slots are single - valued .
this assumption will be relaxed in section 123
a slot - chain is a sequence of zero or more slots separated by periods .
a slot - chain represents a binary relation : the slot - chain a : where a is a slot and is a slot - chain denotes the relation fx; z j ax; y ^ y; zg .
a slot in a frame may have associated facets .
a facet is a ternary relation : if the facet value of facet f on slot a in frame x is y , then the relation f x; a; y holds .
a standard facet is value - type , which species a value restriction on the values of a slot .
the value - type of a slot will be called its type .
the two main types of frames are class frames , represent - ing sets of entities , and instance frames .
the class frames are organized in an is - a hierarchy , where one class may be a subclass of another ( its superclass ) .
the slots of a class frame may be own slots , which describe a property of the class itself , and template slots , which are slots inherited by all instances and subclasses of the class .
the facets asso - ciated with template slots are template facets , and are also
inherited .
an instance or subclass may override the values of inherited slots or facets .
probabilistic information is incorporated into a frame kb by annotating class frames with local probabilisticmodels .
a class frame that has been so annotated is called a p - class .
a p - class has a set of template slots , each with a value - type facet .
depending on the type , a slot is either simple or complex .
the type of a complex slot is another p - class .
the type of a simple slot is an explicitly enumerated list of possible values for the slot .
for example , the phd - student p - class may have a simple slot year , whose type is f123st , 123nd , 123rd , 123th123th , tenuredg , and a complex slot advisor whose type is the p - class professor .
a p - class may also have other slots that do not participate in the probability model , whose type is neither of the above .
for example , phd - student may also have the slot name , which does not have an associated probability model .
this feature allows existing kbs to be annotated with probabilistic information , without requiring a complete redesign of the ontology .
a simple slot is very much like a node in a bayes net .
it has a range of values , a set of parents , and a cpt .
a p - class species a probability model for its simple slots using two special - purpose facets : parents and distribution .
facets are a natural place to put a probability model , since such a model can be viewed as a generalization of a value restric - tion : not only does it specify a range of possible values , but also a distribution over that range .
the parents facet lists the slots on which the value of this slot depends .
each parent is specied by a slot - chain referring to some other simple slot .
more precisely , let x be a p - class and a a simple slot .
the parents facet of a is a list of slot chains 123; : : : ; n , such that x : i refers to a simple slot .
for example , in the phd - student p - class , year may have the parent ( age ) , while the parents of years - to - graduation may be year; advisor . picky .
the distribution facet species the conditional probability dis - tribution over values of the slot given values of its parents .
the conditional distribution is specied using a conditional probability table ( cpt ) as in bayesian networks .
for each combination of values of its parents , the cpt provides a probability distribution over values of the slot .
for the pur - poses of this paper , we assume that the cpts are represented as fully specied functions of parent values .
more compact representations such as noisy - or can easily be accomodated within our framework .
the probability model of a complex slot is simply de - scribed by its p - class y .
however , each complex slot a also has an additional facet called imports , whose value is a list of slots in y .
this list , called the import list of a , is the list of slots of y that are visible within x .
we require that if a : b : ( for a possibly empty slot chain ) is a slot chain appearing within x , then b must be in the import list of a .
once a probability model has been specied for a p - class , the p - class can be used just like any other class frame .
one can create instances of the class , which will inherit all of its template slots and facets .
in particular , the probability distribution over values of slots of the instance will be as de - scribed in the p - class .
similarly , the inheritance mechanism of a frame system can be used to make one p - class a subclass of another .
a subclass can extend the denition of the super - class as well as overwrite parts of it .
in particular , a subclass
can redene the probability model of one or more of the slots .
for example , we can dene associate - professorto be a subclass of professor , and overwrite the distribution over salary to one that is appropriate to the more specic class .
another im - portant aspect of subtyping is that an instance of a subclass is also an instance of the superclass , so that it can ll a slot whose type is the superclass .
for example , in a particular instance of phd - student , the value of the advisor slot may be specied to be an instance whose class is associate - professor .
values can be assigned to an own slot of an instance frame either directly or by assignment to a template slot at the class level .
both types of assignments are interpreted in the same way .
an assignment to a simple slot is interpreted as observing the value of the slot , thereby conditioning the probability distribution for the instance .
this conditioning process may result in a change in our beliefs for other related slots .
consider , for example , a subclass graduating - phd - student of phd - student which assigns 123 to the slot years - to - graduation .
then the conditioning process will result in a new probability model for any instance i of this subclass; in particular , our beliefs about i : year and i : advisor . picky will both change , as will our beliefs about other related slots .
an assignment to a complex slot species that the value of that slot is another particular instance .
thus , complex net - works of inter - related frames can be created , such as students who share an advisor , and students of different advisors in the same department .
such an assignment at the class level results in all of the class instances having the same frame as their value for that slot .
one of the features of a probabilistic frame system is that related frames can inuence each other .
we have already seen one mechanism for such interactions : since a parent of a slot is a slot - chain , the value of a simple slot may be inuenced probabilistically by the value of a slot in another frame .
this mechanism , however , only allows a frame to be inuenced by related frames , but not to inuence them in turn .
we resolve this difculty by utilizing a basic feature of most frssinverse slots .
let x and y be two class frames , a a slot of x with type y , and b a slot of y with type x .
then a and b are inverse slots if , for every instance i of x , if i : a = j then j : b = i , and vice versa .
thus , we view an assignment of a specic instance frame j to a slot i : a as encompassing the corresponding assignment of i to j : b .
for that reason , we do not allow assignments of values to slots such as a at the class level; otherwise , for any given frame j of class y , the value of j : b would be the set consisting of every frame of class x , a model which is too unwieldy to deal with .
inverse slots allow either of the frames to refer to slots in the other , thereby allowing probabilistic dependencies in both directions .
allowing such intertwined dependencies without restriction could lead to horribly complex interactions be - tween two frames .
in particular , it could lead to a cyclic chain of inuences that has no coherent probability model .
therefore , one of the two inverse slotssay x : ais desig - nated to be the primary direction while the othery : bis secondary .
similarly , x is called the primary frame , while y is the secondary frame .
a primary inverse slot such as a in x has a parents facet just like a simple slot , i . e . , it is a list
of slot - chains in x .
intuitively , the parents of a are the only slots of x that are exported to y via b .
more precisely , the parent list of a in x must be identical to the import list of b in y .
thus , the ow of inuence between the two frames is neatly regulated : the parents of a in x can inuence any of the slots in y ; some of those can , in turn , inuence other slots in x that are downstream from a .
for example , suppose we decide that the thesis slot of phd - student should be an inverse slot , with its inverse being the author slot of phd - thesis .
the slot thesis is designated to be primary , and is given the parent eld in phd - student .
then eld is visible within the phd - thesis class , so that for example , jargon - content may depend on author . eld .
other slots of phd - student may depend on slots of thesis; thus , for example , job - prospects may depend on thesis . quality , which would therefore have to be on the import list of thesis .
inverse slots serve a dual purpose in our language .
as we said , they allow bidirectional dependencies between two instances .
but they also allow our probabilistic models to be multicentered .
if , as above , x : a and y : b are inverses , and we dene an instance from class x , it immediately implies the existence of a corresponding instance from class y .
al - ternatively , we could start modeling with an object of class y , and guarantee that the corresponding x will exist .
thus , we can dene a model centered around whatever entities are of interest to us in our context .
in this section we present a semantics for probabilistic frame knowledge bases .
for a given kb with a set of class and instance frames , our semantics denes a probability distribu - tion over the slot values of the instance frames ( and of some other related instance frames ) .
in order to dene a coherent probability distribution , our frame kb must satisfy several conditions .
the basic theme of the conditions is familiar from the realm of bayesian networks : our dependency model must be acyclic .
however , since there may be complicated chains of dependencies both within a frame and between frames , and on both the class and instance levels , we need to develop some tools to reason about dependencies .
denition 123 : a dependency is a pair x : a y : b , where x and y are frames ( not necessarily distinct ) , a is a slot of x and b is a slot of y .
we say that x : a y : b holds if a is a simple slot of x , y = x and b : is a parent of a; a is a complex slot of x , b is in the import list of a , and y is either an instance frame assigned to x : a or the p - class frame which is the value type of x : a .
intuitively , a dependency x : a y : b asserts that for every instance frame i consistent with x there exists an instance frame j consistent with y such that i : a depends ( if x is itself an instance frame i , then only i is consistent with x; if x is a class , then any instance of that class is consistent with x . ) note however , that our denition of dependencies only considers the rst slot in a chain on which a slot depends; thus , it makes only a rst - level partition of dependency .
it is a conservative overestimate of the true dependency model , since if x : a y : b , it is not necessarily the case that x : a depends on every slot - chain
while it is fairly straightforward to rene our notion of dependency , we have found our denition to be adequate for most purposes .
denition 123 : a dependency chain is a list x123 : a123 x123 : a123 such that , for each i , xi : ai xi+123 : ai+123
a dependency cycle is a dependency chain that begins and ends with the same slot .
dependency cycles reect potential problems with our ( although , as indicated by our discussion above , some correct models may appear to be problematic sim - ply because of our overestimate for probabilistic dependen - cies . ) a dependency cycle containing i : a , where i is an instance frame , corresponds to a possible chain of depen - dencies through which i : a depends on itself .
such a cyclic dependency , if it exists , prevents us from dening a coherent probability model .
a dependency cycle containing x : a for some class x means that for every instance i123 of x there is some instance i123 of x such that i123 : a depends on i123 : a .
in some cases , i123 and i123 are necessarily the same instance; such cases are called truly cyclic .
in others , however , they are distinct instances of the class x .
these cases can also be problematic , as they may represent an innite dependency chain beginning with i123 : a : i123 : a depends on i123 : a which de - pends on some i123 : a , etc .
such models also do not typically have well - dened probabilistic semantics .
we conclude from this discussion that we want to disallow all dependency cycles . 123 some types of dependency cycles are easy to prevent using purely local considerations .
specif - ically , we can build , for each class x , a dependency graph for x .
this graph contains all the slots of x , with an edge from b to a if the dependency x : a x : b holds .
clearly , if we want to avoid dependency cycles , this graph should be acyclic .
indeed , our care in designing the dependency model for inverse slots implies that if we make all class dependency graphs acyclic , we avoid any truly cyclic dependency chains at the class level .
formally , if we dene a class - level depen - dency chain to be one in which all the xis are p - classes , we obtain the following theorem : theorem 123 : if we have a knowledge base in which all class dependency graphs are acyclic , then there are no truly cyclic class - level dependency chains .
however , as we discussed , even dependency chains that are not truly cyclic can result in incoherent models .
in addition , we have not eliminated instance - level dependency chains that are truly cyclic .
unfortunately , the general problem is not so easy to prevent using purely local constraints .
however , we can detect whether or not the kb contains a dependency cycle by building a more global directed graph g , called the dependency graph of the kb .
the nodes of g are all x : a where x is a p - class or named individualframe and a is a slot of x .
there is an edge from y : b to x : a if the dependency x : a y : b holds .
clearly , the kb contains a dependency cycle iff g is cyclic .
for a kb that contains no dependency cycles , our goal now is to dene a probability distribution over instantiations
123note that we are not disallowing innite reference chains ( chains of related instances ) , unless they imply innite dependency
to frames , i . e . , assignments of values to the slots of the frames .
several issues combine to make such a denition difcult .
the most obvious idea is to follow the approach taken in the semantics of bayesian networks : we determine a set of random variables , and dene a distribution over their joint value space .
unfortunately , our framework is too rich to make this approach appropriate .
as we mentioned , the set of instance frames that we can potentially refer to may be innite .
while one might be able to circumvent this partic - ular problem , a more serious one manifests when we enrich our language with structural uncertainty in sections 123 and 123
then , the set of instance frames can also vary probabilisti - cally , in a way that both depends on and inuences the values of other random variables in the model .
we therefore dene our semantics via a data generating process , that randomly samples values for the various frames in the model .
the random sampling process implicitly de - nes a distribution over the different possible value assign - ments : the probability of a value assignment is the probability with which it is generated by the process .
note that , although a random sampling process can also be used as a stochastic algorithm for approximate inference , we are not proposing this approach; our sampling process is purely a thought ex - periment for dening the distribution .
in section 123 , we show how a more standard process of exact inference can be used to effectively answer queries relative to this distribution .
the sampling process builds value assignments to slots of frames incrementally , as the different components are re - quired .
by allowing such partial assignments , we bypass the problem of going off on innite sampling chains .
the assumption of nite dependency chains guarantees that the sampling chains required to sample the value of any simple slot will always terminate .
denition 123 : a partial value for an instance frame is an assignment of values ( of the appropriate type ) to some subset of its simple slots , an assignment of instance frames ( from the appropriate p - class ) to some subset of its complex slots , and a partial value for each of these assigned instances .
one nal subtlety arises in the sampling construction .
some instance frames may have specic values pre - assigned to some of the their slots .
such an assignment can be done via an explicit statement for a named instance frame , or via a process of inheritance from a template slot of a class to which the instance belongs .
as we explained in section 123 , the se - mantics of such assignments is to condition the distribution .
to obtain the right semantics , we make the obvious modi - cation to our data generating process .
if , during the sampling process , a value is generated for a slot which is inconsistent with the observed value , we simply discard the entire partial value generated up to that point .
it is easy to see ( 123 ) that the relative probability with which a partial value is gener - ated in this data generating process is exactly the same as its probability conditioned on the observed slot values .
as we discussed , our sampling procedure builds up a par - tial value piece by piece , as the pieces are needed .
our main procedure , shown in figure 123 , is sample ( i , a ) , which samples the value of a single simple slot a of a single instance frame i .
in order to sample a from the correct distribution , it must backward chain and sample other slots on which the
if a has a value in then return foreach parent of a if is a slot b in i then else / * is of the form : c * / let j : = complexvalue ( i , )
choose a value v for a according to p a j paa extend with i : a = v if a has a pre - assigned value v then if v = v then fail
if is empty then / * is of the form b : * / if i : b is assigned a value j in then let k : = j else if i : b is pre - assigned a value j then extend with i : b = j let k : = j let y be value - type ( b ) create a new instance k of p - class y extend with i : b = k if b has an inverse b in k then extend with k : b = i return complexvalue ( k , )
figure 123 : data generating sampling model
if the dependency graph is acyclic ,
value of a depends .
complexvalue ( i , ) determines the value of the complex slot - chain i : , if necessary creating new instance frames to represent the values of complex slots .
when the procedure returns , the partial value ( a global variable in the procedure ) contains a value for i : a .
lemma 123 : sample ( i , a ) , executed from a partial value denes a probability distribution over extensions of with a value as - signed to i : a .
furthermore , the distributiondoes not depend on the order in which the parents of a are examined .
proof : the basic steps in the proof are as follows .
to prove the rst part of the theorem , it sufces to show that the sam - pling algorithm terminates .
this proof proceeds using a sim - ple inductive argument over the length of dependency chains .
to prove that the distribution is independent of the order , we observe that a simple slot is always generated from the same conditional distribution , regardless of when it is sampled , and that the failure conditions are also applied universally .
we can now dene a samplekb procedure that uses sample ( i , a ) to sample values for the slots of all named instances in the kb .
if any call to sample fails , the entire sampling process needs to be restarted .
once a value has been assigned to all simple slots of named instances , we have accounted for all evidence in the model , and therefore further sampling of other slots cannot possibly fail .
therefore the distribution we have obtained over the slots we have sampled is the nal one .
theorem 123 : if the dependency graph is acyclic then sam - plekb denes a probability distribution over partial values which have values assigned to all simple slots i : a for all named instances i .
123 multivalued slots and number uncertainty to this point , we have assumed that every slot is single - valued .
however , slots that take on multiple values are a fundamental concept in frame systems .
the ai - professor p - class may have a multi - valued papers slot of type ai - paper .
to simplify our discussion , we require multi - valued slots to be complex , and all values of the slot must be of the same p - class , as specied in the slots value - type .
to allow other slots in a frame x to depend on the prop - erties of a multi - valued slot a , we must present a way for a
slot to depend on a set of slots .
as the elements in the set cannot be referred to individually , we must refer instead to the properties of the set .
denition 123 : a quantier slot for a multi - valued slot a has the form a : : e , a : : e , na : : e or na : : e , where is a slot chain of a and e is an element of the value type of a : .
the value - type of a quantier slot is the set ftrue; falseg .
given a set of values for a , the value of a quantifer slot on a : b has precisely the meaning that one would expect; for example , if for at least 123 values i of the papers slot i : impact has the value high , then the value of 123papers . impact high is true .
note that the cpt of a quantier slot is well - dened for any number of values of its multi - valued slot .
on the other hand , no other slot can depend directly on the multi - valued slot , thereby avoiding the problem of dening general cpts with a variable number of parents .
a quantier slot , on the other hand , is treated in the same way as a simple slot , so it may be used as a parent of another slot .
thus , for example , the will - get - tenure slot of the assistant - professor class may depend on the above quantier slot .
so far , we have not specied the number of values that a given multi - valued slot can take .
in many cases , e . g . , the number of papers , this number is not xed .
therefore , we would like to be able to model situations in which different numbers of papers are possible , and to represent our beliefs in these various possibilities .
in other words , we would like to allow structural uncertaintyuncertainty over the set of entities in the world and the relationships between them .
uncertainty over the number of values of a multi - valued slot is a type of structural uncertainty called number uncertainty .
we can extend our language to represent number uncer - tainty by associating with each multivalued slot a of x a new number slot numa , which ranges over some set of natural numbers f123; 123; : : : ; ng ( we assume that the number of values of every slot is bounded ) .
the slot numa is treated just like any other simple slot; it has parents and distribution facets that describe its probability model .
thus , the number of values of a in x can depend on values of other slots of x and of related frames , and it can also be the parent of another slot .
for example , ai - professor will have a numpapers slot , whose value ranges from 123 to 123; numpapers may depend on productivity and in turn inuence tired .
as with the case of single - valued slots , a specic value i may be asserted for a multi - valued slot a of both a p - class and a named individual .
we interpret such assignments as asserting that one of as values is i .
it does not prevent a from having other values; in fact , multiple values may be asserted for the slot .
such assignments do not eliminate our number uncertainty for this slot , but any case where the slot has fewer than the number of asserted llers is eliminated; thus , we must condition numa to be at least the asserted number .
to assert that a has only the values mentioned , we would need to explicitly assert a value for numa .
it is interesting to examine the interaction between multi - valued slots and inverses .
assume that the advisees slot has an inverse advisor within the phd - student frame .
if we now have a student instance frame i , then we automatically assert at least one valuethe value ifor the advisees slot in the
instance frame i : advisor .
thus , even if we have no other information whatsoever about this instance frame , it will not be a generic member of the professor class .
the very fact that the professor is someones advisor modies its distribution by conditioning it on the fact that numadvisees 123
note that the inverse slot may also be multi - valued .
many - many relations give rise to potentially innite reference chains .
for example , a paper may have several authors , who have all written several papers , and so on .
however , due to the restrictions on the ow of inuence between primary and secondary inverses , an innite reference chain of this sort cannot lead to an innite dependency chain .
number uncertainty can be incorporated into our semantics quite easily .
we need to add number and quantier slots into the dependency graph .
number slots are treated just like simple slots : there is an edge into x : numa for each of the parents of numa in x .
if x : q is a quantier slot over x : a , there is an edge from x : a to x : q .
finally , we must make the value of x : a depend both on x : numa and the properties it imports from each of its llers .
if x : a imports b , then we have x : a y : b , where y is the type of a , and x : a i : b for every asserted value i of x : a .
the sampling process can easily be modied to account for multi - valued slots .
when a multi - valued slot a needs to be sampled for the rst time , we sample rst a value n for numa .
let m be the number of asserted values for a .
if n m , the sample fails .
otherwise , n ( cid : 123 ) m new instances of the type of a are created , and the set of values of a is set to be the m asserted llers and the n ( cid : 123 ) m new instances .
theorem 123 continues to hold .
123 reference uncertainty
as we said , structural uncertainty allows us to represent dis - tributions over models with different structures .
number un - certainty allows us to vary the set of instances in our model .
in this section , we describe reference uncertainty , which al - lows us to vary the relations between the instances .
for example , we may want the conference slot of the ai - paper class to be aaai with probability 123 , and another generic ai conference with probability 123; note that aaai is not the value of a simple slot , but an instance frame itself .
we extend our language to accomodate reference uncertainty by allowing some complex slots to be indirect .
each indirect slot a is associated with a reference slot ref a , a simple slot whose value dictates the value of the indirect slot .
denition 123 : if a is an indirect slot of type y in p - class x , then ref a is a simple slot in x whose value type is an enumerated set r , each of whose values is either : a named individual of type y , a slot - chain of x whose type is y , or the class y itself .
in any instance i of x , the value of a is dened in terms of the value of ref a : if the value of ref a is a named individual j , i : a = j; if the value of ref a is a slot - chain , then i : a = i : ; if ref a is the p - class y , then the value of a is a new instance of y .
a reference slot is treated just like any other simple slot , so it has parents and a cpt , and can inuence other simple slots .
a value can be assigned to a reference slot from
within its value - type , and the value of the indirect slot will be determined by it .
an indirect slot is treated like any other single - valued complex slot; it has an import list , and other slots can depend on the slots it imports .
for technical reasons , we do not allow direct assignments to indirect slots , nor do we allow them to have inverses .
as with number uncertainty , reference uncertainty can be incorporated quite easily into our semantics .
we need to add reference and indirect slots to the dependency graph .
a reference slot is treated like any other simple slot; thus , its only dependencies are on its parents .
an indirect slot a clearly depends on ref a , so we have a ref a .
since a is a complex slot , it also depends on the slots that it imports .
however , because of reference uncertainty , we do not know the frame from which it imports those slots .
let b be some slot on the import list of a .
to be safe , we need to account for every possible value of ref a .
thus , for each r , if is a named individual i , we have x : a i : b; if is a slot chain c : , we have x : a x : c; if is the class y , we have x : a y : b , denoting the fact a may import b from some instance of y .
the sampling process requires a small change to assign - complex to deal with indirect slots .
when assigncomplex is called with an indirect slot , we rst sample the value of the corresponding reference slot in the usual manner , and then assign the value of the indirect slot in the manner deter - mined by the value of the reference slot .
with this change , theorem 123 continues to hold .
in the preceding sections , we presented a representation lan - guage and semantics for probabilistic frame systems .
to complete the story , we now present a simple inference al - gorithm for answering probabilistic queries in such a sys - tem .
our algorithmcan handle any instance - based query , i . e . , queries about the values of slots of instances .
for simplicity , we restrict attention to simple slots of named instances , as other queries can easily be reduced to these .
the algorithm , called constructbn , is based on knowledge - based model construction ( 123 ) , the process of taking a kb and deriving a bn b representing the same probability model .
standard bn inference can then be used to answer queries .
nodes in the bayes net b have the form i : : a where i is an instance frame ( not necessarily named ) , is a possibly empty slot chain , and a is a simple slot .
the algorithmworks by backward chaining along dependency chains , constructing the appropriate nodes in the bn if they do not already exist .
more specically , the algorithm maintains an open list l of nodes to be processed .
initially , l contains only the simple slots of named instances .
in each iteration , the algorithm removes a node from l , and processes it .
when a node is removed from l , it is processed in one of three ways : as a simple slot , as a slot chain , or as a quantier slot .
simple slots i : a are processed as follows .
for each par - ent i : , an edge is added from i : to i : a by a call to addparent ( i : a , i : ) ; if i : is not already in b , this rou - tine adds i : to b and l .
( note that the parent list of any simple non - quantier slot is xed . ) when all parents have been added , the cpt is constructed from the distribution facet
a slot chain i : b : is processed as follows :
if b is indirect then if b is assigned a value j in i then k = j else k = xi : b , where x is the type of b in i set cpt of i : b : to copy the value of k : essentially , if b is assigned a named individual j in i , then i : b = j .
otherwise , i : b = xi : b , an instance of x that does not appear anywhere else in the kb; roughly , xi : b serves the role of a skolem function .
either way , the value of i : b is known to be some other frame k , so that i : b : is equal to k : .
we make k : a parent of i : b : , and dene the cpt to enforce this equality .
these intermediate nodes along the slot chain are introduced to monitor the ow of values through complex slots .
they are needed because the ow becomes complicated when the chain contains indirect slots .
intermediate variables that are spurious can easily be eliminated in a simple post - processing phase .
if b is indirect , then the value of i : b could be one of several frames , depending on the value of the reference slot i : ref b .
for any value of i : ref b , let k denote the frame which is the value of i : b .
the value of i : b : is equal to the value of k : .
in other words , i : ref b selects the value of i : b : from a set of possibilities .
therefore , the node i : b : is a multiplexer node ( 123 ) ; it has as parents the node i : ref b and all nodes k : b : , and it uses the value of i : ref b to select , as its value , the value of one of its for each value of i : refb if is a named individual j then k = j if is the slot chain then k = i : if is the class y then k = y i : c set cpt for i : b : to select the value of ki : b : it remains to deal with the cases introduced by number uncertainty .
since a multi - valued slot a can only be used by quantier slots , these are the only slots which we need to consider .
consider a quantier slot i : q over a : .
the value of i : q is fully determined by i : numa and the value of in each of the possible values of a .
let n be the maximum number of such values , and suppose that a is assigned m values j123; : : : ; jm in i .
in addition to these , there can be up to n ( cid : 123 ) m other instances that are values for a; we build a frame for each of them , jm + 123; : : : ; jn .
the node i : q depends on i : numa and on the appropriate subset of the variables ji : ; i . e . , if numa is k , then only j123; : : : ; jk will inuence i : q .
the exact form of the dependence will depend on the form of the quantier .
for example , a quanti - er slot will be a deterministic conjunction of the appropriate subset of its parents .
processquantier ( i : q ) / * a quantier over a : * / let n be the maximum value of i : numa let j 123; : : : ; j m be the assigned values to i : a for i = m + 123 to n j i = xii : a , where x is the type of i : a
figure 123 : part of the constructed bn for prof .
gumps tenure case .
models for only two of the fty possible papers are shown .
paper ( i ) is shorthand for paper ( gump . papers ) ( i ) , and conf ( i ) is short for conf ( paper ( gump . papers . conference ) ( i ) ) .
the bn constructed for
for i = 123 to n addparent ( i : q , j i : ) set the cpt for i : q to depend on j 123 : ; : : : ; j numa : to illustrate the algorithm , figure 123 shows part a kb concerning the tenure case of one prof .
gump , an instance of ai - assistant - professor .
the node gump . will - get - tenure depends on gump .
123 ( papers . impact : high ) .
the latter is a quantier slot , so it has as parents gump : numpapers and the impact slot of each of the 123 possible papers .
now , assume that the class paper has impact depending on conference . prestige .
this dependence is duplicated for each of the 123 possible pa - pers .
the slot conference is indirect , so that for each i ( using the shorthand of the gure ) paper ( i ) . conf . prestige has the parent paper ( i ) . ref ( conf ) and the prestige slot of the possible values of that reference , which are aaai and conf ( i ) .
looking over the overall structure of the algorithm , we see that there is a correspondence between the structure of the dependency graph g and that of the bn b .
we can de - ne a mapping from nodes of b to nodes of g as follows : i : a : is i : a if i is a named individual , and x : a other - wise for x the p - class of i .
intuitively , the node x : a in g is a representative for all the nodes i : a where i is a generic instance of x .
lemma 123 : if there is an edge from node 123 to node 123 in b , then there is an path from 123 to 123 in g .
in other words , g serves as a template for the dependencies in b .
many edges in b may map to the same path in g , but any cycle or innite dependency in b will necessarily map to a cycle in g ( because g is nite ) .
this property is the basis for the following theorem .
if the dependency graph is acyclic , con - structbn terminates and the constructed bayes net is acyclic .
this construction also provides us with an alternative spec - ication for the distribution dened by a probabilistic frame kb .
intuitively , the bn corresponds to the prior distribution dened by the kb .
in particular , the cpt of a numa slot can ascribe a positive probability to numa = 123 , despite the fact that one or more values have been asserted for a in the
in order for b to represent the distribution dened by our semantics , we must condition it on all of our observations .
specically , we assert the value for any simple slot whose value was assigned in the kb , and lower bounds on the value of numa corresponding to the number of values asserted for a ( including indirectly via inverses ) .
theorem 123 : let s be the set of simple slots of named individuals , and e the evidence on simple slots and number slots derived from the kb .
then prbs j e is the same as the distribution over s dened by our semantics .
we have implemented our approach within a system that contains the following functionality : a graphical network - based editor / browser can be used to annotate a frame kb with the facets encoding its probability model .
the edi - tor / browser interacts with the underlying frs using okbc , thus allowing its use with many of the existing frame systems ( e . g . , ( 123 , 123 , 123 ) ) .
our inference component also connects to the frs via okbc; it extracts the relevant information about frames , instances , and their probabilistic models , constructs the bn corresponding to the kb , and utilizes the bn to an - swer probabilistic queries .
the system has been integrated successfully with the ontolingua frame system ( 123 ) and was used for representing simple models of vehicle movement patterns in a military setting .
our experience with the sys - tem showed that even very simple models with three or four simple p - classes could be used to generate fairly complicated bns ( with hundreds of nodes ) involving several interacting
123 discussion and conclusions
in this paper , we have described the rst integration between two of the most dominant threads of work in kr .
our lan - guage provides a clean synthesis between the probabilistic reasoning component and standard frame reasoning capabil - ities .
from the perspective of frame systems , our system allows existing frame kbs to be annotated with probabilistic models , greatly increasing the ability of frame systems to ex - press meaningful knowledge in real - world applications .
we have also provided an inference algorithm capable of answer - ing probabilistic queries about instances , thereby providing a signicant increase to the inferential ability of such systems .
from the perspective of probabilistic modeling , our language provides the tools for the construction of probabilisticmodels for very large complex domains , signicantly scaling up our ability to do uncertain reasoning .
our language has given us the exciting capability of cre - ating highly expressive probabilistic models with structural uncertainty .
clearly , we have only scratched the surface of this idea .
for example , it is easy to add uncertainty over the type of an object , e . g . , to dene a probability distribu - tion with which a professor is an assistant , associate , and full professor .
it is also easy to combine number and reference uncertainty , allowing , for example , the advisor of a student to be selected from the set of faculty members in the cs department .
these are two of many possible extensions that can now be considered .
another important issue which we have partially resolved is the inference problem for probabilistic frame - based mod - els .
we have shown how we can reduce the problem to that of
reasoning in a standard bn , but this approach does not make full use of the structure encoded in our representation .
particular , it fails to exploit encapsulation of frames within other frames and the reuse of class models among several objects .
these ideas are put to good use in ( 123 , 123 ) , and it is an important research topic to apply them in our richer frame - work .
we believe that by exploiting these features in our inference as well as in our representation , we will be able to effectively represent and reason in large uncertain domains .
acknowledgments this work was supported by onr con - tract n123 - 123 - c - 123 under darpas hpkb program , by darpa contract daca123 - 123 - c - 123 under subcontract to information extraction and transport , inc . , and through the generosity of the powell foundation and the sloan founda -
