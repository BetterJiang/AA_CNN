abstractscene labeling consists in labeling each pixel in an image with the category of the object it belongs to .
we propose a method that uses a multiscale convolutional network trained from raw pixels to extract dense feature vectors that encode regions of multiple sizes centered on each pixel .
the method alleviates the need for engineered features , and produces a powerful representation that captures texture , shape and contextual information .
we report results using multiple post - processing methods to produce the nal labeling .
among those , we propose a technique to automatically retrieve , from a pool of segmentation components , an optimal set of components that best explain the scene; these components are arbitrary , e . g .
they can be taken from a segmentation tree , or from any family of over - segmentations .
the system yields record accuracies on the sift flow dataset ( 123 classes ) and the barcelona dataset ( 123 classes ) and near - record accuracy on stanford background dataset ( 123 classes ) , while being an order of magnitude faster than competing approaches , producing a 123 123 image labeling in less than a second , including feature extraction .
index termsconvolutional networks , deep learning , image segmentation , image classication , scene parsing .
i mage understanding is a task of primary impor -
tance for a wide range of practical applications .
one important step towards understanding an image is to perform a full - scene labeling also known as a scene parsing , which consists in labeling every pixel in the image with the category of the object it belongs to .
after a perfect scene parsing , every region and every object is delineated and tagged .
one challenge of scene parsing is that it combines the traditional problems of detection , segmentation , and multi - label recognition in a single
there are two questions of primary importance in the context of scene parsing : how to produce good internal representations of the visual information , and how to use contextual information to ensure the self - consistency of
this paper presents a scene parsing system that relies on deep learning methods to approach both questions .
the main idea is to use a convolutional network ( 123 ) operating on a large input window to produce label hy - potheses for each pixel location .
the convolutional net is fed with raw image pixels ( after band - pass ltering and contrast normalization ) , and trained in supervised mode from fully - labeled images to produce a category for each pixel location .
convolutional networks are composed of multiple stages each of which contains a lter bank module , a non - linearity , and a spatial pooling module .
with end - to - end training , convolutional networks can automatically learn hierarchical feature representations .
unfortunately , labeling each pixel by looking at a small region around it is difcult .
the category of a pixel may depend on relatively short - range information ( e . g .
clement farabet , camille couprie , and yann lecun are with the courant institute of mathematical sciences , new york university ( new york , ny
clement farabet and laurent najman are with the laboratoire dinformatique gaspard - monge , universite paris - est , equipe a123si , esiee paris ( 123 noisy - le - grand , france ) .
the presence of a human face generally indicates the presence of a human body nearby ) , but may also depend on long - range information .
for example , identifying a grey pixel as belonging to a road , a sidewalk , a gray car , a concrete building , or a cloudy sky requires a wide con - textual window that shows enough of the surroundings to make an informed decision .
to address this problem , we propose to use a multi - scale convolutional network , which can take into account large input windows , while keeping the number of free parameters to a minimum .
common approaches to scene parsing rst produce segmentation hypotheses using graph - based methods .
candidate segments are then encoded using engineered features .
finally , a conditional random eld ( or some other type of graphical model ) , is trained to produce labels for each candidate segment , and to ensure that the labelings are globally consistent .
a striking characteristic of the system proposed here is that the use of a large contextual window to label pixels reduces the requirement for sophisticated post - processing methods that ensure the consistency of the
architecture is depicted on figure 123
two main components :
123 ) multi - scale , convolutional
multi - scale , dense feature extractor produces a series of feature vectors for regions of multiple sizes centered around every pixel in the image , covering a large context .
the multi - scale convolutional net contains multiple copies of a single network ( all sharing the same weights ) that are applied to different scales of a laplacian pyramid version of the input image .
for each pixel , the networks collectively encode the information present in a large contextual window around the given pixel ( 123 123 pixels in the system described here ) .
the convolutional network is fed with raw pixels and trained end to end , thereby alleviating the need for hand - engineered features .
when properly trained , these features produce a representation that captures texture , shape and contextual information .
while using
a multiscale representation seems natural for fsl , has rarely been used in the context of feature learning systems .
the multiscale representation that is learned is sufciently complete to allow the detection and recognition of all the objects and regions in the scene .
however , it does not accurately pinpoint the boundaries of the regions , and requires some post - processing to yield cleanly delineated predictions .
123 ) graph - based classication : an over - segmentation is constructed from the image , and is used to group the feature descriptors .
several over - segmentations are considered , and three techniques are proposed to produce the nal image labeling .
superpixels : the image is segmented into disjoint components , widely over - segmenting the scene .
in this scenario , a pixelwise classier is trained on the convo - lutional feature vectors , and a simple vote is done for each component , to assign a single class per component .
this method is simple and effective , but imposes a xed level of segmentation , which can be suboptimal .
conditional random eld over superpixels : a conditional random eld is dened over a set of super - pixels .
compared to the previous , simpler method , this post - processing models joint probabilities at the level of the scene , and is useful to avoid local aberrations ( e . g .
a person in the sky ) .
that kind of approach is widely used in the computer vision community , and we show that our learned multiscale feature representation essentially makes the use of a global random eld much less useful : most scene - level relationships seem to be already captured by it .
multilevel cut with class purity criterion : a family of segmentations is constructed over the image to analyze the scene at multiple levels .
in the simplest case , this family might be a segmentation tree; in the most general case it can be any set of segmentations , for example a collection of superpixels either produced using the same algorithm with different parameter tunings or produced by different algorithms .
each is represented by the set of feature vectors that fall into it : the component is encoded by a spatial grid of aggregated feature vectors .
the aggregated feature vector of each grid cell computed by a component - wise max pooling of the feature vectors centered on all the pixels that fall into the grid cell .
this produces a scale - invariant representation of the segment and its surrounding .
a classier is then applied to the aggregated feature grid of each node .
this classier is trained to estimate the histogram of all object categories present in the component .
a subset of the components is then selected such that they cover the entire image .
these components are selected so as to minimize the average impurity of the class distribution in a procedure that we name optimal cover .
the class impurity is dened as the entropy of the class distribution .
the choice of the cover thus attempts to nd a consistent overall segmentation in which each segment contains pixels belonging to only one of the learned categories .
this simple method allows us to consider full families of segmentation components , rather than a unique , predetermined segmentation ( e . g .
a single set of superpixels ) .
all the steps in the process have a complexity linear ( or almost linear ) in the number of pixels .
the bulk of the computation resides in the convolutional network feature extractor .
the resulting system is very fast , producing a full parse of a 123 123 image in less than a second on a conventional cpu , and in less than 123ms using dedicated hardware , opening the door to real - time applications .
once trained , the system is parameter free , and requires no adjustment of thresholds or other knobs .
an early version of this work was rst published in ( 123 ) .
this journal version reports more complete ex - periments , comparisons and higher results .
123 related work the scene parsing problem has been approached with a wide variety of methods in recent years .
many methods rely on mrfs , crfs , or other types of graphical models to ensure the consistency of the labeling and to account for context ( 123 ) , ( 123 ) , ( 123 ) , ( 123 ) , ( 123 ) , ( 123 ) , ( 123 ) .
most methods rely on a pre - segmentation into superpixels or other segment candidates , and extract features and categories from individual segments and from various combinations of neighboring segments .
the graphical model inference pulls out the most consistent set of segments which covers the image .
( 123 ) proposed a method to aggregate segments in a greedy fashion using a trained scoring function .
the originality of the approach is that the feature vector of the combination of two segments is computed from the feature vectors of the individual segments through a trainable function .
like us , they use deep learning methods to train their feature extractor .
but unlike us , their feature extractor operates on hand - engineered fea -
one of the main question in scene parsing is how to take a wide context into account to make a local decision .
( 123 ) proposed to use the histogram of labels extracted from a coarse scale as input to the labeler that looks at ner scales .
our approach is somewhat simpler : our feature extractor is applied densely to an image pyramid .
the coarse feature maps thereby gen - erated are upsampled to match that of the nest scale .
hence with three scales , each feature vector has multiple elds which encode multiple regions of increasing sizes and decreasing resolutions , centered on the same pixel
like us , a number of authors have used families of segmentations or trees to generate candidate segments by aggregating elementary segments .
the approaches of ( 123 ) , ( 123 ) rely on inference algorithms based on graph cuts to label images using trees of segmentation .
other strategies using families of segmentations appeared in ( 123 ) , ( 123 ) .
none of the previous strategies for scene la - beling used a purity criterion on the class distributions .
combined to the optimal cover strategy , this purity criterion is general , efcient and could be applied to solve different problems .
contrary to the previously cited approaches using engineered features , our system extracts features densely from a multiscale pyramid of images using a convolu - tional network ( convnet ) ( 123 ) .
these networks can be fed with raw pixels and can automatically learn low - level and mid - level features , alleviating the need for
diagram of the scene parsing system .
the raw input image is transformed through a laplacian pyramid .
each scale is fed to a 123 - stage convolutional network , which produces a set of feature maps .
the feature maps of all scales are concatenated , the coarser - scale maps being upsampled to match the size of the nest - scale map .
each feature vector thus represents a large contextual window around each pixel .
in parallel , a single segmentation ( i . e .
superpixels ) , or a family of segmentations ( e . g .
a segmentation tree ) are computed to exploit the natural contours of the image .
the nal labeling is produced from the feature vectors and the segmentation ( s ) using different methods , as presented in section 123
hand - engineered features .
one of their advantage is the ability to compute dense features efciently over large images .
they are best known for their applications to detection and recognition ( 123 ) , ( 123 ) , ( 123 ) , ( 123 ) , but they have also been used for image segmentation , particularly for biological image segmentation ( 123 ) , ( 123 ) , ( 123 ) .
the only previously published work on using con - volutional networks for scene parsing is that of ( 123 ) .
while somewhat preliminary , their work showed that convolutional networks fed with raw pixels could be trained to perform scene parsing with decent accuracy .
unlike ( 123 ) however , our system uses a boundary - based hierarchy of segmentations to align the labels produced by the network to the boundaries in the image and thus produces representations that are independent of the size of the segments through feature pooling .
slightly after ( 123 ) , schulz and behnke proposed a similar architecture of a multiscale convolutional network for scene parsing ( 123 ) .
unlike us , they use pairwise class location lters to predict the nal segmentation , instead of using the image gradient that we found to be more accurate .
123 multiscale feature extraction for
the model proposed in this paper , depicted on figure 123 , relies on two complementary image representations .
in the rst representation , an image patch is seen as a point in rp , and we seek to nd a transform f : rp rq that maps each patch into rq , a space where it can be classied linearly .
this rst representation typically suffers from two main problems when using a classi - cal convolutional network , where the image is divided following a grid pattern : ( 123 ) the window considered rarely contains an object that is properly centered and scaled , and therefore offers a poor observation basis to predict the class of the underlying object , ( 123 ) integrating a large context involves increasing the grid size , and therefore the dimensionality p of the input; given a
nite amount of training data , it is then necessary to enforce some invariance in the function f itself .
this is usually achieved by using pooling / subsampling layers , which in turn degrades the ability of the model to precisely locate and delineate objects .
in this paper , f is implemented by a multiscale convolutional network , which allows integrating large contexts ( as large as the complete scene ) into local decisions , yet still remaining manageable in terms of parameters / dimensionality .
this multiscale model , in which weights are shared across scales , allows the model to capture long - range interac - tions , without the penalty of extra parameters to train .
this model is described in section 123 .
in the second representation , the image is seen as an edge - weighted graph , on which one or several over - segmentations can be constructed .
the components are spatially accurate , and naturally delineate the underly - ing objects , as this representation conserves pixel - level precision .
section 123 describes multiple strategies to com - bine both representations .
in particular , we describe in section 123 a method for analyzing a family of segmenta - tions ( at multiple levels ) .
it can be used as a solution to the rst problem exposed above : assuming the capability of assessing the quality of all the components in this family of segmentations , a system can automatically choose its components so as to produce the best set of
123 scale - invariant , scene - level feature extraction good internal representations are hierarchical .
in vision , pixels are assembled into edglets , edglets into motifs , motifs into parts , parts into objects , and objects into scenes .
this suggests that recognition architectures for vision ( and for other modalities such as audio and natural language ) should have multiple trainable stages stacked on top of each other , one for each level in the feature hierarchy .
convolutional networks ( convnets ) provide a simple framework to learn such hierarchies of
convolutional networks ( 123 ) , ( 123 ) are trainable archi - tectures composed of multiple stages .
the input and output of each stage are sets of arrays called feature maps .
for example , if the input is a color image , each feature map would be a 123d array containing a color channel of the input image ( for an audio input each feature map would be a 123d array , and for a video or volumetric image , it would be a 123d array ) .
at the output , each feature map represents a particular feature extracted at all locations on the input .
each stage is composed of three layers : a lter bank layer , a non - linearity layer , and a feature pooling layer .
a typical convnet is composed of one , two or three such 123 - layer stages , followed by a classication module .
because they are trainable , arbi - trary input modalities can be modeled , beyond natural
our feature extractor is a three - stage convolutional network .
the rst two stages contain a bank of lters producing multiple feature maps , a point - wise non - linear mapping and a spatial pooling followed by sub - sampling of each feature map .
the last layer only con - tains a bank of lters .
the lters ( convolution kernels ) are subject to training .
each lter is applied to the input feature maps through a 123d convolution operation , which detects local features at all locations on the input .
each lter bank of a convolutional network produces features that are equivariant under shifts , input is shifted , the output is also shifted but otherwise
while convolutional networks have been used success - fully for a number of image labeling problems , image - level tasks such as full - scene understanding ( pixel - wise labeling , or any dense feature estimation ) require the system to model complex interactions at the scale of complete images , not simply within a patch .
to view a large contextual window at full resolution , a convolu - tional network would have to be unmanageably large .
the solution is to use a multiscale approach .
our multiscale convolutional network overcomes these limi - tations by extending the concept of spatial weight repli - cation to the scale space .
given an input image i , a multiscale pyramid of images xs , s ( 123 , .
, n ) is constructed , where x123 has the size of i .
the multiscale pyramid can be a laplacian pyramid , and is typically pre - processed , so that local neighborhoods have zero mean and unit standard deviation .
given a classical convolutional network fs with parameters s , the multi - scale network is obtained by instantiating one network per scale s , and sharing all parameters across scales : s = 123 , s ( 123 , .
, n ) .
we introduce the following convention : banks of im - ages will be seen as three dimensional arrays in which the rst dimension is the number of independent feature maps , or images , the second is the height of the maps and the third is the width .
the output state of the l - th stage is denoted hl .
the maps in the pyramid are computed using a scaling / normalizing function gs as xs = gs ( i ) , for all s ( 123 , .
, n ) .
for each scale s , the convolutional network fs can be described as a sequence of linear transforms , inter - spersed with non - linear symmetric squashing units ( typ - ically the tanh function ( 123 ) ) , and pooling / subsampling operators .
for a network fs with l layers , we have :
fs ( xs; s ) = wlhl123 ,
where the vector of hidden units at layer l is
hl = pool ( tanh ( wlhl123 + bl ) )
l ( 123 , .
, l 123 ) , with bl a vector of bias parameters , and h123 = xs .
the matrices wl are toeplitz matrices , therefore each hidden unit vector hl can be expressed as a regular convolution between kernels from wl and the previous hidden unit vector hl123 , squashed through a tanh , and pooled spatially .
more specically ,
hlp = pool ( tanh ( blp + x
the lters wl and the biases bl constitute the trainable parameters of our model , and are collectively denoted s .
the function tanh is a point - wise non - linearity , while is a function that considers a neighborhood of activations , and produces one activation per neighbor - hood .
in all our experiments , we use a max - pooling operator , which takes the maximum activation within the neighborhood .
pooling over a small neighborhood provides built - in invariance to small translations .
finally , the outputs of the n networks are upsampled and concatenated so as to produce f , a map of feature vectors of size n times the size of f123 , which can be seen as local patch descriptors and scene - level descriptors
f = ( f123 , u ( f123 ) , .
, u ( fn ) ) ,
where u is an upsampling function .
as mentioned above , weights are shared between net - works fs .
intuitively , imposing complete weight sharing across scales is a natural way of forcing the network to learn scale invariant features , and at the same time reduce the chances of over - tting .
the more scales used to jointly train the models fs ( s ) the better the represen - tation becomes for all scales .
because image content is , in principle , scale invariant , using the same function to extract features at each scale is justied .
123 learning discriminative scale - invariant features as described in section 123 , feature vectors in f are obtained by concatenating the outputs of multiple net - works fs , each taking as input a different image in a
ideally a linear classier should produce the correct categorization for all pixel locations i , from the feature vectors fi .
we train the parameters s to achieve this goal , using the multiclass cross entropy loss function .
let ci be the normalized prediction vector from the linear classier for pixel i .
we compute normalized predicted probability distributions over classes ci , a using the soft - max function , i . e .
where w is a temporary weight matrix only used to learn the features .
the cross entropy between the predicted class distribution c and the target class distribution c penalizes their deviation and is measured by
with di the groundtruth distribution at location i , and s ( k ) the surface of component k .
matrices w123 and w123 are the trainable parameters of the classier .
using a two - layer neural network , as opposed to the simple linear classier used in section 123 , allows the system to capture non - linear relationships between the features at different scales .
in this case , the nal labeling for each component k is given by
first labeling strategy from the features : using superpixels as described in section 123 .
lk = arg max
lcat = x
the true target probability ci , a of class a to be present at location i can either be a distribution of classes at location i , in a given neighborhood or a hard target vector : ci , a = 123 if pixel i is labeled a , and 123 otherwise .
for training maximally discriminative features , we use hard target vectors in this rst stage .
once the parameters s are trained , the classier in eq 123 is discarded , and the feature vectors fi are used using different strategies , as described in section 123
123 scene labeling strategies the simplest strategy for labeling the scene is to use the linear classier described in section 123 , and assign each pixel with the argmax of the prediction at its location .
more specically , for each pixel i
li = arg max
the resulting labeling l , although fairly accurate , is not satisfying visually , as it lacks spatial consistency , and precise delineation of objects .
in this section , we explore three strategies to produce spatially more appealing
predicting the class of each pixel independently from its neighbors yields noisy predictions .
a simple cleanup can be obtained by forcing local regions of same color intensities to be assigned a single label .
as in ( 123 ) , ( 123 ) , we compute superpixels , following the method proposed by ( 123 ) , to produce an over - segmentation of the image .
we then classify each location of the image densely , and aggregate these predictions in each superpixel , by computing the average class distri - bution within the superpixel .
for this method , the pixelwise distributions dk at superpixel k are predicted from the feature vectors fi using a two - layer neural network :
yi = w123 tanh ( w123fi + b123 ) ,
lcat = x
the pipeline is depicted in figure 123
123 conditional random fields
the local assignment obtained using superpixels does not involve a global understanding of the scene .
in this section , we implement a classical crf model , con - structed on the superpixels .
this is a quite standard ap - proach for image labeling .
our multi - scale convolutional network already has the capability of modeling global relationships within a scene , but might still be prone to errors , and can benet from a crf , to impose consistency and coherency between labels , at test time .
a common strategy for labeling a scene consists in associating the image to a graph and dene an energy function whose optimal solution corresponds to the de - sired segmentation ( 123 ) , ( 123 ) .
for this purpose , we dene a graph g = ( v , e ) with vertices v v and edges e e v v .
each pixel in the image is associated to a vertex , and edges are added between every neighboring nodes .
an edge , e , spanning two vertices , vi and vj , is denoted by eij .
the conditional random field ( crf ) energy function is typically composed of a unary term enforcing the variable l to take values close to the predictions d and a pairwise term enforcing regularity or local consistency of l .
the crf energy to minimize is given by
e ( l ) = x
( di , li ) + x
we considered as unary terms
( di , a , li ) = exp ( di , a ) 123 ( li 123= a ) ,
where di , a corresponds to the probability of class a to be present at a pixel i computed as in section 123 , and 123 ( ) is an indicator function that equals one if the input is true , and zero otherwise .
the pairwise term consists in
( li , lj ) = exp ( kiki ) 123 ( li 123= lj )
where kiki is the 123 norm of the gradient of the image i at a pixel i .
details on the parameters used are given in the experimental section .
the crf energy ( 123 )
is minimized using alpha - expansions ( 123 ) , ( 123 ) .
an illustration of the procedure appears in figure 123
second labeling strategy from the features : using a crf , described in section 123 .
123 parameter - free multilevel parsing
one problem subsists with the two methods presented above : the observation level problem .
an object , or object part , can be easily classied once it is segmented at the right level .
the two methods above are based on an arbitrary segmentation of the image , which typically decomposes it into segments that are too small , or , more rarely , too large .
in this section , we propose a method to analyze a family of segmentations and automatically discover the best observation level for each pixel in the image .
one special case of such families is the segmentation tree , in which components are hierarchically organized .
our method is not restricted to such trees , and can be used for arbitrary sets of neighborhoods .
in section 123 . 123 we formulate the search for the most adapted neighborhood of a pixel as an optimization problem .
the construction of the cost function that is minimized is then described in section 123 . 123
123 . 123 optimal purity cover we dene the neighborhood of a pixel as a connected that contains this pixel .
let ck , k ( 123 , .
, k ) be the set of all possible connected compo - nents of the lattice dened on image i , and let sk be a cost associated to each of these components .
for each pixel i , we wish to nd the index k ( i ) of the component that best explains this pixel , that is , the component with the minimal cost sk ( i ) :
k ( i ) = argmin k | ick
note that components ck ( i ) are non - disjoint sets that form a cover of the lattice .
note also that the overall cost s = pi sk ( i ) is minimal .
in practice , the set of components ck is too large , and only a subset of it can be considered .
a classical technique to reduce the set of components is to con - sider a hierarchy of segmentations ( 123 ) , ( 123 ) , that can be represented as a tree t .
this was previously explored in ( 123 ) .
solving eq 123 on t consists in the following procedure : for each pixel ( leaf ) i , the optimal component ck ( i ) is the one along the path between the leaf and the root with minimal cost sk ( i ) .
the optimal cover is the union of all these components .
for efciency purposes , it can be done simply by exploring the tree in a depth - rst search manner , and nding the component with minimal weight along each branch .
the complexity of the optimal cover procedure is then linear in the
third labeling strategy from the features : using a family of of segmentations , as described in section 123 .
on this gure , the family of segmentations is a segmen - tation tree .
the segment associated with each node in the tree is encoded by a spatial grid of feature vectors pooled in the segments region .
a classier is then applied to all the aggregated feature grids to produce a histogram of categories , the entropy of which measures the impu - rity of the segment .
each pixel is then labeled by the minimally - impure node above it , which is the segment that best explains the pixel .
( c123 , c123 , c123 , c123 )
c123 c123 c123 c123
finding the optimal cover on a tree .
the numbers next to the components correspond to the entropy scores si .
for each pixel ( leaf ) i , the optimal component ck ( i ) is the one along the path between the leaf and the root with minimal cost sk ( i ) .
the optimal cover is the union of all these components .
in this example , the optimal cover ( c123 , c123 , c123 , c123 ) will result in a segmentation in disjoint sets ( c123 , c123 , c123 , c123 ) , with the subtle difference that component c123 will be labelled with the class of c123 , as c123 is the best observation level for c123
the generalization to a family of segmentations is straightforward ( see text ) .
number of components in the tree .
figure 123 illustrates
another technique to reduce the set of components considered is to compute a set of segmentations using different merging thresholds .
in section 123 , we use such an approach , by computing multiple levels of the felzen - szwalb algorithm ( 123 ) .
the felzenszwalb algorithm is not strictly monotonic , so the structure obtained cannot be cast into a tree : rather , it has a general graph form , in which each pixel belongs to as many superpixels as levels explored .
solving eq 123 in this case consists in the following procedure : for each pixel i , the optimal component ck ( i ) is the one among all the segmentations with minimal cost sk ( i ) .
thus the complexity to produce a cover on the family of components is linear on the number of pixels , but with a constant that is proportional to the number of levels explored .
123 . 123 producing the condence costs given a set of components ck , we explain how to produce all the condence costs sk .
these costs represent the class purity of the associated components .
given the groundtruth segmentation , we can compute the cost as being the entropy of the distribution of classes present in the component .
at test time , when no groundtruth is available , we need to dene a function that can predict this cost by simply looking at the component .
we now describe a way of achieving this , as illustrated in figure 123
given the scale - invariant features f , we dene a compact representation to describe objects as an elastic spatial arrangement of such features .
in other terms , an object , or category in general , can be best described as a spatial arrangement of features , or parts .
we dene a simple attention function a used to mask the feature vector map with each component ck , producing a set of k masked feature vector patterns ( f t ck ) , k ( 123 , .
the function a is called an attention func - tion because it suppresses the background around the component being analyzed .
the patterns ( f t ck ) are resampled to produce xed - size representations .
in our model the sampling is done using an elastic max - pooling
the shape - invariant attention function a .
for each component ck in the family of segmentations t , corresponding image segment is encoded by a spatial grid of feature vectors that fall into this segment .
the aggregated feature vector of each grid cell is computed by a component - wise max pooling of the feature vectors centered on all the pixels that fall into the grid cell; this produces a scale - invariant representation of the segment and its surroundings .
the result , ok , is a descriptor that encodes spatial relations between the underlying objects parts .
the grid size was set to 123 for all our experiments .
function , which remaps input patterns of arbitrary size into a xed g g grid .
this grid can be seen as a highly invariant representation that encodes spatial relations between an objects attributes / parts .
this representation is denoted ok .
some nice properties of this encoding are : ( 123 ) elongated , or in general ill - shaped objects , are nicely handled , ( 123 ) the dominant features are used to represent the object , combined with background subtraction , the features pooled represent solid basis functions to recog - nize the underlying object .
once we have the set of object descriptors ok , we dene a function c : ok ( 123 , 123 ) nc ( where nc is the number of classes ) as predicting the distribution of classes present in component ck .
we associate a cost sk to this distribution .
in this paper , c is implemented as a simple 123 - layer neural network , and sk is the entropy of the predicted distribution .
more formally , let ok be the feature vector associated with component ck , dk the predicted class distribution , and sk the cost associated to this distribution .
we have
yk = w123 tanh ( w123ok + b123 ) ,
sk = x
with dk the groundtruth distribution for component k .
matrices w123 and w123 are noted c , and represent the trainable parameters of c .
these parameters need to be learned over the complete set of segmentation families , computed on the entire training set available .
the training procedure is described in section 123 . 123
for each component ck chosen by the optimal purity
cover ( section 123 . 123 ) the label is produced by :
lk = arg max
dk , a ck cut .
123 . 123 training procedure let f be the set of all feature maps in the training set , and t the set of all families of segmentations
construct the segmentation collections ( t ) t t on the entire training set , and , for all t t train the classier c to predict the distribution of classes in component ck t , as well as the costs sk .
given the trained parameters s , we build f and t , i . e .
we compute all vector maps f and segmentation collections t on all the training data available , so as to produce a new training set of descriptors ok .
this time , the parameters c of the classier c are trained to minimize the kl - divergence between the true ( known ) distributions of labels dk in each component , and the prediction from the classier dk ( eq 123 ) :
ldiv = x
in this setting , the groundtruth distributions dk are not hard target vectors , but normalized histograms of the labels present in component ck .
once the parameters c are trained , dk accurately predicts the distribution of labels , and eq 123 is used to assign a purity cost to the
we report our semantic scene understanding results on three different datasets : stanford background on which related state - of - the - art methods report classica - tion errors , and two more challenging datasets with a larger number of classes : sift flow and barcelona .
the stanford background dataset ( 123 ) contains 123 im - ages of outdoor scenes composed of 123 classes , chosen from other existing public datasets so that all the images are outdoor scenes , have approximately 123 123 pixels , where each image contains at least one foreground ob - ject .
we use the evaluation procedure introduced in ( 123 ) , 123 - fold cross validation : 123 images used for training , and 123 for testing .
the sift flow dataset ( 123 ) is composed of 123 , 123 images , that have been thoroughly labeled by labelme users , and split in 123 , 123 training images and 123 test images .
the authors used synonym correction to obtain 123 semantic labels .
the barcelona dataset , as described in ( 123 ) , is derived from the labelme subset used in ( 123 ) .
it has 123 , 123 training and 123 test images .
the test set consists of street scenes from barcelona , while the training set ranges in scene types but has no street scenes from barcelona .
synonyms were manually consolidated by ( 123 ) to produce 123 unique labels .
to evaluate the representation from our multiscale convolutional network , we report results from several experiments on the stanford background dataset : ( 123 ) a system based on a plain convolutional network alone; ( 123 ) the multiscale convolutional network presented in sec - tion 123 , with raw pixelwise prediction; ( 123 ) superpixel - based predictions , as presented in section 123; ( 123 ) crf - based predictions , as presented in section 123; ( 123 ) cover - based predictions , as presented in section 123 .
results are reported in table 123 , and compared with related works .
our model achieves very good results in comparison with previous approaches .
methods of ( 123 ) , ( 123 ) achieve similar or better performances on this partic - ular dataset but to the price of several minutes to parse
gould et al .
123 ( 123 ) munoz et al .
123 ( 123 ) tighe et al .
123 ( 123 ) socher et al .
123 ( 123 ) kumar et al .
123 ( 123 )
lempitzky et al .
123 ( 123 )
multiscale net + superpixels multiscale net + gpb + cover multiscale net + crf on gpb
123 to 123s
123 to 123s
performance of our system on the stanford background dataset ( 123 ) : per - pixel / average per - class accuracy .
the third column reports compute times , as reported by the authors .
our algorithms were computed using a 123 - core
liu et al .
123 ( 123 ) tighe et al .
123 ( 123 ) raw multiscale net123
multiscale net + superpixels123
multiscale net + cover123 multiscale net + cover123
performance of our system on the sift flow dataset
( 123 ) : per - pixel / average per - class accuracy .
our multiscale network is trained using two sampling
methods : 123balanced frequencies , 123natural frequencies .
we compare the results of our multiscale network with
the raw ( pixelwise ) classier , felzenszwalb
superpixels ( 123 ) ( one level ) , and our optimal cover
applied to a stack of 123 levels of felzenszwalb
superpixels .
note : the threshold for the single level was picked to yield the best results; the cover automatically
nds the best combination of superpixels .
we then demonstrate that our system scales nicely when augmenting the number of classes on two other datasets , in tables 123 and 123
results on these datasets were obtained using our cover - based method , from sec - tion 123 .
example parses on the sift flow dataset are shown on figure 123
for the sift flow and barcelona datasets , we ex - perimented with two sampling methods when learning the multiscale features : respecting natural frequencies of classes , and balancing them so that an equal amount of each class is shown to the network .
balancing class oc - currences is essential to model the conditional likelihood of each class ( i . e .
ignore their prior distribution ) .
both results are reported in table 123
training with balanced frequencies allows better discrimination of small objects , and although it decreases the overall pixelwise accuracy , it is more correct from a recognition point of view .
frequency balancing is used on the stanford background dataset , as it consistently gives better results .
for the barcelona dataset , both sampling methods are used as well , but frequency balancing worked rather poorly in that case .
this can be explained by the fact that this dataset has a large amount of classes with very few training examples .
these classes are therefore extremely
example of results on the stanford background dataset .
( b ) , ( d ) and ( f ) show results with different labeling strategies , overlaid with superpixels ( cf section 123 ) , segments results of a threshold in the gpb hierarchy ( 123 ) , and segments recovered by the maximum purity approach with an optimal cover ( cf 123 ) .
the result ( c ) is obtained with a crf on the superpixels shown in ( d ) , as described in section 123 .
hard to model , and overtting occurs much faster than for the sift flow dataset .
results are shown on table 123
results in table 123 demonstrate the impressive com - putational advantage of convolutional networks over competing algorithms .
exploiting the parallel structure of this special network , by computing convolutions in parallel , allows us to parse an image of size 123 123 in less than one second on a 123 - core intel i123 laptop .
using gpus or other types of dedicated hardware , our scene parsing model can be run in real - time ( i . e .
at more than
123 multiscale feature extraction
for all experiments , we use a 123 - stage convolutional net - work .
the rst two layers of the network are composed of a bank of lters of size 123 followed by tanh units and 123 123 max - pooling operations .
the last layer is a simple
lter bank .
the lters and pooling dimensions were chosen by a grid search .
the input image is transformed into yuv space , and a laplacian pyramid is constructed from it .
the y , u and v channels of each scale in the pyramid are then independently locally normalized , such that each local 123 patch has zero - mean and unit variance .
for these experiments , the pyramid consists of 123 rescaled versions of the input ( n = 123 ) , in octaves : 123 123 , 123 123 , 123 123
the network is then applied to each 123 - dimension input map xs .
this input is transformed into a 123 - dimension feature map , using a bank of 123 lters , 123 connected to the y channel , the 123 others connected to the u and v channels .
the second layer transforms this 123 - dimension feature map into a 123 - dimension feature map , each map being produced by a combination of 123 randomly selected feature maps from the previous layer .
finally the 123 - dimension feature map is transformed into
more results using our multiscale convolutional network and a at crf on the stanford background dataset .
tighe et al .
123 ( 123 ) raw multiscale net123
multiscale net + superpixels123
multiscale net + cover123 multiscale net + cover123
performance of our system on the barcelona
dataset ( 123 ) : per - pixel / average per - class accuracy
multiscale network is trained using two sampling
methods : 123balanced frequencies , 123natural frequencies .
we compare the results of our multiscale network with
the raw ( pixelwise ) classier , felzenszwalb
superpixels ( 123 ) ( one level ) , and our optimal cover
applied to a stack of 123 levels of felzenszwalb
superpixels .
note : the threshold for the single level was picked to yield the best results; the cover automatically
nds the best combination of superpixels .
a 123 - dimension feature map , each map being produced by a combination of 123 randomly selected feature maps from the previous layer .
the outputs of each of the 123 networks are then upsam - pled and concatenated , so as to produce a 123 123 = 123 - dimension feature vector map f .
given the lter sizes , the network has a eld of view of 123 123 , at each scale , which means that a feature vector in f is inuenced by a 123 neighborhood at full resolution , a 123 neigh - borhood at half resolution , and a 123 neighborhood at quarter resolution .
these neighborhoods are shown in
the network is trained on all 123 scales in parallel , using stochastic gradient descent with no second - order infor - mation , and mini - batches of size 123
simple grid - search was performed to nd the best learning rate ( 123 ) and regularization parameters ( l123 coefcient : 123 ) , using a holdout of 123% of the training data for validation .
the holdout is also used to select the best network , i . e .
the network that generalizes the most on the holdout .
convergence , that is , maximum generalization perfor - mance , is typically attained after between 123 to 123 mil - lion patches have been seen during stochastic gradient
descent .
this typically represents between two to ve days of training .
no special hardware ( gpus ) was used
the convolutional network has roughly 123 million trainable parameters .
to ensure that features do not overt some irrelevant biases present in the data , jitter horizontal ipping of all images , rotations between 123 and 123 degrees , and rescaling between 123 and 123% was used to articially expand the size of the training data .
these additional distortions are applied during training , before loading a new training point , and are sampled from uniform distributions .
jitter was shown to be crucial for low - level feature learning in the works of ( 123 ) and ( 123 ) .
for our baseline , we trained a single - scale network and a three - scale network as raw site predictors , for each location i , using the classication loss lcat dened in eq 123 , with the two - layer neural network dened in eq 123
table 123 shows the clear advantage of the multi - scale representation , which captures scene - level dependencies , and can classify more pixels accurately .
without an explicit segmentation model , the visual aspect of the pre - dictions still suffers from inaccurate object delineation .
123 parsing with superpixels the results obtained with the strategy presented in section 123 demonstrate the quality of our multiscale features , by reaching a very high classication accuracy on all three datasets .
this simple strategy is also a real t for real time applications , taking only an additional 123 second to label a 123 123 image on intel i123 cpu .
an example of result is given in figure 123
the 123layer neural network used for this method ( eq 123 ) has 123 input units , 123 hidden units; and as many output units as classes in each dataset .
this neural network is trained with no regularization .
123 multilevel parsing although the simple strategy of the previous section seems appealing , the results can be further improved using the multilevel approach of section 123 .
the family of segmentations used to nd the optimal cover could be a simple segmentation tree constructed
on the raw image gradient .
for the stanford background dataset experiments , we used a more sophisticated tree based on a semantic image gradient .
we used the gpb hierarchies of arbelaez et al .
, which are computed using spectral clustering to produce semantically con - sistent contours of objects .
their computation requires one minute per image .
for the sift flow and barcelona datasets , we used a cheaper technique , which does not rely on a tree : we ran the superpixel method proposed by felzenszwalb in ( 123 ) at 123 different levels .
the felzenszwalb algorithm is not strictly monotonic , so the structure obtained cannot be cast into a tree : rather , it has a general graph form , in which each pixel belongs to 123 different superpixels .
our optimal cover algorithm can be readily applied to arbitrary structures of this type .
the 123 levels were chosen such that they are linearly distributed and span a large range .
classically , segmentation methods nd a partition of the segments rather than a cover .
partitioning the seg - ments consists in nding an optimal cut in a tree ( so that each terminal node in the pruned tree corresponds to a segment ) .
we experimented with graph - cuts to do so ( 123 ) , ( 123 ) , but the results were less accurate than with our optimal cover method ( stanford background dataset
the 123layer neural network c from eq 123 has 123 123 123 = 123 input units ( using a 123 123 grid of feature vectors from f ) , 123 hidden units; and as many output units as classes in each dataset .
this rather large neural network is trained with l123 regularization ( coefcient : 123 ) , to minimize overtting .
results are better than the superpixel method , particular , better delineation is achieved ( see fig
123 conditional random eld we demonstrate the state - of - the - art quality of our fea - tures by employing a crf on the superpixels given by thresholding the gpb hierarchy , on the stanford back - ground dataset .
a similar test is performed in lempitsky et al .
( 123 ) , where the authors also use a crf on the same superpixels ( at the threshold 123 in the gpb hierarchy ) , but employ different features .
histograms of densely sam - pled sift words , colors , locations , and contour shape descriptors .
they report a ratio of correctly classied pixels of 123% on the stanford background dataset .
we recall that this accuracy is the best one has achieved at the present day on this dataset with a at crf .
in our crf energy , we performed a grid search to set the parameters of ( 123 ) ( = 123 , = 123 = 123 ) , and used a grey level gradient .
the accuracy of the resulting system is 123 , as reported in table 123
our features are thus outperforming the best publicly available combina - tion of handcrafted features .
123 some comments on the learned features with recent advances in unsupervised ( deep ) learning , learned features have become easier to analyze and understand .
in this work , the entire stack of features is learned in a purely supervised manner , and yet we found that the features obtained are rather meaningful .
we believe that the reason for this is the type of loss function we use , which enforces a large invariance : the system
is forced to produce an invariant representation for all the locations of a given object .
this type of invariance is very similar to what can be achieved using semi - supervised techniques such as dr - lim ( 123 ) , where the loss enforces pairs of similar patches to yield a same encoding .
figure 123 shows an example of the features learned on the sift flow dataset .
typical rst layer features , learned on the sift flow dataset .
( a ) to ( c ) show the 123 lters learned at each scale , when no weight sharing is used ( networks at each scale are independent ) .
( d ) show the 123 lters obtained when sharing weights across all 123 scales .
all the lters are 123 123
we observe typical oriented edges , and high - frequency lters .
filters at higher layers are more difcult
123 some comments on real - world generalization
now that we have compared and discussed several strategies for scene parsing based on our multiscale features , we consider taking our system in the real - world , to evaluate its generalization properties .
the work of ( 123 ) , measuring dataset bias , raises the question of the generalization of a recognition system learned on specic , publicly available datasets .
we used our multiscale features combined with clas - sication using superpixels as described in section 123 , trained on the siftflow dataset ( 123 , 123 images , most of them taken in non - urban environments , see table 123 and figure 123 ) .
we collected a 123 degree movie in our workplace environment , including a street and a park .
introducing difculties such as lighting conditions and image distortions : see figure 123
the movie was built from four videos that were stitched to form a 123 degree video stream of 123 123 images , thus creating artifacts not seen during training .
we processed each frame independently , without using any temporal consistency or smoothing .
despite all these constraints , and the rather small size of the training dataset , we observe rather convinc - ing generalization of our models on these previously unseen scenes .
the two video sequences are available at http : / / www . clement . farabet . net / .
two snapshots are included in figure 123
our scene parsing system con - stitutes at the best of our knowledge the rst approach achieving real time performance , one frame being pro - cessed in less than a second on a 123 - core intel i123
feature extraction , which represent around 123ms on the i123 can be reduced to 123ms using dedicated fpga hardware ( 123 ) ,
the main lessons from the experiments presented in this paper are as follows :
typical results achieved on the sift flow dataset .
using a high - capacity feature - learning system fed with raw pixels yields excellent results , when com - pared with systems that use engineered features .
the accuracy is similar or better than competing systems , even when the segmentation hypothesis generation and the post - processing module are ab - sent or very simple .
feeding the system with a wide contextual window is critical to the quality of the results .
the numbers in table 123 show a dramatic improvement of the per - formance of the multi - scale convolutional network over the single scale version .
when a wide context is taken into account to pro - duce each pixel label , the role of the post - processing is greatly reduced .
in fact , a simple majority vote of the categories within a superpixel yields state - of - the - art accuracy .
this seems to suggest that contex - tual information can be taken into account by a feed - forward trainable system with a wide contextual window , perhaps as well as an inference mechanism that propagates label constraints over a graphical model , but with a considerably lower computational
the use of highly sophisticated post - processing schemes , which seem so crucial to the success of other models , does not seem to improve the re - sults signicantly over simple schemes .
this seems to suggest that the performance is limited by the quality of the labeling , or the quality of the seg - mentation hypotheses , rather than by the quality of the contextual consistency system or the inference
relying heavily on a highly - accurate feed - forward pixel labeling system , while simplifying the post - processing module to its bare minimum cuts down the inference times considerably .
the resulting sys - tem is dramatically faster than those that rely heav - inference .
moreover , the ily on graphical model
bulk of the computation takes place in the convolu - tional network .
this computation is algorithmically simple , easily parallelizable .
implementations on multi - core machines , general - purpose gpus , dig - ital signal processors , or specialized architectures implemented on fpgas is straightforward .
this is demonstrated by the fpga implementation ( 123 ) , ( 123 ) of the feature extraction scheme presented in this paper that runs in 123ms for an image resolution of
123 conclusion and future work this paper demonstrates that a feed - forward convo - lutional network , trained end - to - end in a supervised manner , and fed with raw pixels from large patches over multiple scales , can produce state of the art performance on standard scene parsing datasets .
the model does not rely on engineered features , and uses purely supervised training from fully - labeled images to learn appropriate low - level and mid - level features .
perhaps the most surprising results is that even in the absence of any post - processing , by simply labeling each pixel with the highest - scoring category produced by the convolutional net for that location , the system yields near state - of - the - art pixel - wise accuracy , and bet - ter per - class accuracy than all previously - published re - sults .
feeding the features of the convolutional net to various sophisticated schemes that generate segmenta - tion hypotheses , and that nd consistent segmentations and labeling by taking local constraints into account improves the results slightly , but not considerably .
while the results on datasets with few categories are good , the accuracy of the best existing scene parsing sys - tems , including ours , is still quite low when the number of categories is large .
the problem of scene parsing is far from being solved .
while the system presented here has a number of advantages and shortcomings , the framing of the scene parsing task itself is in need of renement .
real - time scene parsing in natural conditions .
training on siftflow dataset .
we display one label per component in the nal prediction .
first of all , the pixel - wise accuracy is a somewhat inaccurate measure of the visual and practical quality of the result .
spotting rare objects is often more important than accurately labeling every boundary pixel of the sky ( which are often in greater number ) .
the average per - class accuracy is a step in the right direction , but not the ultimate solution : one would prefer a system that correctly spots every object or region , while giving an approximate boundary to a system that produces accurate boundaries for large regions ( sky , road , grass ) , but fail to spot small objects .
a reection is needed on the best ways to measure the accuracy of scene labeling
scene parsing datasets also need better labels .
one could imagine using scene parsing datasets with hi - erarchical labels , so that a window within a building would be labeled as building and window .
using this kind of labeling in conjunction with graph structures on sets of labels that contain is - part - of relationships would likely produce more consistent interpretations of the whole scene .
the framework presented in this paper trains the convolutional net as a pixel labeling system in isolation from the post - processing module that ensures the con - sistency of the labeling and its proper registration with the image regions .
this requires that the convolutional
net be trained with images that are fully labeled at the pixel level .
one would hope that jointly ne - tuning the convolutional net and the post - processor produces interpretations .
gradients can be back - propagated through the post - processor to the convolu - tional nets .
this is reminiscent of the graph transformer network model , a kind of non - linear crf in which an un - normalized graphical model based post - processing module was trained jointly with a convolutional network for handwriting recognition ( 123 ) .
unfortunately , prelimi - nary experiments with such joint training yielded lower test - set accuracies due to overtraining .
a more importantly advantage of joint training would allow the use of weakly - labeled images in which only a list of objects present in the image would be given , perhaps tagged with approximate positions .
this would be similar in spirit to sentence - level discriminative train - ing methods used in speech recognition and handwriting
another possible direction for improvement includes the use of objective functions that directly operates of the edge costs of neighborhood graphs in such as way that graph - cut segmentation and similar methods produce the best answer .
one such objective function is is turagas maximin learning ( 123 ) , which pushes up the lowest edge cost along the shortest path between two points in different segments , and pushes down the highest edge cost along a path between two points in the same segment .
our system so far has been trained using purely supervised learning applied to a fairly classical convo - lutional network architecture .
however , a number of recent works have shown the advantage of architectural elements such as rectifying non - linearities and local contrast normalization ( 123 ) .
more importantly , several works have shown the advantage of using unsupervised pre - training to prime the convolutional net into a good starting point before supervised renement ( 123 ) , ( 123 ) , ( 123 ) , ( 123 ) , ( 123 ) .
these methods improve the performance in the low training set size regime , and would probably improve the performance of the present system .
code and data are available online at
we would like to thank marco scofer for fruitful dis - cussions and the 123 degree video collection .
we are also grateful to victor lempitsky who kindly provided us with his results on the stanford database for compari -
this work was funded in part by darpa contract in - tegrated deep learning for large scale multi - modal data representation , onr muri provably - stable vision - based control of high - speed ight , onr grant learn - ing hierarchical models for information integration .
