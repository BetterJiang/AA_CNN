a goal of statistical language modeling is to learn the joint probability function of sequences of words in a language .
this is intrinsically difcult because of the curse of dimensionality : a word sequence on which the model will be tested is likely to be different from all the word sequences seen during training .
traditional but very successful approaches based on n - grams obtain generalization by concatenating very short overlapping sequences seen in the training set .
we propose to ght the curse of dimensionality by learning a distributed representation for words which allows each training sentence to inform the model about an exponential number of semantically neighboring sentences .
the model learns simultaneously ( 123 ) a distributed representation for each word along with ( 123 ) the probability function for word sequences , expressed in terms of these representations .
generalization is obtained because a sequence of words that has never been seen before gets high probability if it is made of words that are similar ( in the sense of having a nearby representation ) to words forming an already seen sentence .
training such large models ( with millions of parameters ) within a reasonable time is itself a signicant challenge .
we report on experiments using neural networks for the probability function , showing on two text corpora that the proposed approach signicantly improves on state - of - the - art n - gram models , and that the proposed approach allows to take advantage of longer contexts .
keywords : statistical language modeling , articial neural networks , distributed representation , curse of dimensionality
a fundamental problem that makes language modeling and other learning problems difcult is the curse of dimensionality .
it is particularly obvious in the case when one wants to model the joint distribution between many discrete random variables ( such as words in a sentence , or discrete at - tributes in a data - mining task ) .
for example , if one wants to model the joint distribution of 123 consecutive words in a natural language with a vocabulary v of size 123 , 123 , there are potentially 123 123 = 123 123 free parameters .
when modeling continuous variables , we obtain gen - eralization more easily ( e . g .
with smooth classes of functions like multi - layer neural networks or gaussian mixture models ) because the function to be learned can be expected to have some lo - cal smoothness properties .
for discrete spaces , the generalization structure is not as obvious : any change of these discrete variables may have a drastic impact on the value of the function to be esti -
c ( cid : 123 ) 123 yoshua bengio , rjean ducharme , pascal vincent , christian jauvin .
bengio , ducharme , vincent and jauvin
mated , and when the number of values that each discrete variable can take is large , most observed objects are almost maximally far from each other in hamming distance .
a useful way to visualize how different learning algorithms generalize , inspired from the view of non - parametric density estimation , is to think of how probability mass that is initially concentrated on the training points ( e . g . , training sentences ) is distributed in a larger volume , usually in some form of neighborhood around the training points .
in high dimensions , it is crucial to distribute probability mass where it matters rather than uniformly in all directions around each training point .
we will show in this paper that the way in which the approach proposed here generalizes is fundamentally different from the way in which previous state - of - the - art statistical language modeling approaches
a statistical model of language can be represented by the conditional probability of the next
word given all the previous ones , since
= ( wi , wi+123 , ( cid : 123 ) ( cid : 123 ) ( cid : 123 ) , w j123 , w j ) .
such statisti - where wt is the t - th word , and writing sub - sequence w j cal language models have already been found useful in many technological applications involving natural language , such as speech recognition , language translation , and information retrieval .
im - provements in statistical language models could thus have a signicant impact on such applications .
when building statistical models of natural language , one considerably reduces the difculty of this modeling problem by taking advantage of word order , and the fact that temporally closer words in the word sequence are statistically more dependent .
thus , n - gram models construct ta - bles of conditional probabilities for the next word , for each one of a large number of contexts , i . e .
combinations of the last n 123 words :
) ( cid : 123 ) p ( wtjwt123
we only consider those combinations of successive words that actually occur in the training cor - pus , or that occur frequently enough .
what happens when a new combination of n words appears that was not seen in the training corpus ? we do not want to assign zero probability to such cases , because such new combinations are likely to occur , and they will occur even more frequently for larger context sizes .
a simple answer is to look at the probability predicted using a smaller context size , as done in back - off trigram models ( katz , 123 ) or in smoothed ( or interpolated ) trigram mod - els ( jelinek and mercer , 123 ) .
so , in such models , how is generalization basically obtained from sequences of words seen in the training corpus to new sequences of words ? a way to understand how this happens is to think about a generative model corresponding to these interpolated or back - off n - gram models .
essentially , a new sequence of words is generated by gluing very short and overlapping pieces of length 123 , 123 . . .
or up to n words that have been seen frequently in the training data .
the rules for obtaining the probability of the next piece are implicit in the particulars of the back - off or interpolated n - gram algorithm .
typically researchers have used n = 123 , i . e .
and obtained state - of - the - art results , but see goodman ( 123 ) for how combining many tricks can yield to substantial improvements .
obviously there is much more information in the sequence that immediately precedes the word to predict than just the identity of the previous couple of words .
there are at least two characteristics in this approach which beg to be improved upon , and that we
a neural probabilistic language model
will focus on in this paper .
first , it is not taking into account contexts farther than 123 or 123 words , 123 second it is not taking into account the similarity between words .
for example , having seen the sentence the cat is walking in the bedroom in the training corpus should help us gener - alize to make the sentence a dog was running in a room almost as likely , simply because dog and cat ( resp .
the and a , room and bedroom , etc . . . ) have similar semantic and
there are many approaches that have been proposed to address these two issues , and we will briey explain in section 123 the relations between the approach proposed here and some of these earlier approaches .
we will rst discuss what is the basic idea of the proposed approach .
a more formal presentation will follow in section 123 , using an implementation of these ideas that relies on shared - parameter multi - layer neural networks .
another contribution of this paper concerns the challenge of training such very large neural networks ( with millions of parameters ) for very large data sets ( with millions or tens of millions of examples ) .
finally , an important contribution of this paper is to show that training such large - scale model is expensive but feasible , scales to large contexts , and yields good comparative results ( section 123 ) .
many operations in this paper are in matrix notation , with lower case v denoting a column vector
its transpose , a j the j - th row of a matrix a , and x . y = x
123 fighting the curse of dimensionality with distributed representations
in a nutshell , the idea of the proposed approach can be summarized as follows :
associate with each word in the vocabulary a distributed word feature vector ( a real -
valued vector in rm ) ,
express the joint probability function of word sequences in terms of the feature vectors
of these words in the sequence , and
learn simultaneously the word feature vectors and the parameters of that probability
the feature vector represents different aspects of the word : each word is associated with a point in a vector space .
the number of features ( e . g .
m =123 , 123 or 123 in the experiments ) is much smaller than the size of the vocabulary ( e . g .
123 , 123 ) .
the probability function is expressed as a product of conditional probabilities of the next word given the previous ones , ( e . g .
using a multi - layer neural network to predict the next word given the previous ones , in the experiments ) .
this function has parameters that can be iteratively tuned in order to maximize the log - likelihood of the training data or a regularized criterion , e . g .
by adding a weight decay penalty . 123 the feature vectors associated with each word are learned , but they could be initialized using prior knowledge of semantic features .
why does it work ? in the previous example , if we knew that dog and cat played simi - lar roles ( semantically and syntactically ) , and similarly for ( the , a ) , ( bedroom , room ) , ( is , was ) ,
n - grams with n up to 123 ( i . e .
123 words of context ) have been reported , though , but due to data scarcity , most predictions
are made with a much shorter context .
like in ridge regression , the squared norm of the parameters is penalized .
bengio , ducharme , vincent and jauvin
( running , walking ) , we could naturally generalize ( i . e .
transfer probability mass ) from
and likewise to
the cat is walking in the bedroom a dog was running in a room the cat is running in a room a dog is walking in a bedroom the dog was walking in the room
and many other combinations .
in the proposed model , it will so generalize because similar words are expected to have a similar feature vector , and because the probability function is a smooth function of these feature values , a small change in the features will induce a small change in the probability .
therefore , the presence of only one of the above sentences in the training data will in - crease the probability , not only of that sentence , but also of its combinatorial number of neighbors in sentence space ( as represented by sequences of feature vectors ) .
123 relation to previous work
the idea of using neural networks to model high - dimensional discrete distributions has already been found useful to learn the joint probability of z123 ( cid : 123 ) ( cid : 123 ) ( cid : 123 ) zn , a set of random variables where each is possibly of a different nature ( bengio and bengio , 123a , b ) .
in that model , the joint probability is decomposed as a product of conditional probabilities
p ( z123 = z123 , ( cid : 123 ) ( cid : 123 ) ( cid : 123 ) , zn = zn ) = ( cid : 123 )
p ( zi = zijgi ( zi123 = zi123 , zi123 = zi123 , ( cid : 123 ) ( cid : 123 ) ( cid : 123 ) , z123 = z123 ) ) ,
where g ( . ) is a function represented by a neural network with a special left - to - right architecture , with the i - th output block gi ( ) computing parameters for expressing the conditional distribution of zi given the value of the previous zs , in some arbitrary order .
experiments on four uci data sets show this approach to work comparatively very well ( bengio and bengio , 123a , b ) .
here we must deal with data of variable length , like sentences , so the above approach must be adapted .
another important difference is that here , all the zi ( word at i - th position ) , refer to the same type of object ( a word ) .
the model proposed here therefore introduces a sharing of parameters across time the same gi is used across time that is , and across input words at different positions .
it is a successful large - scale application of the same idea , along with the ( old ) idea of learning a distributed representation for symbolic data , that was advocated in the early days of connectionism ( hinton , 123 , elman , 123 ) .
more recently , hintons approach was improved and successfully demonstrated on learning several symbolic relations ( paccanaro and hinton , 123 ) .
the idea of using neural networks for language modeling is not new either ( e . g .
miikkulainen and dyer , 123 ) .
in contrast , here we push this idea to a large scale , and concentrate on learning a statistical model of the distribution of word sequences , rather than learning the role of words in a sentence .
the approach proposed here is also related to previous proposals of character - based text compression using neural networks to predict the probability of the next character ( schmidhuber , 123 ) .
the idea of using a neural network for language modeling has also been independently proposed by xu and rudnicky ( 123 ) , although experiments are with networks without hidden units and a single input word , which limit the model to essentially capturing unigram and bigram statistics .
the idea of discovering some similarities between words to obtain generalization from training sequences to new sequences is not new .
for example , it is exploited in approaches that are based on learning a clustering of the words ( brown et al . , 123 , pereira et al . , 123 , niesler et al . , 123 , baker
a neural probabilistic language model
and mccallum , 123 ) : each word is associated deterministically or probabilistically with a discrete class , and words in the same class are similar in some respect .
in the model proposed here , instead of characterizing the similarity with a discrete random or deterministic variable ( which corresponds to a soft or hard partition of the set of words ) , we use a continuous real - vector for each word , i . e .
a learned distributed feature vector , to represent similarity between words .
the experimental comparisons in this paper include results obtained with class - based n - grams ( brown et al . , 123 , ney and kneser , 123 , niesler et al . , 123 ) .
the idea of using a vector - space representation for words has been well exploited in the area of information retrieval ( for example see work by schutze , 123 ) , where feature vectors for words are learned on the basis of their probability of co - occurring in the same documents ( latent semantic indexing , see deerwester et al . , 123 ) .
an important difference is that here we look for a repre - sentation for words that is helpful in representing compactly the probability distribution of word sequences from natural language text .
experiments suggest that learning jointly the representation ( word features ) and the model is very useful .
we tried ( unsuccessfully ) using as xed word features for each word w the rst principal components of the co - occurrence frequencies of w with the words occurring in text around the occurrence of w .
this is similar to what has been done with documents for information retrieval with lsi .
the idea of using a continuous representation for words has how - ever been exploited successfully by bellegarda ( 123 ) in the context of an n - gram based statistical language model , using lsi to dynamically identify the topic of discourse .
the idea of a vector - space representation for symbols in the context of neural networks has also ( e . g .
riis and krogh , 123 ) for
previously been framed in terms of a parameter sharing layer , secondary structure prediction , and for text - to - speech mapping ( jensen and riis , 123 ) .
a neural model the training set is a sequence w123 ( cid : 123 ) ( cid : 123 ) ( cid : 123 ) wt of words wt 123 v , where the vocabulary v is a large but nite set .
the objective is to learn a good model f ( wt , ( cid : 123 ) ( cid : 123 ) ( cid : 123 ) , wtn+123 ) = p ( wtjwt123 ) , in the sense that it gives high out - of - sample likelihood .
below , we report the geometric average of 123 / p ( wtjwt123 also known as perplexity , which is also the exponential of the average negative log - likelihood .
the i=123 f ( i , wt123 , ( cid : 123 ) ( cid : 123 ) ( cid : 123 ) , wtn+123 ) = 123 , with only constraint on the model is that for any choice of wt123 f > 123
by the product of these conditional probabilities , one obtains a model of the joint probability of sequences of words .
we decompose the function f ( wt , ( cid : 123 ) ( cid : 123 ) ( cid : 123 ) , wtn+123 ) = p ( wtjwt123 123
a mapping c from any element i of v to a real vector c ( i ) 123 rm .
it represents the distributed feature vectors associated with each word in the vocabulary .
in practice , c is represented by a jvj ( cid : 123 ) m matrix of free parameters .
) in two parts :
the probability function over words , expressed with c : a function g maps an input sequence of feature vectors for words in context , ( c ( wtn+123 ) , ( cid : 123 ) ( cid : 123 ) ( cid : 123 ) , c ( wt123 ) ) , to a conditional probability distribution over words in v for the next word wt .
the output of g is a vector whose i - th element estimates the probability p ( wt = ijwt123
) as in figure 123
f ( i , wt123 , ( cid : 123 ) ( cid : 123 ) ( cid : 123 ) , wtn+123 ) = g ( i , c ( wt123 ) , ( cid : 123 ) ( cid : 123 ) ( cid : 123 ) , c ( wtn+123 ) )
the function f is a composition of these two mappings ( c and g ) , with c being shared across all the words in the context .
with each of these two parts are associated some parameters
bengio , ducharme , vincent and jauvin
i - th output = p ( wt = i j context )
most computation here
neural network and c ( i ) is the i - th word feature vector .
figure 123 : neural architecture : f ( i , wt123 , ( cid : 123 ) ( cid : 123 ) ( cid : 123 ) , wtn+123 ) = g ( i , c ( wt123 ) , ( cid : 123 ) ( cid : 123 ) ( cid : 123 ) , c ( wtn+123 ) ) where g is the parameters of the mapping c are simply the feature vectors themselves , represented by a jvj ( cid : 123 ) m matrix c whose row i is the feature vector c ( i ) for word i .
the function g may be implemented by a feed - forward or recurrent neural network or another parametrized function , with parameters w overall parameter set is q = ( c , w ) .
training is achieved by looking for q
that maximizes the training corpus penalized log - likelihood :
log f ( wt , wt123 , ( cid : 123 ) ( cid : 123 ) ( cid : 123 ) , wtn+123;q ) + r ( q ) ,
where r ( q ) is a regularization term .
for example , in our experiments , r is a weight decay penalty applied only to the weights of the neural network and to the c matrix , not to the biases . 123
in the above model , the number of free parameters only scales linearly with v , the number of words in the vocabulary .
it also only scales linearly with the order n : the scaling factor could be reduced to sub - linear if more sharing structure were introduced , e . g .
using a time - delay neural network or a recurrent neural network ( or a combination of both ) .
in most experiments below , the neural network has one hidden layer beyond the word features mapping , and optionally , direct connections from the word features to the output .
therefore there are really two hidden layers : the shared word features layer c , which has no non - linearity ( it would not add anything useful ) , and the ordinary hyperbolic tangent hidden layer .
more precisely , the neural network computes the following function , with a softmax output layer , which guarantees positive probabilities summing to 123 :
the biases are the additive parameters of the neural network , such as b and d in equation 123 below .
p ( wtjwt123 , ( cid : 123 ) ( cid : 123 ) ( cid : 123 ) wtn+123 ) = eywt
a neural probabilistic language model
the yi are the unnormalized log - probabilities for each output word i , computed as follows , with parameters b , w , u , d and h :
y = b +w x +u tanh ( d + hx )
where the hyperbolic tangent tanh is applied element by element , w is optionally zero ( no direct connections ) , and x is the word features layer activation vector , which is the concatenation of the input word features from the matrix c :
x = ( c ( wt123 ) , c ( wt123 ) , ( cid : 123 ) ( cid : 123 ) ( cid : 123 ) , c ( wtn+123 ) ) .
let h be the number of hidden units , and m the number of features associated with each word .
when no direct connections from word features to outputs are desired , the matrix w is set to 123
the free parameters of the model are the output biases b ( with jvj elements ) , the hidden layer biases d ( with h elements ) , the hidden - to - output weights u ( a jvj ( cid : 123 ) h matrix ) , the word features to output weights w ( a jvj ( cid : 123 ) ( n 123 ) m matrix ) , the hidden layer weights h ( a h ( cid : 123 ) ( n 123 ) m matrix ) , and the word features c ( a jvj ( cid : 123 ) m matrix ) :
q = ( b , d , w , u , h , c ) .
the number of free parameters is jvj ( 123 + nm + h ) + h ( 123 + ( n 123 ) m ) .
the dominating factor is jvj ( nm + h ) .
note that in theory , if there is a weight decay on the weights w and h but not on c , then w and h could converge towards zero while c would blow up .
in practice we did not observe such behavior when training with stochastic gradient ascent .
stochastic gradient ascent on the neural network consists in performing the following iterative
update after presenting the t - th word of the training corpus :
q q + e
log p ( wtjwt123 , ( cid : 123 ) ( cid : 123 ) ( cid : 123 ) wtn+123 )
is the learning rate .
note that a large fraction of the parameters needs not be updated or visited after each example : the word features c ( j ) of all words j that do not occur in the input
mixture of models .
in our experiments ( see section 123 ) we have found improved performance by combining the probability predictions of the neural network with those of an interpolated trigram model , either with a simple xed weight of 123 , a learned weight ( maximum likelihood on the validation set ) or a set of weights that are conditional on the frequency of the context ( using the same procedure that combines trigram , bigram , and unigram in the interpolated trigram , which is a
parallel implementation
although the number of parameters scales nicely , i . e .
linearly with the size of the input window and linearly with the size of the vocabulary , the amount of computation required for obtaining the output probabilities is much greater than that required from n - gram models .
the main reason is that with n - gram models , obtaining a particular p ( wtjwt123 , .
, wtn+123 ) does not require the computation of the probabilities for all the words in the vocabulary , because of the easy normalization ( performed when training the model ) enjoyed by the linear combinations of relative frequencies .
the main computational bottleneck with the neural implementation is the computation of the activations of the output layer .
bengio , ducharme , vincent and jauvin
running the model ( both training and testing ) on a parallel computer is a way to reduce compu - tation time .
we have explored parallelization on two types of platforms : shared - memory processor machines and linux clusters with a fast network .
123 data - parallel processing
in the case of a shared - memory processor , parallelization is easily achieved , thanks to the very low communication overhead between processors , through the shared memory .
in that case we have chosen a data - parallel implementation in which each processor works on a different subset of the data .
each processor computes the gradient for its examples , and performs stochastic gradient updates on the parameters of the model , which are simply stored in a shared - memory area .
our rst implementation was extremely slow and relied on synchronization commands to make sure that each processor would not write at the same time as another one in one of the above parameter subsets .
most of the cycles of each processor were spent waiting for another processor to release a lock on the write access to the parameters .
instead we have chosen an asynchronous implementation where each processor can write at any time in the shared - memory area .
sometimes , part of an update on the parameter vector by one of the processors is lost , being overwritten by the update of another processor , and this introduces a bit of noise in the parameter updates .
however , this noise seems to be very small and did not apparently slow down training .
unfortunately , large shared - memory parallel computers are very expensive and their processor speed tends to lag behind mainstream cpus that can be connected in clusters .
we have thus been able to obtain much faster training on fast network clusters .
123 parameter - parallel processing
if the parallel computer is a network of cpus , we generally cant afford to frequently exchange all the parameters among the processors , because that represents tens of megabytes ( almost 123 megabytes in the case of our largest network ) , which would take too much time through a local network .
instead we have chosen to parallelize across the parameters , in particular the parame - ters of the output units , because that is where the vast majority of the computation is taking place , in our architecture .
each cpu is responsible for the computation of the unnormalized probability for a subset of the outputs , and performs the updates for the corresponding output unit parame - ters ( weights going into that unit ) .
this strategy allowed us to perform a parallelized stochastic gradient ascent with a negligible communication overhead .
the cpus essentially need to commu - nicate two informations : ( 123 ) the normalization factor of the output softmax , and ( 123 ) the gradients on the hidden layer ( denoted a below ) and word feature layer ( denoted x ) .
all the cpus duplicate the computations that precede the computation of the output units activations , i . e . , the selection of word features and the computation of the hidden layer activation a , as well as the corresponding back - propagation and update steps .
however , these computations are a negligible part of the total computation for our networks .
for example , consider the following architecture used in the experiments on the ap ( associated press ) news data : the vocabulary size is jvj = 123 , 123 , the number of hidden units is h = 123 , the order of the model is n = 123 , the number of word features is m = 123
the total number of numerical opera - tions to process a single training example is approximately jvj ( 123+nm+h ) +h ( 123+nm ) +nm ( where the terms correspond respectively to the computations of the output units , hidden units , and word
a neural probabilistic language model
feature units ) .
in this example the fraction of the overall computation required for computing the weighted sums of the output units is therefore approximately 123% .
this calculation is approximate because the actual cpu time associated with different operations differ , but it shows that it is generally advantageous to parallelize the output units com - putation .
the fact that all cpus will duplicate a very small fraction of the computations is not going to hurt the total computation time for the level of parallelization sought here , i . e .
of a few dozen if the number of hidden units was large , parallelizing their computation would also become protable , but we did not investigate that approach in our experiments .
the implementation of this strategy was done on a cluster of 123 ghz clock - speed athlon pro - cessors ( 123 x 123 cpus ) connected through a myrinet network ( a low - latency gigabit local area net - work ) , using the mpi ( message passing interface ) library ( dongarra et al . , 123 ) for the paralleliza - tion routines .
the parallelization algorithm is sketched below , for a single example ( wtn+123 , ( cid : 123 ) ( cid : 123 ) ( cid : 123 ) , wt ) , executed in parallel by cpu i in a cluster of m processors .
cpu i ( i ranging from 123 to m 123 ) is responsible of a block of output units starting at number starti = i ( cid : 123 ) djvj / me , the block being of length min ( djvj / me , jvj starti ) .
computation for processor i , example t
forward phase
( a ) perform forward computation for the word features layer :
( c ) perform forward computation for output units in the i - th block :
( b ) perform forward computation for the hidden layer :
x = ( x ( 123 ) , x ( 123 ) , ( cid : 123 ) ( cid : 123 ) ( cid : 123 ) , x ( n 123 ) ) o d + hx loop over j in the i - th block i .
y j b j + a . u j ii .
if ( direct connections ) y j y j + x . wj iii .
p j ey j iv .
si si + p j
( d ) compute and share s = ( cid : 123 )
i si among the processors .
this can easily be achieved with an
( e ) normalize the probabilities :
mpi allreduce operation , which can efciently compute and share this sum .
loop over j in the i - th block , p j p j / s .
( f ) update the log - likelihood .
if wt falls in the block of cpu i > 123 , then cpu i sends pwt to
cpu 123 computes l = log pwt and keeps track of the total log - likelihood .
backward / update phase , with learning rate e .
( a ) perform backward gradient computation for output units in the i - th block :
clear gradient vectors l loop over j in the i - th block
a and l
bengio , ducharme , vincent and jauvin
b j b j + e
if ( direct connections ) l if ( direct connections ) wj wj + e u j u j + e
( b ) sum and share l
x and l
a across processors .
this can easily be achieved with an mpi
( c ) back - propagate through and update hidden layer weights :
loop over k between 123 and h ,
d d + e h h + e
( d ) update word feature vectors for the input words :
loop over k between 123 and n 123
c ( wtk ) c ( wtk ) + e
x ( k ) is the k - th block ( of length m ) of the vector l
the weight decay regularization was not shown in the above implementation but can easily be put in ( by subtracting the weight decay factor times the learning rate times the value of the parameter , from each parameter , at each update ) .
note that parameter updates are done directly rather than through a parameter gradient vector , to increase speed , a limiting factor in computation speed being the access to memory , in our experiments .
there could be a numerical problem in the computation of the exponentials in the forward phase , whereby all the p j could be numerically zero , or one of them could be too large for computing the exponential ( step 123 ( c ) ii above ) .
to avoid this problem , the usual solution is to subtract the maximum of the y js before taking the exponentials in the softmax .
thus we have added an extra allreduce operation to share among the m processors the maximum of the y js , before computing the exponentials in p j .
let qi be the maximum of the y js in block i .
then the overall maximum q = maxi qi is collectively computed and shared among the m processors .
the exponentials are then computed as follows : p j ey jq ( instead of step 123 ( c ) ii ) to guarantee that at least one of the p js will be numerically non - zero , and the maximum of the exponentials argument is 123
by comparing clock time of the parallel version with clock time on a single processor , we found that the communication overhead was only 123 / 123th of the total time ( for one training epoch ) : thus we get an almost perfect speed - up through parallelization , using this algorithm on a fast network .
on clusters with a slow network , it might be possible to still obtain an efcient parallelization by performing the communications every k examples ( a mini - batch ) rather than for each example .
this requires storing k versions of the activities and gradients of the neural network in each pro - cessor .
after the forward phase on the k examples , the probability sums must be shared among the
a neural probabilistic language model
processors .
then the k backward phases are initiated , to obtain the k partial gradient vectors l x .
after exchanging these gradient vectors among the processors , each processor can complete the backward phase and update parameters .
this method mainly saves time because of the savings in network communication latency ( the amount of data transferred is the same ) .
it may lose in con - vergence time if k is too large , for the same reason that batch gradient descent is generally much slower than stochastic gradient descent ( lecun et al . , 123 ) .
experimental results
comparative experiments were performed on the brown corpus which is a stream of 123 , 123 , 123 words , from a large variety of english texts and books .
the rst 123 , 123 words were used for training , the following 123 , 123 for validation ( model selection , weight decay , early stopping ) and the remaining 123 , 123 for testing .
the number of different words is 123 , 123 ( including punctuation , distinguishing between upper and lower case , and including the syntactical marks used to separate texts and paragraphs ) .
rare words with frequency ( cid : 123 ) 123 were merged into a single symbol , reducing the vocabulary size to jvj = 123 , 123
an experiment was also run on text from the associated press ( ap ) news from 123 and 123
the training set is a stream of about 123 million ( 123 , 123 , 123 ) words , the validation set is a stream of about 123 million ( 123 , 123 ) words , and the test set is also a stream of about 123 million ( 123 , 123 ) words .
the original data has 123 , 123 different words ( including punctuation ) , which was reduced to jvj = 123 by keeping only the most frequent words ( and keeping punctuation ) , mapping upper case to lower case , mapping numeric forms to special symbols , mapping rare words to a special symbol and mapping proper nouns to another special symbol .
123 ( after a few trials with a tiny data set ) , and gradually decreased according to the following schedule : e t represents the number of parameter updates done and r is a decrease factor that was heuristically chosen to be r = 123
for training the neural networks , the initial learning rate was set to e o = 123
t = e o
123 n - gram models
the rst benchmark against which the neural network was compared is an interpolated or smoothed trigram model ( jelinek and mercer , 123 ) .
let qt = l ( f req ( wt123 , wt123 ) ) represents the discretized frequency of occurrence of the input context ( wt123 , wt123 ) . 123 then the conditional probability esti - mates have the form of a conditional mixture :
p ( wtjwt123 , wt123 ) = a 123 ( qt ) p123 + a 123 ( qt ) p123 ( wt ) + a 123 ( qt ) p123 ( wtjwt123 ) + a 123 ( qt ) p123 ( wtjwt123 , wt123 )
i ( qt ) ( cid : 123 ) 123 , ( cid : 123 )
with conditional weights a i ( qt ) = 123
the base predictors are the following : p123 = 123 / jvj , p123 ( i ) is a unigram ( relative frequency of word i in the training set ) , p123 ( ij j ) is the bigram ( relative frequency of word i when the previous word is j ) , and p123 ( ij j , k ) is the trigram ( relative frequency of word i when the previous 123 words are j and k ) .
the motivation is that when the frequency of ( wt123 , wt123 ) is large , p123 is most reliable , whereas when it is lower , the lower - order statistics of p123 , p123 , or even p123 are more reliable .
there is a different set of mixture weights a of the discrete values of qt ( which are context frequency bins ) .
they can be easily estimated with 123
we used l ( x ) = dlog ( ( 123 + x ) / t ) e where f req ( wt123 , wt123 ) is the frequency of occurrence of the input context and
t is the size of the training corpus .
bengio , ducharme , vincent and jauvin
the em algorithm in about 123 iterations , on a set of data ( the validation set ) not used for estimating the unigram , bigram and trigram relative frequencies .
the interpolated n - gram was used to form a mixture with the mlps since they appear to make errors in very different ways .
comparisons were also made with other state - of - the - art n - gram models : back - off n - gram mod - els with the modied kneser - ney algorithm ( kneser and ney , 123 , chen and goodman . , 123 ) , as well as class - based n - gram models ( brown et al . , 123 , ney and kneser , 123 , niesler et al . , 123 ) .
the validation set was used to choose the order of the n - gram and the number of word classes for the class - based models .
we used the implementation of these algorithms in the sri language mod - eling toolkit , described by stolcke ( 123 ) and in www . speech . sri . com / projects / srilm / .
they were used for computing the back - off models perplexities reported below , noting that we did not give a special status to end - of - sentence tokens in the accounting of the log - likelihood , just as for our neural network perplexity .
all tokens ( words and punctuation ) were treated the same in averaging the log - likelihood ( hence in obtaining the perplexity ) .
below are measures of test set perplexity ( geometric average of 123 / p ( wtjwt123 ) ) for different models p .
apparent convergence of the stochastic gradient ascent procedure was obtained after around 123 to 123 epochs for the brown corpus .
on the ap news corpus we were not able to see signs of over - tting ( on the validation set ) , possibly because we ran only 123 epochs ( over 123 weeks using 123 cpus ) .
early stopping on the validation set was used , but was necessary only in our brown experiments .
a weight decay penalty of 123 was used in the apnews experiments ( selected by a few trials , based on validation set perplexity ) .
table 123 summarizes the results obtained on the brown corpus .
all the back - off models of the table are modied kneser - ney n - grams , which worked signicantly better than standard back - off models .
when m is specied for a back - off model in the table , a class - based n - gram is used ( m is the number of word classes ) .
random initialization of the word features was done ( similarly to initialization of neural network weights ) , but we suspect that better results might be obtained with a
123 was used in the brown experiments and a weight decay of 123
the main result is that signicantly better results can be obtained when using the neural net - work , in comparison with the best of the n - grams , with a test perplexity difference of about 123% on brown and about 123% on ap news , when taking the mlp versus the n - gram that worked best on the validation set .
the table also suggests that the neural network was able to take advantage of more context ( on brown , going from 123 words of context to 123 words brought improvements to the neural network , not to the n - grams ) .
it also shows that the hidden units are useful ( mlp123 vs mlp123 and mlp123 vs mlp123 ) , and that mixing the output probabilities of the neural network with the interpo - lated trigram always helps to reduce perplexity .
the fact that simple averaging helps suggests that the neural network and the trigram make errors ( i . e .
low probability given to an observed word ) in different places .
the results do not allow to say whether the direct connections from input to output are useful or not , but suggest that on a smaller corpus at least , better generalization can be obtained without the direct input - to - output connections , at the cost of longer training : without direct connec - tions the network took twice as much time to converge ( 123 epochs instead of 123 ) , albeit to a slightly lower perplexity .
a reasonable interpretation is that direct input - to - output connections provide a bit more capacity and faster learning of the linear part of the mapping from word features to log -
a neural probabilistic language model
h m direct mix
table 123 : comparative results on the brown corpus .
the deleted interpolation trigram has a test per - plexity that is 123% above that of the neural network with the lowest validation perplexity .
the difference is 123% in the case of the best n - gram ( a class - based model with 123 word classes ) .
n : order of the model .
c : number of word classes in class - based n - grams .
h : number of hidden units .
m : number of word features for mlps , number of classes for class - based n - grams .
direct : whether there are direct connections from word features to outputs .
mix : whether the output probabilities of the neural network are mixed with the output of the trigram ( with a weight of 123 on each ) .
the last three columns give perplexity on the training , validation and test sets .
probabilities .
on the other hand , without those connections the hidden units form a tight bottleneck which might force better generalization .
table 123 gives similar results on the larger corpus ( ap news ) , albeit with a smaller difference in perplexity ( 123% ) .
only 123 epochs were performed ( in approximately three weeks with 123 cpus ) .
the class - based model did not appear to help the n - gram models in this case , but the high - order modied kneser - ney back - off model gave the best results among the n - gram models .
extensions and future work
in this section , we describe extensions to the model described above , and directions for future work .
bengio , ducharme , vincent and jauvin
m direct mix
back - off kn 123 back - off kn 123 back - off kn 123
table 123 : comparative results on the ap news corpus .
see the previous table for the column labels .
123 an energy minimization network
a variant of the above neural network can be interpreted as an energy minimization model following hintons recent work on products of experts ( hinton , 123 ) .
in the neural network described in the previous sections the distributed word features are used only for the input words and not for the output word ( next word ) .
furthermore , a very large number of parameters ( the majority ) are expanded in the output layer : the semantic or syntactic similarities between output words are not exploited .
in the variant described here , the output word is also represented by its feature vector .
the network takes in input a sub - sequence of words ( mapped to their feature vectors ) and outputs an energy function e which is low when the words form a likely sub - sequence , high when it is unlikely .
for example , the network outputs an energy function e ( wtn+123 , ( cid : 123 ) ( cid : 123 ) ( cid : 123 ) , wt ) = v . tanh ( d + hx ) +
where b is the vector of biases ( which correspond to unconditional probabilities ) , d is the vector of hidden units biases , v is the output weight vector , and h is the hidden layer weight matrix , and unlike in the previous model , input and output words contribute to x :
x = ( c ( wt ) , c ( wt123 ) , c ( wt123 ) , ( cid : 123 ) ( cid : 123 ) ( cid : 123 ) , c ( wtn+123 ) .
the energy function e ( wtn+123 , ( cid : 123 ) ( cid : 123 ) ( cid : 123 ) , wt ) can be interpreted as an unnormalized log - probability for the joint occurrence of ( wtn+123 , ( cid : 123 ) ( cid : 123 ) ( cid : 123 ) , wt ) .
to obtain a conditional probability p ( wtjwt123 ) it is enough ( but costly ) to normalize over the possible values of wt , as follows :
p ( wtjwt123 , ( cid : 123 ) ( cid : 123 ) ( cid : 123 ) , wtn+123 ) = e
e ( wtn+123 , ( cid : 123 ) ( cid : 123 ) ( cid : 123 ) , wt ) i ee ( wtn+123 , ( cid : 123 ) ( cid : 123 ) ( cid : 123 ) , wt123 , i )
note that the total amount of computation is comparable to the architecture presented earlier , and the number of parameters can also be matched if the v parameter is indexed by the identity of the target word ( wt ) .
note that only bwt remains after the above softmax normalization ( any linear function of the wti for i > 123 is canceled by the softmax normalization ) .
as before , the parameters of the model can be tuned by stochastic gradient ascent on log p ( wtjwt123 , ( cid : 123 ) ( cid : 123 ) ( cid : 123 ) , wtn+123 ) , using similar probability of a sub - sequence ( wtn+123 , ( cid : 123 ) ( cid : 123 ) ( cid : 123 ) , wt ) is proportional to the exponential of a sum of terms associated with each hidden unit j , v j tanh ( d j + h jx ) .
note that because we have chosen to de - compose the probability of a whole sequence in terms of conditional probabilities for each element ,
in the products - of - experts framework , the hidden units can be seen as the experts :
a neural probabilistic language model
the computation of the gradient is tractable .
this is not the case for example with products - of - hmms ( brown and hinton , 123 ) , in which the product is over experts that view the whole se - quence , and which can be trained with approximate gradient algorithms such as the contrastive divergence algorithm ( brown and hinton , 123 ) .
note also that this architecture and the products - of - experts formulation can be seen as extensions of the very successful maximum entropy mod - els ( berger et al . , 123 ) , but where the basis functions ( or features , here the hidden units acti - vations ) are learned by penalized maximum likelihood at the same time as the parameters of the features linear combination , instead of being learned in an outer loop , with greedy feature subset
we have implemented and experimented with the above architecture , and have developed a speed - up technique for the neural network training , based on importance sampling and yielding a 123 - fold speed - up ( bengio and sencal , 123 ) .
out - of - vocabulary words .
an advantage of this architecture over the previous one is that it can easily deal with out - of - vocabulary words ( and even assign them a probability ! ) .
the main idea is to rst guess an initial feature vector for such a word , by taking a weighted convex combination of the feature vectors of other words that could have occurred in the same context , with weights propor - tional to their conditional probability .
suppose that the network assigned a probability p ( ijwt123 to words i 123 v in context wt123 tn+123 , and that in this context we observe a new word j 123 v .
we initialize the feature vector c ( j ) for j as follows : c ( j ) ( cid : 123 ) ) .
we can then incorporate j in v and re - compute probabilities for this slightly larger set ( which only requires a renormalization for all the words , except for word i , which requires a pass through the neural network ) .
this feature vector c ( i ) can then be used in the input context part when we try to predict the probabilities of words that follow word i .
i123v c ( i ) p ( ijwt123
123 other future work
there are still many challenges ahead to follow - up on this work .
in the short term , methods to speed - up training and recognition need to be designed and evaluated .
in the longer term , more ways to generalize should be introduced , in addition to the two main ways exploited here .
here are some ideas that we intend to explore :
decomposing the network in sub - networks , for example using a clustering of the words .
training many smaller networks should be easier and faster .
representing the conditional probability with a tree structure where a neural network is ap - plied at each node , and each node represents the probability of a word class given the context and the leaves represent the probability of words given the context .
this type of representation has the potential to reduce computation time by a factor jvj / logjvj ( see bengio , 123 ) .
propagating gradients only from a subset of the output words .
it could be the words that are conditionally most likely ( based on a faster model such as a trigram , see schwenk and gauvain , 123 , for an application of this idea ) , or it could be a subset of the words for which the trigram has been found to perform poorly .
if the language model is coupled to a speech recognizer , then only the scores ( unnormalized probabilities ) of the acoustically ambiguous words need to be computed .
see also bengio and sencal ( 123 ) for a new accelerated training method using importance sampling to select the words .
bengio , ducharme , vincent and jauvin
introducing a - priori knowledge .
several forms of such knowledge could be introduced , such as : semantic information ( e . g . , from wordnet , see fellbaum , 123 ) , low - level grammatical information ( e . g . , using parts - of - speech ) , and high - level grammatical information , e . g . , cou - pling the model to a stochastic grammar , as suggested in bengio ( 123 ) .
the effect of longer term context could be captured by introducing more structure and parameter sharing in the neural network , e . g .
using time - delay or recurrent neural networks .
in such a multi - layered network the computation that has been performed for small groups of consecutive words does not need to be redone when the network input window is shifted .
similarly , one could use a recurrent network to capture potentially even longer term information about the subject of the
interpreting ( and possibly using ) the word feature representation learned by the neural net - work .
a simple rst step would start with m = 123 features , which can be more easily dis - played .
we believe that more meaningful representations will require large training corpora , especially for larger values of m .
polysemous words are probably not well served by the model presented here , which assigns to each word a single point in a continuous semantic space .
we are investigating extensions of this model in which each word is associated with multiple points in that space , each associated with the different senses of the word .
the experiments on two corpora , one with more than a million examples , and a larger one with above 123 million words , have shown that the proposed approach yields much better perplexity than a state - of - the - art method , the smoothed trigram , with differences between 123 and 123% in perplexity .
we believe that the main reason for these improvements is that the proposed approach allows to take advantage of the learned distributed representation to ght the curse of dimensionality with its own weapons : each training sentence informs the model about a combinatorial number of other
there is probably much more to be done to improve the model , at the level of architecture , computational efciency , and taking advantage of prior knowledge .
an important priority of future research should be to improve speed - up techniques123 as well as ways to increase capacity without increasing training time too much ( to deal with corpora with hundreds of millions of words or more ) .
a simple idea to take advantage of temporal structure and extend the size of the input window to include possibly a whole paragraph ( without increasing too much the number of parameters or computation time ) is to use a time - delay and possibly recurrent neural networks .
evaluations of the type of models presented here in applicative contexts would also be useful , but see work already done by schwenk and gauvain ( 123 ) for improvements in speech recognition word error rate .
more generally , the work presented here opens the door to improvements in statistical language models brought by replacing tables of conditional probabilities by more compact and smoother representations based on distributed representations that can accommodate far more conditioning variables .
whereas much effort has been spent in statistical language models ( e . g .
stochastic gram - mars ) to restrict or summarize the conditioning variables in order to avoid overtting , the type of
see work by bengio and sencal ( 123 ) for a 123 - fold speed - up technique .
a neural probabilistic language model
models described here shifts the difculty elsewhere : many more computations are required , but computation and memory requirements scale linearly , not exponentially with the number of condi -
the authors would like to thank lon bottou , yann le cun and geoffrey hinton for useful discus - sions .
this research was made possible by funding from the nserc granting agency , as well as the mitacs and iris networks .
