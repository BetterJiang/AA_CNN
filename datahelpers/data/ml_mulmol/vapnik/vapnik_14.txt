abstract .
the problem of automatically tuning multiple parameters for pattern recognition support vector machines ( svms ) is considered .
this is done by minimizing some estimates of the generalization error of svms using a gradient descent algorithm over the set of parameters .
usual methods for choosing parameters , based on exhaustive search become intractable as soon as the number of parameters exceeds two .
some experimental results assess the feasibility of our approach for a large number of parameters ( more than 123 ) and demonstrate an improvement of generalization performance .
support vector machines , kernel selection , leave - one - out procedure , gradient descent , feature
in the problem of supervised learning , one takes a set of input - output pairs z = ( ( x123 , y123 ) , .
, ( x ( cid : 123 ) , y ( cid : 123 ) ) ) and attempts to construct a classier function f that maps input vectors x x onto labels y y .
we are interested here in pattern recognition or classication , that is the case where the set of labels is simply y = ( 123 , 123 ) .
the goal is to nd a f f which minimizes the error ( f ( x ) ( cid : 123 ) = y ) on future examples .
learning algorithms usually depend on parameters which control the size of the class f or the way the search is conducted in f .
several techniques exist for performing the selection of these parameters .
the idea is to nd the parameters that minimize the generalization error of the algorithm at hand .
this error can be estimated either via testing on some data which has not been used for learning ( hold - out testing or cross - validation techniques ) or via a bound given by theoretical analysis .
tuning multiple parameters .
usually there are multiple parameters to tune at the same time and moreover , the estimates of the error are not explicit functions of these parameters , so
chapelle et al .
that the naive strategy which is exhaustive search in the parameter space becomes intractable since it would correspond to running the algorithm on every possible value of the parameter vector ( up to some discretization ) .
we propose here a methodology for automatically tuning multiple parameters for the support vector machines ( svms ) which takes advantage of the specic properties of this algorithm .
the svm algorithm .
support vector machines ( svms ) realize the following idea : map a n - dimensional input vector x rn 123 into a high dimensional ( possibly innite dimensional ) feature spaceh by and construct an optimal separating hyperplane in this space .
different mappings construct different svms .
when the training data is separable , the optimal hyperplane is the one with the maximal distance ( in h space ) between the hyperplane and the closest image ( xi ) of the vector xi from the training data .
for non - separable training data a generalization of this concept is
suppose that the maximal distance is equal to and that the images ( x123 ) , .
, ( x ( cid : 123 ) ) of the training vectors x123 , .
, x ( cid : 123 ) are within a sphere of radius r .
then the following theorem holds true ( vapnik & chapelle , 123 ) .
theorem 123
given a training set z = ( ( x123 , y123 ) , .
, ( x ( cid : 123 ) , y ( cid : 123 ) ) ) of size ( cid : 123 ) , a feature space h and a hyperplane ( w , b ) , the margin ( w , b , z ) and the radius r ( z ) are dened by
yi ( w ( xi ) + b )
( w , b , z ) = min ( xi , yi ) z r ( z ) = min
( cid : 123 ) ( xi ) + a ( cid : 123 )
the maximum margin algorithm l ( cid : 123 ) : ( x y ) ( cid : 123 ) h r takes as input a training set of size ( cid : 123 ) and returns a hyperplane in feature space such that the margin ( w , b , z ) is maximized .
note that assuming the training set separable means that > 123
under this assumption , for all probability measures p underlying the data z , the expectation of the misclassication
perr ( w , b ) = p ( sign ( w ( x ) + b ) ( cid : 123 ) = y )
has the bound
e ( perr ( l ( cid : 123 ) 123 ( z ) ) ) 123
123 ( l ( z ) , z )
the expectation is taken over the random draw of a training set z of size ( cid : 123 ) 123 for the left hand side and size ( cid : 123 ) for the right hand side .
this theorem justies the idea of constructing a hyperplane that separates the data with a large margin : the larger the margin the better the performance of the constructed hyperplane .
choosing multiple parameters for support vector machines
note however that according to the theorem the average performance depends on the ratio e ( r123 / 123 ) and not simply on the large margin .
why multiple parameters ? the svm algorithm usually depends on several parameters .
one of them , denoted c , controls the tradeoff between margin maximization and error minimization .
other parameters appear in the non - linear mapping into feature space .
they are called kernel parameters .
for simplicity , we will use a classical trick that allows us to consider c as a kernel parameter , so that all parameters can be treated in a unied
it is widely acknowledged that a key factor in an svms performance is the choice of the kernel .
however , in practice , very few different types of kernels have been used due to the difculty of appropriately tuning the parameters .
we present here a technique that allows to deal with a large number of parameters and thus allows to use more complex kernels .
another potential advantage of being able to tune a large number of parameters is the possibility of rescaling the attributes .
indeed , when no a priori knowledge is available about the meaning of each of the attributes , the only choice is to use spherical kernels ( i . e .
give the same weight to each attribute ) .
but one may expect that there is a better choice for the shape of the kernel since many real - world database contain attributes of very different natures .
there may thus exist more appropriate scaling factors that give the right weight to the right feature .
for example , we will see how to use radial basis function kernels ( rbf ) with as many different scaling factors as input dimensions :
( xi zi ) 123
k ( x , z ) = exp
the usual approach is to consider = 123 = = n and to try to pick the best value for .
however , using the proposed method , we can choose automatically good values for the scaling factors i .
indeed , these factors are precisely parameters of the kernel .
moreover , we will demonstrate that the problem of feature selection can be addressed with the same framework since it corresponds to nding those attributes which can be rescaled with a zero factor without harming the generalization .
we thus see that tuning kernel parameters is something extremely useful and a procedure that allows to do this would be a versatile tool for various tasks such as nding the right shape of the kernel , feature selection , nding the right tradeoff between error and margin , etc .
all this gives a rationale for developing such techniques .
in summary , our goal is not only to nd the hyperplane which maximizes the margin but also the values of the mapping parameters that yield best generalization error .
to do so , we propose a minimax approach : maximize the margin over the hyperplane coefcients and minimize an estimate of the generalization error over the set of kernel parameters .
this last step is performed using a standard gradient descent approach .
what kind of error estimates .
we will consider several ways of assessing the generalization
chapelle et al .
validation error : this procedure requires a reduction of the amount of data used for learning in order to save some of it for validation .
moreover , the estimates have to be smoothed for proper gradient descent .
leave - one - out error estimates : this procedure gives an estimate of the expected general -
ization as an analytic function of the parameters .
we will examine how the accuracy of the estimates inuences the whole procedure of nding optimal parameters .
in particular we will show that what really matters is how variations of the estimates relate to variations of the test error rather than how their values are related .
outline .
the paper is organized as follows .
the next section introduces the basics of svms .
the different possible estimates of their generalization error are described in sections 123 and 123 explains how to smooth theses estimates .
then we introduce in section 123 a framework for minimizing those estimates by gradient descent .
section 123 deals with the computation of gradients of error estimates with respect to kernel parameters .
fi - nally , in sections 123 and 123 , we present experimental results of the method applied to a variety of databases in different contexts .
section 123 deals with nding the right penalization along with the right radius for a kernel and with nding the right shape of a kernel .
in section 123 we present results of applying our method to feature selection .
support vector learning
we introduce some standard notations for svms; for a complete description , see ( vapnik , 123 ) .
let ( ( xi , yi ) ) 123i ( cid : 123 ) be a set of training examples , xi rn which belong to a class labeled by yi ( 123 , 123 ) .
in the svm methodology , we map these vectors into a feature space using a kernel function k ( xi , x j ) that denes an inner product in this feature space .
here , we consider a kernel k depending on a set of parameters .
the decision function given by an svm is : f ( x ) = sign
i are obtained by maximizing the following functional :
i j yi y j k ( xi , x j )
i yi k ( xi , x ) + b
i = 123 , .
, ( cid : 123 ) .
where the coefcients 123
w ( ) = ( cid : 123 ) ( cid : 123 )
under the constraints i yi = 123
the coefcients 123 i dene a maximal margin hyperplane in a high - dimensional feature space where the data are mapped through a non - linear function such that ( xi ) ( x j ) = k ( xi , x j ) .
choosing multiple parameters for support vector machines
this formulation of the svm optimization problem is called the hard margin formulation since no training errors are allowed .
every training point satises the inequality yi f ( xi ) 123 and for points xi with corresponding i > 123 an equality is satised .
these points are called notice that one may require the separating hyperplane to pass through the origin by choosing a xed b = 123
this variant is called the hard margin svm without threshold .
in that case , the optimization problem remains the same as above except that the constraint
i yi = 123 disappears .
dealing with non - separability .
for the non - separable case , one needs to allow training errors which results in the so called soft margin svm algorithm ( cortes & vapnik , 123 ) .
it can be shown that soft margin svms with quadratic penalization of errors can be considered as a special case of the hard margin version with the modied kernel ( cortes & vapnik , 123; cristianini & shawe - taylor , 123 ) .
k k + 123
where i is the identity matrix and c a constant penalizing the training errors .
in the rest of the paper , we will focus on the hard margin svm and use ( 123 ) whenever we have to deal with non - separable data .
thus c will be considered just as another parameter of the kernel
estimating the performance of an svm
ideally we would like to choose the value of the kernel parameters that minimize the true risk of the svm classier .
unfortunately , since this quantity is not accessible , one has to build estimates or bounds for it .
in this section , we present several measures of the expected error rate of an svm .
single validation estimate
if one has enough data available , it is possible to estimate the true error on a validation set .
this estimate is unbiased and its variance gets smaller as the size of the validation set increases .
if the validation set is ( ( x ( cid : 123 )
) ) 123i p , the estimate is
i f ( x
where is the step function : ( x ) = 123 when x > 123 and ( x ) = 123 otherwise .
chapelle et al .
leave - one - out bounds
the leave - one - out procedure consists of removing from the training data one element , constructing the decision rule on the basis of the remaining training data and then testing on the removed element .
in this fashion one tests all ( cid : 123 ) elements of the training data ( using ( cid : 123 ) different decision rules ) .
let us denote the number of errors in the leave - one - out procedure by l ( x123 , y123 , .
, x ( cid : 123 ) , y ( cid : 123 ) ) .
it is known ( luntz & brailovsky , 123 ) that the the leave - one - out procedure gives an almost unbiased estimate of the expected generalization error :
e ( l ( x123 , y123 , .
, x ( cid : 123 ) , y ( cid : 123 ) ) ) ,
and the expectations are taken over the random choice of the sample .
is the probability of test error for the machine trained on a sample of size ( cid : 123 ) 123
although this lemma makes the leave - one - out estimator a good choice when estimating the generalization error , it is nevertheless very costly to actually compute since it requires running the training algorithm ( cid : 123 ) times .
the strategy is thus to upper bound or approximate this estimator by an easy to compute quantity t having , if possible , an analytical expression .
if we denote by f 123 the classier obtained when all training examples are present and f i
the one obtained when example i has been removed , we can write :
l ( x123 , y123 , .
, x ( cid : 123 ) , y ( cid : 123 ) ) = ( cid : 123 ) ( cid : 123 ) l ( x123 , y123 , .
, x ( cid : 123 ) , y ( cid : 123 ) ) = ( cid : 123 ) ( cid : 123 )
which can also be written as
( yp f p ( x p ) ) ,
( yp f 123 ( x p ) + yp ( f 123 ( x p ) f p ( x p ) ) ) .
thus , if u p is an upper bound for yp ( f 123 ( x p ) f p ( x p ) ) , we will get the following upper bound on the leave - one - out error :
l ( x123 , y123 , .
, x ( cid : 123 ) , y ( cid : 123 ) ) ( cid : 123 ) ( cid : 123 )
( u p 123 ) ,
since for hard margin svms , yp f 123 ( x p ) 123 and is monotonically increasing .
support vector count .
since removing a non - support vector from the training set does not change the solution computed by the machine ( i . e .
u p = f 123 ( x p ) f p ( x p ) = 123 for x p non - support vector ) , we can restrict the preceding sum to support vectors and upper
choosing multiple parameters for support vector machines
bound each term in the sum by 123 which gives the following bound on the number of errors made by the leave - one - out procedure ( vapnik , 123 ) :
t = nsv
where nsv denotes the number of support vectors .
jaakkola - haussler bound .
for svms without threshold , analyzing the optimiza - tion performed by the svm algorithm when computing the leave - one - out error , jaakkola and haussler ( 123 ) proved the inequality :
yp ( f 123 ( x p ) f p ( x p ) ) 123
p k ( x p , x p ) = u p
which leads to the following upper bound :
p k ( x p , x p ) 123
note that wahba , lin , and zhang ( 123 ) proposed an estimate of the number of errors made by the leave - one - out procedure , which in the hard margin svm case turns out to be
p k ( x p , x p ) ,
which can be seen as an upper bound of the jaakkola - haussler one since ( x 123 ) x for
opper - winther bound .
for hard margin svms without threshold , opper and winther ( 123 ) used a method inspired from linear response theory to prove the following : under the assumption that the set of support vectors does not change when removing the example p , we have
yp ( f 123 ( x p ) f p ( x p ) ) =
where ksv is the matrix of dot products between support vectors; leading to the following
chapelle et al .
radius - margin bound .
for svms without threshold and with no training errors , vapnik ( 123 ) proposed the following upper bound on the number of errors of the leave -
where r and are the radius and the margin as dened in theorem 123
span bound .
vapnik and chapelle ( 123 ) and chapelle and vapnik ( 123 ) derived an estimate using the concept of span of support vectors .
under the assumption that the set of support vectors remains the same during the leave -
one - out procedure , the following equality is true :
where sp is the distance between the point ( x p ) and the set p where
yp ( f 123 ( x p ) f p ( x p ) ) = 123
i ( xi ) ,
i ( cid : 123 ) = p , 123
this gives the exact number of errors made by the leave - one - out procedure under the
the span estimate can be related to other approximations :
if we consider svms without threshold , the con - link with jaakkola - haussler bound .
i = 123 can be removed in the denition of the span .
then we can easily upper k ( x p , x p ) , and thus recover the jaakkola - haussler bound .
bound the value of the span : s123 link with r123 / 123
for each support vector , we have yp f 123 ( x p ) = 123
since for x 123 , ( x 123 ) x , the number of errors made by the leave - one - out procedure is bounded by :
it has been shown ( vapnik & chapelle , 123 ) that the span sp is bounded by the diameter = 123 / 123 , we nally get of the smallest sphere enclosing the training points and since
choosing multiple parameters for support vector machines
a similar derivation as the one used in the span bound has been proposed in joachims ( 123 ) , where the leave - one - out error is bounded by| ( p , 123 p r123 > yp f 123 ( x p ) ) | , with 123 k ( xi , xi )
link with opper - winther .
when the support vectors do not change , the hard margin case without threshold gives the same value as the opper - winther bound , namely :
smoothing the test error estimates
the estimate of the performance of an svm through a validation error ( 123 ) or the leave - one - out error ( 123 ) requires the use of the step function .
however , we would like to use a gradient descent approach to minimize those estimates of the test error .
unfortunately the step function is not differentiable .
as already mentioned in section 123 . 123 , it is possible to bound ( x 123 ) by x for x 123
this is how the bound r123 / 123 is derived from the leave - one - out error .
nevertheless by doing so , large errors count more than one , therefore it might be advantageous instead to use a contracting function of the form ( x ) = ( 123 + exp ( ax + b ) ) 123 ( see gure 123 ) .
however , the choice of the constants a and b is difcult .
if a is too small , the estimate
is not accurate and a is too large , the resulting estimate is not smooth .
instead of trying to pick good constants a and b , one can try to get directly a smooth approximation of the test error by estimating posterior probabilities .
recently , platt proposed the following estimate of the posterior distribution p ( y = 123| x = x ) of an svm output f ( x )
pa , b ( x ) = p ( y = 123| x = x ) =
123+ exp ( a f ( x ) + b )
where f ( x ) is the output of the svm .
the constants a and b are found by minimizing the kullback - leibler divergence between p and an empirical approximation of p built from a validation set ( x ( cid : 123 )
) = arg max
log ( pa , b ( x
) ) + 123 y
log ( 123 pa , b ( x
this optimization is carried out using a second order gradient descent algorithm ( platt , 123 ) .
is such that ( cid : 123 ) = 123 , we obtained a correction compared to
f ( x ) = sign ( pa , b ( x ) 123 ) .
note that if b
according to this estimate the best threshold for our svm classier f
the usual svm threshold .
chapelle et al .
figure 123
validation error for different values of the width ( in log scale ) of an rbf kernel .
top left : with a step function , ( x ) = 123x > 123
top right : sigmoid function , ( x ) = ( 123 + exp ( 123x ) ) 123
bottom : linear function , ( x ) = 123 + x for x > 123 , 123 otherwise .
note that on the bottom picture , the minimum is not at the right place .
by denition the generalization error of our classier is p ( y = 123| x ) d ( x ) +
p ( y ( cid : 123 ) = f ( x ) ) =
x , f ( x ) =123
( y = 123| x ) d ( x ) .
x , f ( x ) =123
this error can be empirically estimated as123 :
p ( y ( cid : 123 ) = f ( x ) )
) , 123 p ( x
note that the labels of the validation set are not used directly in this last step but indirectly
through the estimation of the constants a and b appearing in the parametric form of pa , b .
to have a better understanding of this estimate , let us consider the extreme case where there is no error on the validation set .
then the maximum likelihood algorithm is going to yield
a = and pa , b ( x ) will only take binary values .
as a consequence , the estimate of the
error probability will be zero .
choosing multiple parameters for support vector machines
optimizing the kernel parameters
lets go back to the svm algorithm .
we assume that the kernel k depends on one or several parameters , encoded into a vector = ( 123 , .
we thus consider a class of decision functions parametrized by , b and :
f , b , ( x ) = sign
i yi k ( x , xi ) + b
we want to choose the values of the parameters and such that w ( see eq .
( 123 ) ) is maximized ( maximum margin algorithm ) and t , the model selection criterion , is minimized ( best kernel parameters ) .
more precisely , for xed , we want to have 123 = arg max w ( ) and choose 123 such that
123 = arg min
t ( 123 , ) .
when is a one dimensional parameter , one typically tries a nite number of values and picks the one which gives the lowest value of the criterion t .
when both t and the svm solution are continuous with respect to , a better approach has been proposed by cristianini , campbell , and shawe - taylor ( 123 ) : using an incremental optimization algorithm , one can train an svm with little effort when is changed by a small amount .
however , as soon as has more than one component computing t ( , ) for every possible value of becomes intractable , and one rather looks for a way to optimize t along a trajectory in the kernel
using the gradient of a model selection criterion to optimize the model parameters has been proposed in bengio ( 123 ) and demonstrated in the case of linear regression and time - series prediction .
it has also been proposed by larsen et al .
( 123 ) to optimize the regularization parameters of a neural network .
here we propose an algorithm that alternates the svm optimization with a gradient step is the direction of the gradient of t in the parameter space .
this can be achieved by the following iterative procedure :
initialize to some value .
using a standard svm algorithm , find the maximum of the
quadratic form w : 123 ( ) = arg max
w ( , ) .
update the parameters such that t is minimized .
this is typically achieved by a gradient step ( see below ) .
go to step 123 or stop when the minimum of t is reached .
solving step 123 requires estimating how t varies with .
we will thus restrict ourselves to the case where k can be differentiated with respect to .
moreover , we will only consider cases where the gradient of t with respect to can be computed ( or approximated ) .
chapelle et al .
note that 123 depends implicitly on since 123 is dened as the maximum of w .
then , if we have n kernel parameters ( 123 , .
, n ) , the total derivative of t 123 ( ) t ( 123 ( ) , ) with respect to p is :
having computed the gradient t ( 123 , ) , a way of performing step 123 is to make a
t ( 123 , )
for some small and eventually decreasing .
the convergence can be improved with the use of second order derivatives ( newtons method ) :
k = ( t ) 123
t ( 123 , )
where the laplacian operator is dened by
( t ) i , j = 123t ( 123 , )
in this formulation , additional constraints can be imposed through projection of the gradient .
computing the gradient
in this section , we describe the computation of the gradient ( with respect to the kernel parameters ) of the different estimates of the generalization error .
first , for the bound r123 / 123 ( see theorem 123 ) , we obtain a formulation of the derivative of the margin ( section 123 ) and of the radius ( section 123 ) .
for the validation error ( see eq .
( 123 ) ) , we show how to calculate the derivative of the hyperplane parameters 123 and b ( see section 123 ) .
finally , the computation of the derivative of the span bound ( 123 ) is presented in section 123 .
we rst begin with a useful lemma .
suppose we are given a ( n 123 ) vector v and an ( n n ) matrix p smoothly
depending on a parameter .
consider the function :
l ( ) = max
xt v 123
xt p x
f = ( x : bt x = c , x 123 ) .
choosing multiple parameters for support vector machines
let x be the the vector x where the maximum in l ( ) is attained .
if this minimum is unique
in other words , it is possible to differentiate l with respect to as if x did not depend on .
note that this is also true if one ( or both ) of the constraints in the denition of f are
proof : we rst need to express the equality constraint with a lagrange multiplier and the inequality constraints with lagrange multipliers i :
l ( ) = max
xt v 123
xt p x ( bt x c ) + t x .
at the maximum , the following conditions are veried :
v p x = b ,
bt x = c , i xi = 123 ,
we will not consider here differentiability problems .
the interested reader can nd de - tails in bonnans and shapiro ( 123 ) .
the main result is that whenever x is unique , l is
x + xt
( v p x ) ,
where the last term can be written as follows ,
( v p x ) =
using the derivatives of the optimality conditions , namely
b = 123 ,
xi + i
and the fact that either i = 123 or xi = 123 we get :
xi = i
( v p x ) = 123
chapelle et al .
and the result follows .
computing the derivative of the margin note that in feature space , the separating hyperplane ( x : w ( x ) +b = 123 ) has the following
w = ( cid : 123 ) ( cid : 123 )
i yi ( xi )
and is normalized such that
yi ( w ( xi ) + b ) = 123
it follows from the denition of the margin in theorem 123 that this latter is = 123 / ( cid : 123 ) w ( cid : 123 ) .
thus we write the bound r123 / 123 as r123 ( cid : 123 ) w ( cid : 123 ) 123
the previous lemma enables us to compute the derivative of ( cid : 123 ) w ( cid : 123 ) 123
indeed , it can be
shown ( vapnik , 123 ) that ( cid : 123 ) w ( cid : 123 ) 123 = w ( 123 ) ,
and the lemma can be applied to the standard svm optimization problem ( 123 ) , giving
j yi y j
k ( xi , x j )
computing the derivative of the radius
computing the radius of the smallest sphere enclosing the training points can be achieved by solving the following quadratic problem ( vapnik , 123 ) :
i k ( xi , xi ) ( cid : 123 ) ( cid : 123 )
r123 = max
i j k ( xi , x j )
i = 123 i i 123
choosing multiple parameters for support vector machines
we can again use the previous lemma to compute the derivative of the radius :
k ( xi , xi )
k ( xi , x j )
where 123 maximizes the previous quadratic form .
computing the derivative of the hyperplane parameters
let us rst compute the derivative of 123 with respect to a parameter of the kernel .
for this purpose , we need an analytical formulation for 123
first , we suppose that the points which are not support vectors are removed from the training set .
this assumption can be done without any loss of generality since removing a point which is not support vector does not affect the solution .
then , the fact that all the points lie on the margin can be written
= yi y j k ( xi , x j ) .
if there are n support vectors , h is a ( n + 123 ) ( n + 123 ) matrix .
the parameters of the svms can be written as :
( 123 , b ) t = h
123 ( 123 123 123 ) t .
we are now able to compute the derivatives of those parameters with respect to a kernel parameter p .
indeed , since the derivative of the inverse of a matrix m depending on a parameter p can be written123
it follows that
123 ( 123 123 123 ) t ,
chapelle et al .
we can easily use the result of this calculation to recover the computation ( cid : 123 ) w ( cid : 123 ) 123 we denote = ( 123 , b ) , we have ( cid : 123 ) w ( cid : 123 ) 123 = ( 123 ) t ky 123 = t h and it turns out that :
indeed , if
computing the derivative of the span - rule
now , let us consider the span value .
recall that the span of the support vector x p is dened as the the distance between the point ( x p ) and the set p dened by ( 123 ) .
then the value of the span can be written as :
i ( xi )
( cid : 123 ) 123 + 123
i = 123
note that we introduced a lagrange multiplier to enforce the constraint introducing the extended vector = ( t ) t and the extended matrix of the dot products between support vectors
the value of the span can be written as :
( k ( x p , x p ) 123vt +
where h is the submatrix of ksv with row and column p removed , and v is the p - th column of ksv .
from the fact that the optimal value of is h123v , it follows :
= k ( x p , x p ) vt h
choosing multiple parameters for support vector machines
the last equality comes from the following block matrix identity , known as the woodbury formula ( lutkepohl , 123 )
where b123 = ( a123 aa the closed form we obtain is particularly attractive since we can compute the value of
the span for each support vector just by inverting the matrix ksv .
combining eqs .
( 123 ) and ( 123 ) , we get the derivative of the span
123 at ) 123
thus , the complexity of computing the derivative of the span - rule with respect to a and the inversion of
parameter p of the kernel requires only the computation of k ( xi , x j ) the matrix ksv .
the complexity of these operations is not larger than that of the quadratic
optimization problem itself .
there is however a problem in this approach : the value given by the span - rule is not continuous .
by changing smoothly the value of the parameters , the coefcients p change continuously , but the span s123 p does not .
there is actually a discontinuity for most support vectors when the set of support vectors changes .
this can be easily understood from eq .
( 123 ) : suppose that upon changing the value of the parameter from to + , a point xm is not a support vector anymore , then for all other support vectors ( x p ) p ( cid : 123 ) =m , the set p is going to be smaller and a discontinuity is likely to appear for the value of sp = d ( ( x p ) , p ) .
the situation is explained in gure 123 : we plotted the value of the span of a support vector x p versus the width of an rbf kernel .
almost everywhere the span is decreasing , hence a negative derivative , but some jumps appear , corresponding to a change in the set of support vectors .
moreover the span is globally increasing : the value of the derivate does not give us a good indication of the global evolution of the span .
one way to solve is this problem is to try to smooth the behavior of the span .
this can be done by imposing the following additional constraint in the denition of p in eq .
( 123 ) : |i| c 123 i , where c is a constant .
given this constraint , if a point xm is about to leave or has just entered the set of support vectors , it will not have a large inuence on the span of the other support vectors , since 123 m will be small .
the effect of this constraint is to make the set p become continuous when the set of support vectors changes .
however this new constraint prevents us from computing the span as efciently as in eq .
a possible solution is to replace the constraint by a regularization term in the computation of the span :
( cid : 123 ) ( cid : 123 ) ( cid : 123 ) ( cid : 123 ) ( cid : 123 ) ( x p ) n ( cid : 123 )
i ( xi )
chapelle et al .
figure 123
value of kernel varying in the small vicinity .
p , the sum of the span of the training points for different values of the width of an rbf
with this new denition of the span , eq .
( 123 ) becomes :
= 123 / ( ksv + d ) 123
where d is a diagonal matrix with elements dii = / 123 i and dn+123 , n+123 = 123
as shown on gure 123 , the span is now much smoother and its minimum is still at the right place .
in our experiments , we took = 123 .
note that computing the derivative of this new expression is no more difcult than the
previous span expression .
figure 123
left : the minima of the span prediction with regularization ( dashed line ) and without regular - ization ( solid line ) are close .
right : detailed behavior of the span for different values of the regularizer , = 123 , 123 , 123 , 123 .
choosing multiple parameters for support vector machines
it is interesting to look at the leave - one - out error for svms without threshold .
in this
case , the value of the span with regularization writes :
as already pointed out in section 123 . 123 , if = 123 , the value of span is :
i ( xi )
and we recover the opper - winther bound .
on the other hand , if = + , then = 123 and s123
bound is identical to the jaakkola - haussler one .
= k ( x p , x p ) .
in this case , the span
in a way , the span bound with regularization is in between the bounds of opper - winther
experiments have been carried out to assess the performance and feasibility of our method .
the rst set of experiments consists in nding automatically the optimal value of two parameters : the width of an rbf kernel and the constant c in eq .
the second set of experiments corresponds to the optimization of a large number of scaling factors in the case of handwritten digit recognition .
we then show that optimizing scaling factors leads naturally to feature selection and demonstrate the application of the method to the selection of relevant features in several databases .
optimization details
the core of the technique we present here is a gradient descent algorithm .
we used the optimization toolbox of matlab to perform it .
it includes second order updates to improve the convergence speed .
since we are not interested in the exact value of the parameters minimizing the functional , we used a loose stopping criterion .
benchmark databases
in a rst set of experiments , we tried to select automatically the width of a rbf kernel ,
( xi zi ) 123
k ( x , z ) = exp
along the constant c penalizing the training error appearing in eq
chapelle et al .
in order to avoid adding positivity constraints in the optimization problem ( for the constant c and the width of the rbf kernel ) , we use the parameterization = ( log c , log ) .
moreover , this turns out to give a more stable optimization .
the initial values are c = 123 and log = 123
each component being normalized by its standard deviation , this corresponds to a rather small value for .
we used benchmark databases described in ratsch , onoda , and muller ( 123 )
databases , as long as the 123 differents training and test splits are available at
we followed the same experimental setup as in ratsch , onoda , and muller ( 123 ) .
on each of the rst 123 training sets , the kernel parameters are estimated using either 123 - fold cross - validation , minimization of r123 / 123 , or the span - bound .
finally , the kernel parameters are computed as the median of the 123 estimations .
the results are shown in table 123
it turns out that minimizing r123 / 123 or the span estimates yields approximately the same performances as picking - up the parameters which minimize the cross - validation error .
this is not very surprising since cross - validation is known to be an accurate method for choosing the hyper - parameters of any learning algorithm .
a more interesting comparison is the computational cost of these methods .
table 123 shows how many svm trainings in average are needed to select the kernel parameters on each split .
the results for cross - validation are the ones reported in ratsch , onoda , and
table 123
test error found by different algorithms for selecting the svm parameters c and .
the rst column reports the results from ratsch , onoda , and muller ( 123 ) .
in the second and last column , the parameters are found by minimizing r123 / 123 and the span - bound using a gradient descent algorithm .
table 123
average number of svm trainings on one training set needed to select the parameters c and using standard cross - validation or by minimizing r123 / 123 or the span - bound .
choosing multiple parameters for support vector machines
muller ( 123 ) .
they tried 123 different values for c and and performed 123 - fold cross - validation .
the number of svm trainings on each of the 123 training set needed by this method is 123 123 123 = 123
the gain in complexity is impressive : on average 123 times fewer svm training iterations are required to nd the kernel parameters .
the main reason for this gain is that there were two parameters to optimize .
because of computational reasons , exhaustive search by cross - validation can not handle the selection of more than 123 parameters , whereas our method can , as highlighted in the next section .
discussion .
as explained in section 123 , r123 / 123 can seem to be a rough upper bound of the span - bound , which is in an accurate estimate of the test error ( chapelle & vapnik , 123 ) .
however in the process of choosing the kernel parameters , what matters is to have a bound whose minimum is close to the optimal kernel parameters .
even if r123 / 123 cannot be used to estimate the test error , the previous experiments show that its minimization yields quite good results .
the generalization error obtained by minimizing the span - bound ( cf table 123 ) are just slightly better .
since the minimization of the latter is more difcult to implement and to control ( more local minima ) , we recommend in practice to minimize r123 / 123
in the experiments of the following section , we will only relate experiments with this bound , but similar results have been obtained with the span - bound .
automatic selection of scaling factors
in this experiment , we try to choose the scaling factors for an rbf and polynomial kernel of degree 123
more precisely , we consider kernels of the following form :
k ( x , z ) = exp
k ( x , z ) =
( xi zi ) 123
most of the experiments have been carried out on the usps handwritten digit recognition database .
this database consists of 123 training examples and 123 test examples of digit images of size 123 123 pixels .
we try to classify digits 123 to 123 against 123 to 123
the training set has been split into 123 subsets of 123 examples and each of this subset has been used successively during the training .
to assess the feasibility of our gradient descent approach for nding kernel parameters , we rst used only 123 parameters , each one corresponding to a scaling factor for a squared tile of 123 pixels as shown on gure 123
the scaling parameters were initialized to 123
the evolution of the test error and of the bound r123 / 123 is plotted versus the number of iterations in the gradient descent procedure in gures 123 ( polynomial kernel ) and 123 ( rbf kernel ) .
chapelle et al .
figure 123
on each of the 123 tiles , the scaling factors of the 123 pixels are identical .
figure 123
evolution of the test error ( left ) and of the bound r123 / 123 ( right ) during the gradient descent optimization with a polynomial kernel .
figure 123
evolution of the test error ( left ) and of the bound r123 / 123 ( right ) during the gradient descent optimization with an rbf kernel .
choosing multiple parameters for support vector machines
figure 123
scaling factors found by the optimization procedure : darker means smaller scaling factor .
note that for the polynomial kernel , the test error went down to 123% whereas the best test error with only one scaling parameter is 123% .
thus , by taking several scaling parameters , we managed to make the test error decrease .
it might be interesting to have a look at the value of the scaling coefcients we have have found .
for this purpose , we took 123 scaling parameters ( one per pixel ) and mini - mized r123 / 123 with a polynomial kernel .
the map of the scaling coefcient is shown in gure 123
the result is quite consistent with what one could expect in such a situation : the coef - cients near the border of the picture are smaller than those in the middle of the picture , so that these coefcients can be directly interpreted as measures of the relevance of the
discussion .
this experiment can be considered as a sanity check experiment .
indeed , it proves it is feasible to choose multiple kernel parameters of an svm and that it does not lead to overtting .
however , the gain in test error was not our main motivation since we did not expect any signicant improvement on such a problem where most features play a similar role ( taking all scaling factors equal on this database seems a reasonable choice ) .
however as highlighted by gure 123 , this method can be a powerful tool to perform feature
feature selection
the motivation for feature selection is three - fold :
improve generalization error 123
determine the relevant features ( for explanatory purposes ) 123
reduce the dimensionality of the input space ( for real - time applications )
finding optimal scaling parameters can lead to feature selection algorithms .
indeed , if one of the input components is useless for the classication problem , its scaling factor is likely to become small .
but if a scaling factor becomes small enough , it means that it is possible to remove it without affecting the classication algorithm .
this leads to the following idea for feature selection : keep the features whose scaling factors are the largest .
chapelle et al .
this can also be performed in a principal components space where we scale each principal component by a scaling factor .
we consider two different parametrization of the kernel .
the rst one correspond to
rescaling the data in the input space :
k ( x , z ) = k ( t x , t z )
the second one corresponds to rescaling in the principal components space :
k ( x , z ) = k ( t x , t z )
where is the matrix of principal components .
we compute and using the following iterative procedure :
initialize = ( 123 , .
, 123 ) 123
in the case of principal component scaling , perform
principal component analysis to compute the matrix .
solve the svm optimization problem 123
minimize the estimate of the error t with respect to
with a gradient step .
if a local minimum of t is not reached go to step 123
discard dimensions corresponding to small elements in
and return to step 123
we demonstrate this idea on two toy problems where we show that feature selection reduces generalization error .
we then apply our feature selection algorithm to dna micro - array data where it is important to nd which genes are relevant in performing the classica - tion .
it also seems in these types of algorithms that feature selection improves performances .
lastly , we apply the algorithm to face detection and show that we can greatly reduce the input dimension without sacricing performance .
toy data
we compared several algorithms the standard svm algorithm with no feature selection our feature selection algorithm with the estimate r123 / 123 and with the span estimate the standard svm applied after feature selection via a lter method
the three lter methods we used choose the m largest features according to : pearson correlation coefcients , the fisher criterion score , 123 and the kolmogorov - smirnov test . 123 note that the pearson coefcients and fisher criterion cannot model nonlinear dependencies .
in the two following articial datasets our objective was to assess the ability of the algorithm to select a small number of target features in the presence of irrelevant and redundant features ( weston et al . , 123 ) .
choosing multiple parameters for support vector machines
figure 123
a comparison of feature selection methods on ( a ) a linear problem and ( b ) a nonlinear problem both with many irrelevant features .
the x - axis is the number of training points , and the y - axis the test error as a fraction of test points .
for the rst example , six dimensions of 123 were relevant .
the probability of y = 123 or123 was equal .
the rst three features ( x123 , x123 , x123 ) were drawn as xi = y n ( i , 123 ) and the second three features ( x123 , x123 , x123 ) were drawn as xi = n ( 123 , 123 ) with a probability of 123 , otherwise the rst three were drawn as xi = n ( 123 , 123 ) and the second three as xi = y n ( i 123 , 123 ) .
the remaining features are noise xi = n ( 123 , 123 ) , i = 123 , .
for the second example , two dimensions of 123 were relevant .
the probability of y = 123 or 123 was equal .
the data are drawn from the following : if y = 123 then ( x123 , x123 ) are drawn from n ( 123 , ) or n ( 123 , ) with equal probability , 123 = ( 123 , 123 ) and = i , if y = 123 then ( x123 , x123 ) are drawn again from two normal distributions with equal probability , with 123 = ( 123 , 123 ) and 123 = ( 123 , 123 ) and the same as before .
the rest of the features are noise xi = n ( 123 , 123 ) , i = 123 , .
in the linear problem the rst six features have redundancy and the rest of the features
, 123 ) and 123 = ( 123
are irrelevant .
in the nonlinear problem all but the rst two features are irrelevant .
we used a linear kernel for the linear problem and a second order polynomial kernel for
the nonlinear problem .
we imposed the feature selection algorithms to keep only the best two features .
the results are shown in gure 123 for various training set sizes , taking the average test error on 123 samples over 123 runs of each training set size .
the fisher score ( not shown in graphs due to space constraints ) performed almost identically to correlation coefcients .
in both problem , we clearly see that our method outperforms the other classical meth - ods for feature selection .
in the nonlinear problem , among the lter methods only the kolmogorov - smirnov test improved performance over standard svms .
dna microarray data
next , we tested this idea on two leukemia discrimination problems ( golub et al . , 123 ) and a problem of predicting treatment outcome for medulloblastoma . 123 the rst problem was to
chapelle et al .
classify myeloid versus lymphoblastic leukemias based on the expression of 123 genes .
the training set consists of 123 examples and the test set 123 examples .
standard linear svms achieve 123 error on the test set .
using gradient descent on r123 / 123 we achieved 123 error using 123 genes and 123 error using 123 gene .
using the fisher score to select features resulted in 123 error for both 123 and 123 genes .
the second leukemia classication problem was discriminating b versus t cells for lymphoblastic cells ( golub et al . , 123 ) .
standard linear svms make 123 error for this problem .
using either the span bound or gradient descent on r123 / 123 results in 123 error using 123 genes , whereas the fisher score get 123 errors using the same number of genes .
the nal problem is one of predicting treatment outcome of patients that have medulloblastoma .
here there are 123 examples each with 123 expression values in the dataset and we use leave - one - out to measure the error rate .
a standard svm with a gaussian kernel makes 123 errors , while selecting 123 genes using the gradient descent on r123 / 123 we achieved an error of 123
face detection
the trainable system for detecting frontal and near - frontal views of faces in gray images presented in heisele , poggio , and pontil ( 123 ) gave good results in terms of detection rates .
the system used gray values of 123 123 images as inputs to a second - degree polynomial kernel svm .
this choice of kernel lead to more than 123 , 123 features in the feature space .
searching an image for faces at different scales took several minutes on a pc .
to make
figure 123
roc curves for different number of pca gray features .
choosing multiple parameters for support vector machines
the system real - time reducing the dimensionality of the input space and the feature space was required .
the feature selection in principal components space was used to reduce the dimensionality of the input space ( serre et al . , 123 ) .
the method was evaluated on the large cmu test set 123 consisting of 123 faces and about 123 , 123 , 123 non - face patterns .
in gure 123 , we compare the roc curves obtained for different numbers of selected components .
the results showed that using more than 123 components does not improve the perfor -
mances of the system ( serre et al . , 123 ) .
we proposed an approach for automatically tuning the kernel parameters of an svm .
this is based on the possibility of computing the gradient of various bounds on the generalization error with respect to these parameters .
different techniques have been proposed to smooth these bounds while preserving their accuracy in predicting the location of the minimum of test error .
using these smoothed gradients we were able to perform gradient descent to search the kernel parameter space , leading to both an improvement of the performance and a reduction of the complexity of the solution ( feature selection ) .
using this method , we chose in the separable case appropriate scaling factors .
in the non separable case , this method allows us to choose simultaneously scaling factors and parameter c ( see
the benets of this technique are many .
first it allows to actually optimize a large number of parameters while previous approaches only could deal with 123 parameters at most .
even in the case of a small number of parameters , it improves the run time by a large amount .
moreover experimental results have demonstrated that an accurate estimate of the error is not required and that a simple estimate like r123 / 123 has a very good behaviour in terms of nding the right parameters .
in a way this renders the technique even more applicable since this estimate is very simple to compute and derive .
finally , this approach avoids holding out some data for validation and thus makes full use of the training set for the optimization of parameters , contrary to cross - validation methods .
this approach and the fact that it has be proven successful in various situation opens new directions of research in the theory and practice of support vector machines .
on the practical side , this approach makes possible the use of highly complex and tunable kernels , the tuning of scaling factors for adapting the shape of the kernel to the problem and the selection of relevant features .
on the theoretical side , it demonstrates that even when a large number of parameter are simultaneously tuned the overtting effect remains
of course a lot of work remains to be done in order to properly understand the reasons .
another interesting phenomenon is the fact that the quantitative accuracy of the estimate used for the gradient descent is only marginally relevant .
this raises the question of how to design good estimates for parameter tuning rather than accurate estimates .
future investigation will focus on trying to understand these phenomena and obtain bounds on the generalization error of the overall algorithm , along with looking for new problems where this approach could be applied as well as new applications .
chapelle et al .
the authors would like to thank jason weston and elodie nedelec for helpful comments
in the rest of this article , we will reference vectors and matrices using bold notation .
we note p ( x ) as an abbreviation for pa , b ( x ) .
this inequality can be easily proved by differentiating mm 123
f ( r ) = 123
kstst ( r ) = is the standard deviation .
example , and p is the corresponding empirical distribution .
123 = i .
is the mean value for the r - th feature in the positive and negative classes and ( cid : 123 ) sup ( p ( x fr ) p ( x fr , yr = 123 ) ) where fr denotes the r - th feature from each training
the database will be available at : http : / / waldo . wi . mit . edu / mpr / datasets . html .
