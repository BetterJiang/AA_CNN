A fast learning algorithm for deep belief nets (cid:3)

Geoffrey E. Hinton and Simon Osindero
Department of Computer Science University of Toronto

10 Kings College Road

Toronto, Canada M5S 3G4

fhinton, osinderog@cs.toronto.edu

Yee-Whye Teh

Department of Computer Science
National University of Singapore

3 Science Drive 3, Singapore, 117543

tehyw@comp.nus.edu.sg

Abstract

We show how to use “complementary priors” to
eliminate the explaining away effects that make
inference difﬁcult
in densely-connected belief
nets that have many hidden layers. Using com-
plementary priors, we derive a fast, greedy algo-
rithm that can learn deep, directed belief networks
one layer at a time, provided the top two lay-
ers form an undirected associative memory. The
fast, greedy algorithm is used to initialize a slower
learning procedure that ﬁne-tunes the weights us-
ing a contrastive version of the wake-sleep algo-
rithm. After ﬁne-tuning, a network with three
hidden layers forms a very good generative model
of the joint distribution of handwritten digit im-
ages and their labels. This generative model gives
better digit classiﬁcation than the best discrimi-
native learning algorithms. The low-dimensional
manifolds on which the digits lie are modelled by
long ravines in the free-energy landscape of the
top-level associative memory and it is easy to ex-
plore these ravines by using the directed connec-
tions to display what the associative memory has
in mind.

1 Introduction

Learning is difﬁcult in densely-connected, directed belief nets
that have many hidden layers because it is difﬁcult to infer the
conditional distribution of the hidden activities when given a
data vector. Variational methods use simple approximations
to the true conditional distribution, but the approximations
may be poor, especially at the deepest hidden layer where
the prior assumes independence. Also, variational learning
still requires all of the parameters to be learned together and
makes the learning time scale poorly as the number of param-
eters increases.

We describe a model in which the top two hidden layers
form an undirected associative memory (see ﬁgure 1) and the

(cid:3)To appear in Neural Computation 2006

remaining hidden layers form a directed acyclic graph that
converts the representations in the associative memory into
observable variables such as the pixels of an image. This hy-
brid model has some attractive features:

1. There is a fast, greedy learning algorithm that can ﬁnd
a fairly good set of parameters quickly, even in deep
networks with millions of parameters and many hidden
layers.

2. The learning algorithm is unsupervised but can be ap-
plied to labeled data by learning a model that generates
both the label and the data.

3. There is a ﬁne-tuning algorithm that learns an excel-
lent generative model which outperforms discrimina-
tive methods on the MNIST database of hand-written
digits.

4. The generative model makes it easy to interpret the dis-

tributed representations in the deep hidden layers.

5. The inference required for forming a percept is both fast

and accurate.

6. The learning algorithm is local:

adjustments to a
synapse strength depend only on the states of the pre-
synaptic and post-synaptic neuron.

7. The communication is simple: neurons only need to

communicate their stochastic binary states.

Section 2 introduces the idea of a “complementary” prior
which exactly cancels the “explaining away” phenomenon
that makes inference difﬁcult in directed models. An exam-
ple of a directed belief network with complementary priors
is presented. Section 3 shows the equivalence between re-
stricted Boltzmann machines and inﬁnite directed networks
with tied weights.

Section 4 introduces a fast, greedy learning algorithm
for constructing multi-layer directed networks one layer at
a time. Using a variational bound it shows that as each new
layer is added, the overall generative model improves. The
greedy algorithm bears some resemblance to boosting in its
repeated use of the same “weak” learner, but instead of re-
weighting each data-vector to ensure that the next step learns
something new, it re-represents it. The “weak” learner that

2000 top-level units

10 label units

500 units 

This could be the 
top level of 
another sensory 
pathway

500 units 

28 x 28    
pixel 
image

Figure 1: The network used to model the joint distribution
of digit images and digit labels. In this paper, each training
case consists of an image and an explicit class label, but work
in progress has shown that the same learning algorithm can
be used if the “labels” are replaced by a multilayer pathway
whose inputs are spectrograms from multiple different speak-
ers saying isolated digits. The network then learns to generate
pairs that consist of an image and a spectrogram of the same
digit class.

is used to construct deep directed nets is itself an undirected
graphical model.

Section 5 shows how the weights produced by the fast
greedy algorithm can be ﬁne-tuned using the “up-down” al-
gorithm. This is a contrastive version of the wake-sleep al-
gorithm Hinton et al. (1995) that does not suffer from the
“mode-averaging” problems that can cause the wake-sleep al-
gorithm to learn poor recognition weights.

Section 6 shows the pattern recognition performance of
a network with three hidden layers and about 1.7 million
weights on the MNIST set of handwritten digits. When no
knowledge of geometry is provided and there is no special
preprocessing, the generalization performance of the network
is 1.25% errors on the 10; 000 digit ofﬁcial test set. This beats
the 1.5% achieved by the best back-propagation nets when
they are not hand-crafted for this particular application. It is
also slightly better than the 1.4% errors reported by Decoste
and Schoelkopf (2002) for support vector machines on the
same task.

Finally, section 7 shows what happens in the mind of the
network when it is running without being constrained by vi-
sual input. The network has a full generative model, so it is
easy to look into its mind – we simply generate an image from
its high-level representations.

Throughout the paper, we will consider nets composed of

Figure 2: A simple logistic belief net containing two inde-
pendent, rare causes that become highly anti-correlated when
we observe the house jumping. The bias of (cid:0)10 on the earth-
quake node means that, in the absence of any observation, this
node is e10 times more likely to be off than on. If the earth-
quake node is on and the truck node is off, the jump node has
a total input of 0 which means that it has an even chance of
being on. This is a much better explanation of the observation
that the house jumped than the odds of e(cid:0)20 which apply if
neither of the hidden causes is active. But it is wasteful to turn
on both hidden causes to explain the observation because the
probability of them both happening is e(cid:0)10 (cid:2) e(cid:0)10 = e(cid:0)20.
When the earthquake node is turned on it “explains away” the
evidence for the truck node.

stochastic binary variables but the ideas can be generalized to
other models in which the log probability of a variable is an
additive function of the states of its directly-connected neigh-
bours (see Appendix A for details).

2 Complementary priors

The phenomenon of explaining away (illustrated in ﬁgure 2)
makes inference difﬁcult in directed belief nets. In densely
connected networks, the posterior distribution over the hid-
den variables is intractable except in a few special cases such
as mixture models or linear models with additive Gaussian
noise. Markov Chain Monte Carlo methods (Neal, 1992) can
be used to sample from the posterior, but they are typically
very time consuming. Variational methods (Neal and Hinton,
1998) approximate the true posterior with a more tractable
distribution and they can be used to improve a lower bound on
the log probability of the training data. It is comforting that
learning is guaranteed to improve a variational bound even
when the inference of the hidden states is done incorrectly,
but it would be much better to ﬁnd a way of eliminating ex-
plaining away altogether, even in models whose hidden vari-
ables have highly correlated effects on the visible variables.
It is widely assumed that this is impossible.

A logistic belief net (Neal, 1992) is composed of stochas-
tic binary units. When the net is used to generate data, the

probability of turning on unit i is a logistic function of the
states of its immediate ancestors, j, and of the weights, wij,
on the directed connections from the ancestors:

p(si = 1) =

1

1 + exp((cid:0)bi (cid:0) Pj sjwij)

(1)

where bi is the bias of unit i.
If a logistic belief net only
has one hidden layer, the prior distribution over the hidden
variables is factorial because their binary states are chosen
independently when the model is used to generate data. The
non-independence in the posterior distribution is created by
the likelihood term coming from the data. Perhaps we could
eliminate explaining away in the ﬁrst hidden layer by using
extra hidden layers to create a “complementary” prior that
has exactly the opposite correlations to those in the likeli-
hood term. Then, when the likelihood term is multiplied by
the prior, we will get a posterior that is exactly factorial. It is
not at all obvious that complementary priors exist, but ﬁgure 3
shows a simple example of an inﬁnite logistic belief net with
tied weights in which the priors are complementary at every
hidden layer (see Appendix A for a more general treatment of
the conditions under which complementary priors exist). The
use of tied weights to construct complementary priors may
seem like a mere trick for making directed models equiva-
lent to undirected ones. As we shall see, however, it leads
to a novel and very efﬁcient learning algorithm that works
by progressively untying the weights in each layer from the
weights in higher layers.

2.1 An inﬁnite directed model with tied weights

We can generate data from the inﬁnite directed net in ﬁg-
ure 3 by starting with a random conﬁguration at an inﬁnitely
deep hidden layer1 and then performing a top-down “ances-
tral” pass in which the binary state of each variable in a layer
is chosen from the Bernoulli distribution determined by the
top-down input coming from its active parents in the layer
above. In this respect, it is just like any other directed acyclic
belief net. Unlike other directed nets, however, we can sam-
ple from the true posterior distribution over all of the hidden
layers by starting with a data vector on the visible units and
then using the transposed weight matrices to infer the fac-
torial distributions over each hidden layer in turn. At each
hidden layer we sample from the factorial posterior before
computing the factorial posterior for the layer above2. Ap-
pendix A shows that this procedure gives unbiased samples
because the complementary prior at each layer ensures that
the posterior distribution really is factorial.

Since we can sample from the true posterior, we can com-
pute the derivatives of the log probability of the data. Let

1The generation process converges to the stationary distribution
of the Markov Chain, so we need to start at a layer that is deep
compared with the time it takes for the chain to reach equilibrium.
2This is exactly the same as the inference procedure used in the
wake-sleep algorithm (Hinton et al., 1995) for the models described
in this paper no variational approximation is required because the
inference procedure gives unbiased samples.

us start by computing the derivative for a generative weight,
ij , from a unit j in layer H0 to unit i in layer V0 (see ﬁgure
w00
3). In a logistic belief net, the maximum likelihood learning
rule for a single data-vector, v0, is:

@ log p(v0)

@w00
ij

=<h0

j (v0

i (cid:0) ^v0

i )>

(2)

where < (cid:1)> denotes an average over the sampled states and
i is the probability that unit i would be turned on if the visi-
^v0
ble vector was stochastically reconstructed from the sampled
hidden states. Computing the posterior distribution over the
second hidden layer, V1, from the sampled binary states in the
ﬁrst hidden layer, H0, is exactly the same process as recon-
structing the data, so v1
i is a sample from a Bernoulli random
variable with probability ^v0
i . The learning rule can therefore
be written as:

@ log p(v0)

@w00
ij

=<h0

j (v0

i (cid:0) v1

i )>

(3)

i on h0

j is unproblematic in the deriva-
The dependence of v1
tion of Eq. 3 from Eq. 2 because ^v0
i is an expectation that is
conditional on h0
j . Since the weights are replicated, the full
derivative for a generative weight is obtained by summing the
derivatives of the generative weights between all pairs of lay-
ers:

@ log p(v0)

@wij

= <h0

j (v0

i (cid:0) v1

i )>

+ <v1

i (h0
+ <h1

j (cid:0) h1
j (v1

j )>
i (cid:0) v2
+:::

i )>

(4)

All of the vertically aligned terms cancel leaving the Boltz-

mann machine learning rule of Eq. 5.

3 Restricted Boltzmann machines and

contrastive divergence learning

It may not be immediately obvious that the inﬁnite directed
net in ﬁgure 3 is equivalent to a Restricted Boltzmann Ma-
chine (RBM). An RBM has a single layer of hidden units
which are not connected to each other and have undirected,
symmetrical connections to a layer of visible units. To gen-
erate data from an RBM, we can start with a random state
in one of the layers and then perform alternating Gibbs sam-
pling: All of the units in one layer are updated in parallel
given the current states of the units in the other layer and this
is repeated until the system is sampling from its equilibrium
distribution. Notice that this is exactly the same process as
generating data from the inﬁnite belief net with tied weights.
To perform maximum likelihood learning in an RBM, we can
use the difference between two correlations. For each weight,
wij, between a visible unit i and a hidden unit, j we measure
j > when a datavector is clamped on
the correlation < v0

i h0

TW

W

TW

W

TW

etc.

V2

2

iv

W

TW

H1

1

jh

W

TW

W

V1

1

iv

H0

0

jh

V0

0

iv

Figure 3: An inﬁnite logistic belief net with tied weights. The
downward arrows represent the generative model. The up-
ward arrows are not part of the model. They represent the
parameters that are used to infer samples from the posterior
distribution at each hidden layer of the net when a datavector
is clamped on V0.

the visible units and the hidden states are sampled from their
conditional distribution, which is factorial. Then, using al-
ternating Gibbs sampling, we run the Markov chain shown in
ﬁgure 4 until it reaches its stationary distribution and measure
the correlation <v1
j >. The gradient of the log probability
of the training data is then

i h1

@ log p(v0)

@wij

=<v0

i h0

j> (cid:0) <v1

i h1

j >

(5)

This learning rule is the same as the maximum likelihood
learning rule for the inﬁnite logistic belief net with tied
weights, and each step of Gibbs sampling corresponds to
computing the exact posterior distribution in a layer of the
inﬁnite logistic belief net.

Maximizing the log probability of the data is exactly
the same as minimizing the Kullback-Leibler divergence,
(cid:18) ), between the distribution of the data, P 0, and
KL(P 0jjP 1
the equilibrium distribution deﬁned by the model, P 1
In
(cid:18) .
contrastive divergence learning (Hinton, 2002), we only run
the Markov chain for n full steps3 before measuring the sec-
ond correlation. This is equivalent to ignoring the derivatives
3Each full step consists of updating h given v then updating v

given h.

t = 0                 t = 1 

                 t = 2              

t = infinity

j

j

j

j

<

i hv

00
j

>

<

¥

i hv

¥
j

>

i

 

i

 

i

i

                

t = infinity

Figure 4: This depicts a Markov chain that uses alternating
Gibbs sampling. In one full step of Gibbs sampling, the hid-
den units in the top layer are all updated in parallel by apply-
ing Eq. 1 to the inputs received from the the current states
of the visible units in the bottom layer, then the visible units
are all updated in parallel given the current hidden states. The
chain is initialized by setting the binary states of the visible
units to be the same as a data-vector. The correlations in the
activities of a visible and a hidden unit are measured after the
ﬁrst update of the hidden units and again at the end of the
chain. The difference of these two correlations provides the
learning signal for updating the weight on the connection.

that come from the higher layers of the inﬁnite net. The sum
of all these ignored derivatives is the derivative of the log
probability of the posterior distribution in layer Vn, which
is also the derivative of the Kullback-Leibler divergence be-
tween the posterior distribution in layer Vn, P n
(cid:18) , and the equi-
librium distribution deﬁned by the model. So contrastive di-
vergence learning minimizes the difference of two Kullback-
Leibler divergences:

KL(P 0jjP 1

(cid:18) ) (cid:0) KL(P n

(cid:18) jjP 1
(cid:18) )

(6)

Ignoring sampling noise, this difference is never negative
because Gibbs sampling is used to produce P n
(cid:18) from P 0 and
Gibbs sampling always reduces the Kullback-Leibler diver-
gence with the equilibrium distribution. It is important to no-
(cid:18) depends on the current model parameters and
tice that P n
(cid:18) changes as the parameters change is
the way in which P n
being ignored by contrastive divergence learning. This prob-
lem does not arise with P 0 because the training data does not
depend on the parameters. An empirical investigation of the
relationship between the maximum likelihood and the con-
trastive divergence learning rules can be found in Carreira-
Perpinan and Hinton (2005).

Contrastive divergence learning in a restricted Boltzmann
machine is efﬁcient enough to be practical (Mayraz and Hin-
ton, 2001). Variations that use real-valued units and differ-
ent sampling schemes are described in Teh et al. (2003) and
have been quite successful for modeling the formation of to-
pographic maps (Welling et al., 2003), for denoising natural
images (Roth and Black, 2005) or images of biological cells
(Ning et al., 2005). Marks and Movellan (2001) describe a
way of using contrastive divergence to perform factor analy-
sis and Welling et al. (2005) show that a network with logistic,
binary visible units and linear, Gaussian hidden units can be
used for rapid document retrieval. However, it appears that

the efﬁciency has been bought at a high price: When applied
in the obvious way, contrastive divergence learning fails for
deep, multilayer networks with different weights at each layer
because these networks take far too long even to reach condi-
tional equilibrium with a clamped data-vector. We now show
that the equivalence between RBM’s and inﬁnite directed nets
with tied weights suggests an efﬁcient learning algorithm for
multilayer networks in which the weights are not tied.

4 A greedy learning algorithm for

transforming representations

An efﬁcient way to learn a complicated model is to combine
a set of simpler models that are learned sequentially. To force
each model in the sequence to learn something different from
the previous models, the data is modiﬁed in some way after
each model has been learned.
In boosting (Freund, 1995),
each model in the sequence is trained on re-weighted data that
emphasizes the cases that the preceding models got wrong. In
one version of principal components analysis, the variance in
a modeled direction is removed thus forcing the next modeled
direction to lie in the orthogonal subspace (Sanger, 1989).
In projection pursuit (Friedman and Stuetzle, 1981), the data
is transformed by nonlinearly distorting one direction in the
data-space to remove all non-Gaussianity in that direction.
The idea behind our greedy algorithm is to allow each model
in the sequence to receive a different representation of the
data. The model performs a non-linear transformation on its
input vectors and produces as output the vectors that will be
used as input for the next model in the sequence.

Figure 5 shows a multilayer generative model in which the
top two layers interact via undirected connections and all of
the other connections are directed. The undirected connec-
tions at the top are equivalent to having inﬁnitely many higher
layers with tied weights. There are no intra-layer connections
and, to simplify the analysis, all layers have the same number
of units. It is possible to learn sensible (though not optimal)
values for the parameters W0 by assuming that the parame-
ters between higher layers will be used to construct a comple-
mentary prior for W0. This is equivalent to assuming that all
of the weight matrices are constrained to be equal. The task
of learning W0 under this assumption reduces to the task of
learning an RBM and although this is still difﬁcult, good ap-
proximate solutions can be found rapidly by minimizing con-
trastive divergence. Once W0 has been learned, the data can
be mapped through WT
0 to create higher-level “data” at the
ﬁrst hidden layer.

If the RBM is a perfect model of the original data, the
higher-level “data” will already be modeled perfectly by the
higher-level weight matrices. Generally, however, the RBM
will not be able to model the original data perfectly and we
can make the generative model better using the following
greedy algorithm:

1. Learn W0 assuming all the weight matrices are tied.
2. Freeze W0 and commit ourselves to using WT

0 to infer

Figure 5: A hybrid network. The top two layers have undi-
rected connections and form an associative memory. The lay-
ers below have directed, top-down, generative connections
that can be used to map a state of the associative memory
to an image. There are also directed, bottom-up, recognition
connections that are used to infer a factorial representation in
one layer from the binary activities in the layer below. In the
greedy initial learning the recognition connections are tied to
the generative connections.

factorial approximate posterior distributions over the
states of the variables in the ﬁrst hidden layer, even if
subsequent changes in higher level weights mean that
this inference method is no longer correct.

3. Keeping all the higher weight matrices tied to each
other, but untied from W0, learn an RBM model of the
0 to
higher-level “data” that was produced by using WT
transform the original data.

If this greedy algorithm changes the higher-level weight
matrices, it is guaranteed to improve the generative model.
As shown in (Neal and Hinton, 1998), the negative log prob-
ability of a single data-vector, v0, under the multilayer gen-
erative model is bounded by a variational free energy which
is the expected energy under the approximating distribution,
Q(h0jv0), minus the entropy of that distribution. For a di-
rected model, the “energy” of the conﬁguration v0; h0 is
given by:

E(v0; h0) = (cid:0)(cid:2)log p(h0) + log p(v0jh0)(cid:3)

(7)

So the bound is:
log p(v0) (cid:21) X
all h0
(cid:0) X
all h0

Q(h0jv0)(cid:2)log p(h0) + log p(v0jh0)(cid:3)

Q(h0jv0) log Q(h0jv0)

(8)

where h0 is a binary conﬁguration of the units in the ﬁrst hid-
den layer, p(h0) is the prior probability of h0 under the cur-
rent model (which is deﬁned by the weights above H0) and
Q((cid:1)jv0) is any probability distribution over the binary con-
ﬁgurations in the ﬁrst hidden layer. The bound becomes an
equality if and only if Q((cid:1)jv0) is the true posterior distribu-
tion.

When all of the weight matrices are tied together, the fac-
0 to a
torial distribution over H0 produced by applying WT
data-vector is the true posterior distribution, so at step 2 of
the greedy algorithm log p(v0) is equal to the bound. Step
2 freezes both Q((cid:1)jv0) and p(v0jh0) and with these terms
ﬁxed, the derivative of the bound is the same as the derivative
of

Q(h0jv0) log p(h0)

(9)

X
all h0

So maximizing the bound w.r.t. the weights in the higher lay-
ers is exactly equivalent to maximizing the log probability of
a dataset in which h0 occurs with probability Q(h0jv0). If
the bound becomes tighter, it is possible for log p(v0) to fall
even though the lower bound on it increases, but log p(v0)
can never fall below its value at step 2 of the greedy algo-
rithm because the bound is tight at this point and the bound
always increases.

The greedy algorithm can clearly be applied recursively,
so if we use the full maximum likelihood Boltzmann machine
learning algorithm to learn each set of tied weights and then
we untie the bottom layer of the set from the weights above,
we can learn the weights one layer at a time with a guar-
antee4 that we will never decrease the log probability of the
data under the full generative model. In practice, we replace
maximum likelihood Boltzmann machine learning algorithm
by contrastive divergence learning because it works well and
is much faster. The use of contrastive divergence voids the
guarantee, but it is still reassuring to know that extra layers
are guaranteed to improve imperfect models if we learn each
layer with sufﬁcient patience.

To guarantee that the generative model is improved by
greedily learning more layers, it is convenient to consider
models in which all layers are the same size so that the higher-
level weights can be initialized to the values learned before
they are untied from the weights in the layer below. The same
greedy algorithm, however, can be applied even when the lay-
ers are different sizes.

5 Back-Fitting with the up-down algorithm

Learning the weight matrices one layer at a time is efﬁcient
but not optimal. Once the weights in higher layers have been
learned, neither the weights nor the simple inference proce-
dure are optimal for the lower layers. The sub-optimality pro-
duced by greedy learning is relatively innocuous for super-
vised methods like boosting. Labels are often scarce and each

4The guarantee is on the expected change in the log probability.

label may only provide a few bits of constraint on the parame-
ters, so over-ﬁtting is typically more of a problem than under-
ﬁtting. Going back and reﬁtting the earlier models may, there-
fore, cause more harm than good. Unsupervised methods,
however, can use very large unlabeled datasets and each case
may be very high-dimensional thus providing many bits of
constraint on a generative model. Under-ﬁtting is then a se-
rious problem which can be alleviated by a subsequent stage
of back-ﬁtting in which the weights that were learned ﬁrst are
revised to ﬁt in better with the weights that were learned later.

After greedily learning good initial values for the weights
in every layer, we untie the “recognition” weights that are
used for inference from the “generative” weights that de-
ﬁne the model, but retain the restriction that the posterior in
each layer must be approximated by a factorial distribution in
which the variables within a layer are conditionally indepen-
dent given the values of the variables in the layer below. A
variant of the wake-sleep algorithm described in Hinton et al.
(1995) can then be used to allow the higher-level weights to
inﬂuence the lower level ones. In the “up-pass”, the recog-
nition weights are used in a bottom-up pass that stochasti-
cally picks a state for every hidden variable. The generative
weights on the directed connections are then adjusted using
the maximum likelihood learning rule in Eq. 25. The weights
on the undirected connections at the top level are learned as
before by ﬁtting the top-level RBM to the posterior distribu-
tion of the penultimate layer.

The “down-pass” starts with a state of the top-level asso-
ciative memory and uses the top-down generative connections
to stochastically activate each lower layer in turn. During
the down-pass, the top-level undirected connections and the
generative directed connections are not changed. Only the
bottom-up recognition weights are modiﬁed. This is equiva-
lent to the sleep phase of the wake-sleep algorithm if the as-
sociative memory is allowed to settle to its equilibrium distri-
bution before initiating the down-pass. But if the associative
memory is initialized by an up-pass and then only allowed to
run for a few iterations of alternating Gibbs sampling before
initiating the down-pass, this is a “contrastive” form of the
wake-sleep algorithm which eliminates the need to sample
from the equilibrium distribution of the associative memory.
The contrastive form also ﬁxes several other problems of the
sleep phase. It ensures that the recognition weights are being
learned for representations that resemble those used for real
data and it also helps to eliminate the problem of mode aver-
aging. If, given a particular data vector, the current recogni-
tion weights always pick a particular mode at the level above
and ignore other very different modes that are equally good at
generating the data, the learning in the down-pass will not try
to alter those recognition weights to recover any of the other
modes as it would if the sleep phase used a pure ancestral
pass. A pure ancestral pass would have to start by using pro-
longed Gibbs sampling to get an equilibrium sample from the
top-level associative memory. By using a top-level associa-

5Because weights are no longer tied to the weights above them,
i must be computed using the states of the variables in the layer
^v0
above i and the generative weights from these variables to i.

Figure 6: All 49 cases in which the network guessed right but
had a second guess whose probability was within 0:3 of the
probability of the best guess. The true classes are arranged in
standard scan order.

tive memory we also eliminate a problem in the wake phase:
Independent top-level units seem to be required to allow an
ancestral pass, but they mean that the variational approxima-
tion is very poor for the top layer of weights.

Appendix B speciﬁes the details of the up-down algorithm
using matlab-style pseudo-code for the network shown in ﬁg-
ure 1. For simplicity, there is no penalty on the weights, no
momentum, and the same learning rate for all parameters.
Also, the training data is reduced to a single case.

6 Performance on the MNIST database

6.1 Training the network

The MNIST database of handwritten digits contains 60,000
training images and 10,000 test images. Results for many
different pattern recognition techniques are already published
for this publicly available database so it is ideal for evaluating
new pattern recognition methods. For the “basic” version of
the MNIST learning task, no knowledge of geometry is pro-
vided and there is no special pre-processing or enhancement
of the training set, so an unknown but ﬁxed random permuta-
tion of the pixels would not affect the learning algorithm. For
this “permutation-invariant” version of the task, the general-
ization performance of our network was 1.25% errors on the
ofﬁcial test set. The network6 shown in ﬁgure 1 was trained
on 44,000 of the training images that were divided into 440
balanced mini-batches each containing 10 examples of each
digit class. The weights were updated after each mini-batch.

6Preliminary experiments with 16 (cid:2) 16 images of handwritten
digits from the USPS database showed that a good way to model
the joint distribution of digit images and their labels was to use an
architecture of this type, but for 16 (cid:2) 16 images, only 3=5 as many
units were used in each hidden layer.

Figure 7: The 125 test cases that the network got wrong. Each
case is labeled by the network’s guess. The true classes are
arranged in standard scan order.

In the initial phase of training, the greedy algorithm de-
scribed in section 4 was used to train each layer of weights
separately, starting at the bottom. Each layer was trained for
30 sweeps through the training set (called “epochs”). Dur-
ing training, the units in the “visible” layer of each RBM had
real-valued activities between 0 and 1. These were the nor-
malized pixel intensities when learning the bottom layer of
weights. For training higher layers of weights, the real-valued
activities of the visible units in the RBM were the activation
probabilities of the hidden units in the lower-level RBM. The
hidden layer of each RBM used stochastic binary values when
that RBM was being trained. The greedy training took a few
hours per layer in Matlab on a 3GHz Xeon processor and
when it was done, the error-rate on the test set was 2.49%
(see below for details of how the network is tested).

When training the top layer of weights (the ones in the
associative memory) the labels were provided as part of the
input. The labels were represented by turning on one unit in a
“softmax” group of 10 units. When the activities in this group
were reconstructed from the activities in the layer above, ex-
actly one unit was allowed to be active and the probability of

picking unit i was given by:

pi =

exp(xi)
Pj exp(xj)

(10)

where xi is the total input received by unit i. Curiously,
the learning rules are unaffected by the competition between
units in a softmax group, so the synapses do not need to know
which unit is competing with which other unit. The competi-
tion affects the probability of a unit turning on, but it is only
this probability that affects the learning.

After the greedy layer-by-layer training, the network was
trained, with a different learning rate and weight-decay, for
300 epochs using the up-down algorithm described in section
5. The learning rate, momentum, and weight-decay7 were
chosen by training the network several times and observing
its performance on a separate validation set of 10,000 im-
ages that were taken from the remainder of the full training
set. For the ﬁrst 100 epochs of the up-down algorithm, the
up-pass was followed by three full iterations of alternating
Gibbs sampling in the associative memory before perform-
ing the down-pass. For the second 100 epochs, six iterations
were performed, and for the last 100 epochs, ten iterations
were performed. Each time the number of iterations of Gibbs
sampling was raised, the error on the validation set decreased
noticeably.

The network that performed best on the validation set was
then tested and had an error rate of 1.39%. This network was
then trained on all 60,000 training images8 until its error-rate
on the full training set was as low as its ﬁnal error-rate had
been on the initial training set of 44,000 images. This took
a further 59 epochs making the total learning time about a
week. The ﬁnal network had an error-rate of 1.25%9. The
errors made by the network are shown in ﬁgure 7. The 49
cases that the network gets correct but for which the second
best probability is within 0.3 of the best probability are shown
in ﬁgure 6.

The error-rate of 1.25% compares very favorably with the
error-rates achieved by feed-forward neural networks that
have one or two hidden layers and are trained to optimize
discrimination using the back-propagation algorithm (see ta-
ble 1, appearing after the references). When the detailed
connectivity of these networks is not hand-crafted for this

7No attempt was made to use different learning rates or weight-
decays for different layers and the learning rate and momentum were
always set quite conservatively to avoid oscillations.
It is highly
likely that the learning speed could be considerably improved by a
more careful choice of learning parameters, though it is possible that
this would lead to worse solutions.

8The training set has unequal numbers of each class, so images

were assigned randomly to each of the 600 mini-batches.

9To check that further learning would not have signiﬁcantly im-
proved the error-rate, the network was then left running with a very
small learning rate and with the test error being displayed after ev-
ery epoch. After six weeks the test error was ﬂuctuating between
1.12% and 1.31% and was 1.18% for the epoch on which number of
training errors was smallest.

particular task, the best reported error-rate for stochastic on-
line learning with a separate squared error on each of the 10
output units is 2.95%. These error-rates can be reduced to
1.53% in a net with one hidden layer of 800 units by using
small initial weights, a separate cross-entropy error function
on each output unit, and very gentle learning (John Platt, per-
sonal communication). An almost identical result of 1.51%
was achieved in a net that had 500 units in the ﬁrst hidden
layer and 300 in the second hidden layer by using “soft-
max” output units and a regularizer that penalizes the squared
weights by an amount that is carefully chosen using a valida-
tion set. For comparison, nearest neighbor has a reported er-
ror rate (http://oldmill.uchicago.edu/ wilder/Mnist/) of 3.1%
if all 60,000 training cases are used (which is extremely slow)
and 4.4% if 20,000 are used. This can be reduced to 2.8% and
4.0% by using an L3 norm.

The only standard machine learning technique that comes
close to the 1.25% error rate of our generative model on the
basic task is a support vector machine which gives an er-
ror rate of 1.4% (Decoste and Schoelkopf, 2002). But it
is hard to see how support vector machines can make use
of the domain-speciﬁc tricks, like weight-sharing and sub-
sampling, which LeCun et al. (1998) use to improve the per-
formance of discriminative neural networks from 1.5% to
0.95%. There is no obvious reason why weight-sharing and
sub-sampling cannot be used to reduce the error-rate of the
generative model and we are currently investigating this ap-
proach. Further improvements can always be achieved by av-
eraging the opinions of multiple networks, but this technique
is available to all methods.

Substantial reductions in the error-rate can be achieved by
supplementing the data set with slightly transformed versions
of the training data. Using one and two pixel translations
Decoste and Schoelkopf (2002) achieve 0:56%. Using lo-
cal elastic deformations in a convolutional neural network,
Simard et al. (2003) achieve 0:4% which is slightly better
than the 0:63% achieved by the best hand-coded recognition
algorithm (Belongie et al., 2002). We have not yet explored
the use of distorted data for learning generative models be-
cause many types of distortion need to be investigated and
the ﬁne-tuning algorithm is currently too slow.

6.2 Testing the network

One way to test the network is to use a stochastic up-pass
from the image to ﬁx the binary states of the 500 units in
the lower layer of the associative memory. With these states
ﬁxed, the label units are given initial real-valued activities of
0:1 and a few iterations of alternating Gibbs sampling are then
used to activate the correct label unit. This method of testing
gives error rates that are almost 1% higher than the rates re-
ported above.

A better method is to ﬁrst ﬁx the binary states of the 500
units in the lower layer of the associative memory and to then
turn on each of the label units in turn and compute the ex-
act free energy of the resulting 510 component binary vector.

Figure 8: Each row shows 10 samples from the generative
model with a particular label clamped on. The top-level asso-
ciative memory is run for 1000 iterations of alternating Gibbs
sampling between samples.

Almost all the computation required is independent of which
label unit is turned on (Teh and Hinton, 2001) and this method
computes the exact conditional equilibrium distribution over
labels instead of approximating it by Gibbs sampling which
is what the previous method is doing. This method gives er-
ror rates that are about 0.5% higher than the ones quoted be-
cause of the stochastic decisions made in the up-pass. We
can remove this noise in two ways. The simplest is to make
the up-pass deterministic by using probabilities of activation
in place of stochastic binary states. The second is to repeat
the stochastic up-pass twenty times and average either the la-
bel probabilities or the label log probabilities over the twenty
repetitions before picking the best one. The two types of av-
erage give almost identical results and these results are also
very similar to using a deterministic up-pass, which was the
method used for the reported results.

7 Looking into the mind of a neural network

To generate samples from the model, we perform alternating
Gibbs sampling in the top-level associative memory until the
Markov chain converges to the equilibrium distribution. Then
we use a sample from this distribution as input to the layers
below and generate an image by a single down-pass through
the generative connections. If we clamp the label units to a
particular class during the Gibbs sampling we can see im-
ages from the model’s class-conditional distributions. Figure
8 shows a sequence of images for each class that were gener-
ated by allowing 1000 iterations of Gibbs sampling between
samples.

We can also initialize the state of the top two layers by
providing a random binary image as input. Figure 9 shows
how the class-conditional state of the associative memory
then evolves when it is allowed to run freely, but with the

Figure 9: Each row shows 10 samples from the generative
model with a particular label clamped on. The top-level as-
sociative memory is initialized by an up-pass from a random
binary image in which each pixel is on with a probability of
0:5. The ﬁrst column shows the results of a down-pass from
this initial high-level state. Subsequent columns are produced
by 20 iterations of alternating Gibbs sampling in the associa-
tive memory.

label clamped. This internal state is “observed” by perform-
ing a down-pass every 20 iterations to see what the associa-
tive memory has in mind. This use of the word “mind” is
not intended to be metaphorical. We believe that a mental
state is the state of a hypothetical, external world in which a
high-level internal representation would constitute veridical
perception. That hypothetical world is what the ﬁgure shows.

8 Conclusion

We have shown that it is possible to learn a deep, densely-
connected, belief network one layer at a time. The obvious
way to do this is to assume that the higher layers do not ex-
ist when learning the lower layers, but this is not compatible
with the use of simple factorial approximations to replace the
intractable posterior distribution. For these approximations to
work well, we need the true posterior to be as close to facto-
rial as possible. So instead of ignoring the higher layers, we
assume that they exist but have tied weights which are con-
strained to implement a complementary prior that makes the
true posterior exactly factorial. This is equivalent to having
an undirected model which can be learned efﬁciently using
contrastive divergence. It can also be viewed as constrained
variational learning because a penalty term – the divergence
between the approximate and true posteriors – has been re-
placed by the constraint that the prior must make the varia-
tional approximation exact.

After each layer has been learned, its weights are untied
from the weights in higher layers. As these higher-level
weights change, the priors for lower layers cease to be com-

plementary, so the true posterior distributions in lower layers
are no longer factorial and the use of the transpose of the gen-
erative weights for inference is no longer correct. Neverthe-
less, we can use a variational bound to show that adapting the
higher-level weights improves the overall generative model.

To demonstrate the power of our fast, greedy learning
algorithm, we used it to initialize the weights for a much
slower ﬁne-tuning algorithm that learns an excellent gener-
ative model of digit images and their labels. It is not clear
that this is the best way to use the fast, greedy algorithm. It
might be better to omit the ﬁne-tuning and use the speed of
the greedy algorithm to learn an ensemble of larger, deeper
networks or a much larger training set. The network in ﬁgure
1 has about as many parameters as 0:002 cubic millimeters
of mouse cortex (Horace Barlow, pers. comm.), and several
hundred networks of this complexity could ﬁt within a sin-
gle voxel of a high resolution fMRI scan. This suggests that
much bigger networks may be required to compete with hu-
man shape recognition abilities.

Our current generative model is limited in many ways (Lee
and Mumford, 2003). It is designed for images in which non-
binary values can be treated as probabilities (which is not the
case for natural images); its use of top-down feedback during
perception is limited to the associative memory in the top two
layers; it does not have a systematic way of dealing with per-
ceptual invariances; it assumes that segmentation has already
been performed and it does not learn to sequentially attend to
the most informative parts of objects when discrimination is
difﬁcult. It does, however, illustrate some of the major ad-
vantages of generative models as compared to discriminative
ones:

1. Generative models can learn low-level features with-
out requiring feedback from the label and they can
learn many more parameters than discriminative mod-
els without overﬁtting. In discriminative learning, each
training case only constrains the parameters by as many
bits of information as are required to specify the label.
For a generative model, each training case constrains
the parameters by the number of bits required to spec-
ify the input.

2. It is easy to see what the network has learned by gener-

ating from its model.

3. It is possible to interpret the non-linear, distributed rep-
resentations in the deep hidden layers by generating im-
ages from them.

4. The superior classiﬁcation performance of discrimina-
tive learning methods only holds for domains in which
it is not possible to learn a good generative model. This
set of domains is being eroded by Moore’s law.

Acknowledgments
We thank Peter Dayan, Zoubin Ghahramani, Yann Le Cun,
Andriy Mnih, Radford Neal, Terry Sejnowski and Max
Welling for helpful discussions and the referees for greatly
improving the manuscript. The research was supported by

NSERC, the Gatsby Charitable Foundation, CFI and OIT.
GEH is a fellow of the Canadian Institute for Advanced Re-
search and holds a Canada Research Chair in machine learn-
ing.

References
Belongie, S., Malik, J., and Puzicha, J. (2002). Shape match-
ing and object recognition using shape contexts.
IEEE
Transactions on Pattern Analysis and Machine Intelli-
gence, 24(4):509–522.

Carreira-Perpinan, M. A. and Hinton, G. E. (2005). On con-
trastive divergence learning. In Artiﬁcial Intelligence and
Statistics, 2005.

Decoste, D. and Schoelkopf, B. (2002). Training invariant
support vector machines. Machine Learning, 46:161–190.
Freund, Y. (1995). Boosting a weak learning algorithm by
majority. Information and Computation, 12(2):256 – 285.
Friedman, J. and Stuetzle, W. (1981). Projection pursuit re-
gression. Journal of the American Statistical Association,
76:817–823.

Hinton, G. E. (2002).

Training products of experts by
minimizing contrastive divergence. Neural Computation,
14(8):1711–1800.

Hinton, G. E., Dayan, P., Frey, B. J., and Neal, R. (1995). The
wake-sleep algorithm for self-organizing neural networks.
Science, 268:1158–1161.

LeCun, Y., Bottou, L., and Haffner, P. (1998). Gradient-based
learning applied to document recognition. Proceedings of
the IEEE, 86(11):2278–2324.

Lee, T. S. and Mumford, D. (2003). Hierarchical bayesian in-
ference in the visual cortex. Journal of the Optical Society
of America, A., 20:1434–1448.

Marks, T. K. and Movellan, J. R. (2001). Diffusion networks,
product of experts, and factor analysis. In Proc. Int. Conf.
on Independent Component Analysis, pages 481–485.

Mayraz, G. and Hinton, G. E. (2001). Recognizing hand-
written digits using hierarchical products of experts. IEEE
Transactions on Pattern Analysis and Machine Intelli-
gence, 24:189–197.

Neal, R. (1992). Connectionist learning of belief networks.

Artiﬁcial Intelligence, 56:71–113.

Neal, R. M. and Hinton, G. E. (1998). A new view of the
EM algorithm that justiﬁes incremental, sparse and other
variants. In Jordan, M. I., editor, Learning in Graphical
Models, pages 355—368. Kluwer Academic Publishers.

Ning, F., Delhomme, D., LeCun, Y., Piano, F., Bottou, L.,
and Barbano, P. (2005). Toward automatic phenotyping of
developing embryos from videos. IEEE Transactions on
Image Processing, 14(9):1360–1371.

Pearl, J. (1988). Probabilistic Inference in Intelligent Sys-
tems: Networks of Plausible Inference. Morgan Kauf-
mann, San Mateo, CA.

Roth, S. and Black, M. J. (2005). Fields of experts: A frame-
work for learning image priors. In IEEE Conf. on Com-
puter Vision and Pattern Recognition.

Sanger, T. D. (1989). Optimal unsupervised learning in a
single-layer linear feedforward neural. Neural Networks,
2(6):459–473.

Simard, P. Y., Steinkraus, D., and Platt, J. (2003). Best prac-
tice for convolutional neural networks applied to visual
document analysis. In International Conference on Docu-
ment Analysis and Recogntion (ICDAR), IEEE Computer
Society, Los Alamitos, pages 958–962.

Teh, Y. and Hinton, G. E. (2001). Rate-coded restricted Boltz-
mann machines for face recognition. In Advances in Neu-
ral Information Processing Systems, volume 13.

Teh, Y., Welling, M., Osindero, S., and Hinton, G. E. (2003).
Energy-based models for sparse overcomplete representa-
tions. Journal of Machine Learning Research, 4:1235–
1260.

Welling, M., Hinton, G., and Osindero, S. (2003). Learn-
ing sparse topographic representations with products of
Student-t distributions.
In S. Becker, S. T. and Ober-
mayer, K., editors, Advances in Neural Information Pro-
cessing Systems 15, pages 1359–1366. MIT Press, Cam-
bridge, MA.

Welling, M., Rosen-Zvi, M., and Hinton, G. E. (2005). Expo-
nential family harmoniums with an application to informa-
tion retrieval. In Advances in Neural Information Process-
ing Systems 17, pages 1481–1488. MIT Press, Cambridge,
MA.

9 Tables

Version of MNIST task
permutation-invariant

Learning algorithm
Our generative model

permutation-invariant

permutation-invariant

permutation-invariant

permutation-invariant

permutation-invariant

permutation-invariant

permutation-invariant

permutation-invariant

784(cid:0)>500(cid:0)>500 <(cid:0)(cid:0)>2000 <(cid:0)(cid:0)>10

Support Vector Machine

degree 9 polynomial kernel

Backprop 784(cid:0)>500(cid:0)>300(cid:0)>10
cross-entropy & weight-decay

Backprop 784(cid:0)>800(cid:0)>10

cross-entropy & early stopping
Backprop 784(cid:0)>500(cid:0)>150(cid:0)>10
squared error & on-line updates

Nearest Neighbor

All 60,000 examples & L3 norm

Nearest Neighbor

All 60,000 examples & L2 norm

Nearest Neighbor

20,000 examples & L3 norm

Nearest Neighbor

20,000 examples & L2 norm

unpermuted images

extra data from

elastic deformations
unpermuted deskewed

images, extra data
from 2 pixel transl.
unpermuted images

unpermuted images

extra data from

afﬁne transformations
Unpermuted images

Backprop

cross-entropy & early-stopping

convolutional neural net

Virtual SVM

degree 9 polynomial kernel

Shape-context features
hand-coded matching
Backprop in LeNet5

convolutional neural net

Backprop in LeNet5

convolutional neural net

Test error %

1.25

1.4

1.51

1.53

2.95

2.8

3.1

4.0

4.4

0.4

0.56

0.63

0.8

0.95

Table 1: The error rates of various learning algorithms on the MNIST digit recognition task. See text for details.

10 Appendix

A Complementary Priors

General complementarity

Consider a joint distribution over observables, x, and hidden variables, y. For a given likelihood function, P (xjy), we deﬁne
the corresponding family of complementary priors to be those distributions, P (y), for which the joint distribution, P (x; y) =
P (xjy)P (y), leads to posteriors, P (yjx), that exactly factorise, i.e. leads to a posterior that can be expressed as P (yjx) =
Qj P (yjjx).

Not all functional forms of likelihood admit a complementary prior. In this appendix we will show that the following family

constitutes all likelihood functions admitting a complementary prior:

P (xjy) =

1

(cid:10)(y)

exp0

j

(cid:8)j(x; yj) + (cid:12)(x)1
A

@X
(cid:8)j(x; yj) + (cid:12)(x) (cid:0) log (cid:10)(y)1
A

= exp0

@X

j

(11)

where (cid:10) is the normalisation term. For this assertion to hold we need to assume positivity of distributions: that both P (y) > 0
and P (xjy) > 0 for every value of y and x. The corresponding family of complementary priors then assume the form:

P (y) =

1
C

exp0

@log (cid:10)(y) + X

j

(cid:11)j(yj)1
A

(12)

where C is a constant to ensure normalisation. This combination of functional forms leads to the following expression for the
joint:

P (x; y) =

1
C

exp0

@X

j

(cid:8)j(x; yj) + (cid:12)(x) + X

j

(cid:11)j(yj)1
A

(13)

To prove our assertion, we need to show that every likelihood function of the form in Eq. 11 admits a complementary
prior, and also that complementarity implies the functional form in Eq. 11. Firstly, it can be directly veriﬁed that Eq. 12 is a
complementary prior for the likelihood functions of Eq. 11. To show the converse, let us assume that P (y) is a complementary
prior for some likelihood function P (xjy). Notice that the factorial form of the posterior simply means that the joint distribution
P (x; y) = P (y)P (xjy) satisﬁes the following set of conditional independencies: yj ?? yk j x for every j 6= k. This set of
conditional independencies is exactly those satisﬁed by an undirected graphical model with an edge between every hidden
variable and observed variable and among all observed variables (Pearl, 1988). By the Hammersley-Clifford Theorem, and
using our positivity assumption, the joint distribution must be of the form of Eq. 13, and the forms for the likelihood function
Eq. 11 and prior Eq. 12 follow from this.

Complementarity for inﬁnite stacks

We now consider a subset of models of the form in Eq. 13 for which the likelihood also factorises. This means that we now
have two sets of conditional independencies:

P (xjy) = Y

i

P (yjx) = Y

j

P (xijy)

P (yjjx)

(14)

(15)

This condition is useful for our construction of the inﬁnite stack of directed graphical models.

Identifying the conditional independencies in Eq. 14 and 15 as those satisﬁed by a complete bipartite undirected graph-
ical model, and again using the Hammersley-Clifford Theorem (assuming positivity), we see that the following form fully

characterises all joint distributions of interest,

P (x; y) =

1
Z

exp0

@X

i;j

(cid:9)i;j(xi; yj) + X

i

(cid:13)i(xi) + X

j

(cid:11)j(yj)1
A

while the likelihood functions take on the form,

P (xjy) = exp0

@X

i;j

(cid:9)i;j(xi; yj) + X

i

(cid:13)i(xi) (cid:0) log (cid:10)(y)1
A

(16)

(17)

Although it is not immediately obvious, the marginal distribution over the observables, x, in Eq. 16 can also be expressed

as an inﬁnite directed model in which the parameters deﬁning the conditional distributions between layers are tied together.

An intuitive way of validating of this assertion is as follows. Consider one of the methods by which we might draw samples
from the marginal distribution P (x) implied by Eq. 16. Starting from an arbitrary conﬁguration of y we would iteratively
perform Gibbs sampling using, in alternation, the distributions given in Eq. 14 and 15. If we run this Markov chain for long
enough then, since our positivity assumptions ensure that the chain mixes properly, we will eventually obtain unbiased samples
from the joint distribution given in Eq. 16.

Now let us imagine that we unroll this sequence of Gibbs updates in space — such that we consider each parallel update of
the variables to constitute states of a separate layer in a graph. This unrolled sequence of states has a purely directed structure
(with conditional distributions taking the form of Eq. 14 and 15 in alternation). By equivalence to the Gibbs sampling scheme,
after many layers in such an unrolled graph, adjacent pairs of layers will have a joint distribution as given in Eq. 16.

We can formalize this intuition for unrolling the graph as follows. The basic idea is to construct a joint distribution by
unrolling a graph “upwards” (i.e. moving away from the data-layer to successively deeper hidden layers), so that we can put a
well-deﬁned distribution over an inﬁnite stack of variables. Then we verify some simple marginal and conditional properties
of this joint distribution, and show that our construction is the same as that obtained by unrolling the graph downwards from a
very deep layer.

Let x = x(0); y = y(0); x(1); y(1); x(2); y(2); : : : be a sequence (stack) of variables the ﬁrst two of which are identiﬁed as
our original observed and hidden variables, while x(i) and y(i) are interpreted as a sequence of successively deeper layers.
First, deﬁne the functions

f (x0; y0) =

1
Z

exp0

@X

i;j

(cid:9)i;j(x0

i; y0

i) + X

i

fx(x0) = X

y0

fy(y0) = X

x0

f (x0; y0)

f (x0; y0)

gx(x0jy0) = f (x0; y0)=fy(y0)
gy(y0jx0) = f (x0; y0)=fx(x0)

(cid:13)i(x0

i) + X

j

(cid:11)j(y0

j)1
A

(18)

(19)

(20)

(21)
(22)

over dummy variables y0, x0. Now deﬁne a joint distribution over our sequence of variables (assuming ﬁrst-order Markovian
dependency) as follows:

P (x(0); y(0)) = f (x(0); y(0))

P (x(i)jy(i(cid:0)1)) = gx(x(i)jy(i(cid:0)1))

P (y(i)jx(i)) = gy(y(i)jx(i))

i = 1; 2; : : :

i = 1; 2; : : :

We verify by induction that the distribution has the following marginal distributions:

P (x(i)) = fx(x(i))
P (y(i)) = fy(y(i))

i = 0; 1; 2; : : :

i = 0; 1; 2; : : :

(23)
(24)
(25)

(26)
(27)

For i = 0 this is given by deﬁnition of the distribution in Eq. 23 and by Eqs. 19 and 20. For i > 0, we have:

P (x(i)) = X

y(i(cid:0)1)

P (x(i)jy(i(cid:0)1))P (y(i(cid:0)1)) = X

y(i(cid:0)1)

f (x(i); y(i(cid:0)1))

fy(y(i(cid:0)1))

fy(y(i(cid:0)1)) = fx(x(i))

(28)

and similarly for P (y(i)). Now we see that the following “downward” conditional distributions also hold true:

P (x(i)jy(i)) = P (x(i); y(i))=P (y(i)) = gx(x(i)jy(i))

(29)
(30)
So our joint distribution over the stack of variables also gives the unrolled graph in the “downward” direction, since the con-
ditional distributions in Eq. 29 and 30 are the same as those used to generate a sample in a downwards pass and the Markov
chain mixes.

P (y(i)jx(i+1)) = P (y(i); x(i+1))=P (x(i+1)) = gy(y(i)jx(i+1))

Inference in this inﬁnite stack of directed graphs is equivalent to inference in the joint distribution over the sequence of
variables. In other words, given x(0) we can simply use the deﬁnition of the joint distribution Eqs. 23, 24 and 25 to obtain
a sample from the posterior simply by sampling y(0)jx(0), x(1)jy(0), y(1)jx(1), : : :. This directly shows that our inference
procedure is exact for the unrolled graph.

B Pseudo-Code For Up-Down Algorithm

We now present “MATLAB-style” pseudo-code for an implementation of the up-down algorithm described in section 5 and
used for back-ﬁtting. (This method is a contrastive version of the wake-sleep algorithm (Hinton et al., 1995).)

The code outlined below assumes a network of the type shown in Figure 1 with visible inputs, label nodes, and three layers
of hidden units. Before applying the up-down algorithm, we would ﬁrst perform layer-wise greedy training as described in
sections 3 and 4.

\% UP-DOWN ALGORITHM
\%
\% the data and all biases are row vectors.
\% the generative model is: lab <--> top <--> pen --> hid --> vis
\% the number of units in layer foo is numfoo
\% weight matrices have names fromlayer_tolayer
\% "rec" is for recognition biases and "gen" is for generative biases.
\% for simplicity, the same learning rate, r, is used everywhere.

\% PERFORM A BOTTOM-UP PASS TO GET WAKE/POSITIVE PHASE PROBABILITIES
\% AND SAMPLE STATES
wakehidprobs = logistic(data*vishid + hidrecbiases);
wakehidstates = wakehidprobs > rand(1, numhid);
wakepenprobs = logistic(wakehidstates*hidpen + penrecbiases);
wakepenstates = wakepenprobs > rand(1, numpen);
postopprobs
postopstates

= logistic(wakepenstates*pentop + targets*labtop + topbiases);
= waketopprobs > rand(1, numtop));

\% POSITIVE PHASE STATISTICS FOR CONTRASTIVE DIVERGENCE
poslabtopstatistics = targets’ * waketopstates;
pospentopstatistics

= wakepenstates’ * waketopstates;

\% PERFORM numCDiters GIBBS SAMPLING ITERATIONS USING THE TOP LEVEL
\% UNDIRECTED ASSOCIATIVE MEMORY
negtopstates = waketopstates; \% to initialize loop
for iter=1:numCDiters

negpenprobs = logistic(negtopstates*pentop’ + pengenbiases);
negpenstates = negpenprobs > rand(1, numpen);
neglabprobs = softmax(negtopstates*labtop’ + labgenbiases);
negtopprobs = logistic(negpenstates*pentop+neglabprobs*labtop+topbiases);
negtopstates = negtopprobs > rand(1, numtop));

end;
\% NEGATIVE PHASE STATISTICS FOR CONTRASTIVE DIVERGENCE
negpentopstatistics = negpenstates’*negtopstates;
neglabtopstatistics = neglabprobs’*negtopstates;

\% STARTING FROM THE END OF THE GIBBS SAMPLING RUN, PERFORM A
\% TOP-DOWN GENERATIVE PASS TO GET SLEEP/NEGATIVE PHASE PROBABILITIES
\% AND SAMPLE STATES
sleeppenstates = negpenstates;
sleephidprobs = logistic(sleeppenstates*penhid + hidgenbiases);
sleephidstates = sleephidprobs > rand(1, numhid);
sleepvisprobs = logistic(sleephidstates*hidvis + visgenbiases);

\% PREDICTIONS
psleeppenstates = logistic(sleephidstates*hidpen + penrecbiases);
psleephidstates = logistic(sleepvisprobs*vishid + hidrecbiases);
pvisprobs
phidprobs

= logistic(wakehidstates*hidvis + visgenbiases);
= logistic(wakepenstates*penhid + hidgenbiases);

\% UPDATES TO GENERATIVE PARAMETERS
-hidvis
visgenbiases = visgenbiases + r*(data - pvisprobs);
penhid = penhid + r*wakepenstates’*(wakehidstates-phidprobs);
hidgenbiases = hidgenbiases + r*(wakehidstates - phidprobs);

= hidvis + r*poshidstates’*(data-pvisprobs);

\% UPDATES TO TOP LEVEL ASSOCIATIVE MEMORY PARAMETERS
labtop = labtop + r*(poslabtopstatistics-neglabtopstatistics);
labgenbiases = labgenbiases + r*(targets - neglabprobs);
pentop
pengenbiases = pengenbiases + r*(wakepenstates - negpenstates);
topbiases = topbiases + r*(waketopsates - negtopstates);

= pentop + r*(pospentopstatistics - negpentopstatistics);

\%UPDATES TO RECOGNITION/INFERENCE APPROXIMATION PARAMETERS
hidpen = hidpen + r*(sleephidstates’*(sleeppenstates-psleeppenstates));
penrecbiases = penrecbiases + r*(sleeppenstates-psleeppenstates);
vishid = vishid + r*(sleepvisprobs’*(sleephidstates-psleephidstates));
hidrecbiases = hidrecbiases + r*(sleephidstates-psleephidstates);

