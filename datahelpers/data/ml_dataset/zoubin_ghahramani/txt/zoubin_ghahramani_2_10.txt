Unsupervised Learning∗

Zoubin Ghahramani†

Gatsby Computational Neuroscience Unit

University College London, UK

zoubin@gatsby.ucl.ac.uk

http://www.gatsby.ucl.ac.uk/~zoubin

September 16, 2004

Abstract

We give a tutorial and overview of the ﬁeld of unsupervised learning from the perspective of statistical
modelling. Unsupervised learning can be motivated from information theoretic and Bayesian principles.
We brieﬂy review basic models in unsupervised learning, including factor analysis, PCA, mixtures of
Gaussians, ICA, hidden Markov models, state-space models, and many variants and extensions. We
derive the EM algorithm and give an overview of fundamental concepts in graphical models, and inference
algorithms on graphs. This is followed by a quick tour of approximate Bayesian inference, including
Markov chain Monte Carlo (MCMC), Laplace approximation, BIC, variational approximations, and
expectation propagation (EP). The aim of this chapter is to provide a high-level view of the ﬁeld. Along
the way, many state-of-the-art ideas and future directions are also reviewed.

Contents

1 Introduction

1.1 What is unsupervised learning? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.2 Machine learning, statistics, and information theory . . . . . . . . . . . . . . . . . . . . . . .
1.3 Bayes rule . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

2 Latent variable models

2.1 Factor analysis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.2 Principal components analysis (PCA)
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Independent components analysis (ICA) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.3
2.4 Mixture of Gaussians . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.5 K-means . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

3 The EM algorithm

4 Modelling time series and other structured data

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.1 State-space models (SSMs)
4.2 Hidden Markov models (HMMs)
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.3 Modelling other structured data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

5 Nonlinear, Factorial, and Hierarchical Models

3
3
4
4

6
6
7
7
7
8

8

9
10
10
11

11

6 Intractability

12
∗This chapter will appear in Bousquet, O., Raetsch, G. and von Luxburg, U. (eds) Advanced Lectures on Machine Learning
†The author is also at the Center for Automated Learning and Discovery, Carnegie Mellon University, USA.

LNAI 3176. c(cid:13)Springer-Verlag.

1

13
13
14
14
15

15
16
16
18
18
19

19
20
20
20
21
21
21

21

22
23
23
24
24
25

27

7 Graphical models

7.1 Undirected graphs
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
7.2 Factor graphs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
7.3 Directed graphs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
7.4 Expressive power . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

8 Exact inference in graphs

8.1 Elimination . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
8.2 Belief propagation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
8.3 Factor graph propagation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
8.4 Junction tree algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
8.5 Cutest conditioning . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

9 Learning in graphical models
9.1 Learning graph parameters

9.2.1
9.2.2

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
9.1.1 The complete data case. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
9.1.2 The incomplete data case. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
9.2 Learning graph structure . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Scoring metrics.
Search algorithms.

10 Bayesian model comparison and Occam’s Razor

11 Approximating posteriors and marginal likelihoods

11.1 Laplace approximation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
11.2 The Bayesian information criterion (BIC) . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
11.3 Markov chain Monte Carlo (MCMC) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
11.4 Variational approximations
11.5 Expectation propagation (EP)
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

12 Conclusion

2

1 Introduction

Machine learning is the ﬁeld of research devoted to the formal study of learning systems. This is a highly
interdisciplinary ﬁeld which borrows and builds upon ideas from statistics, computer science, engineering,
cognitive science, optimisation theory and many other disciplines of science and mathematics. The purpose
of this chapter is to introduce in a fairly concise manner the key ideas underlying the sub-ﬁeld of machine
learning known as unsupervised learning. This introduction is necessarily incomplete given the enormous
range of topics under the rubric of unsupervised learning. The hope is that interested readers can delve
more deeply into the many topics covered here by following some of the cited references. The chapter starts
at a highly tutorial level but will touch upon state-of-the-art research in later sections. It is assumed that
the reader is familiar with elementary linear algebra, probability theory, and calculus, but not much else.

1.1 What is unsupervised learning?
Consider a machine (or living organism) which receives some sequence of inputs x1, x2, x3, . . ., where xt is
the sensory input at time t. This input, which we will often call the data, could correspond to an image on
the retina, the pixels in a camera, or a sound waveform. It could also correspond to less obviously sensory
data, for example the words in a news story, or the list of items in a supermarket shopping basket.

One can distinguish between four diﬀerent kinds of machine learning. In supervised learning the machine1
is also given a sequence of desired outputs y1, y2, . . . , and the goal of the machine is to learn to produce the
correct output given a new input. This output could be a class label (in classiﬁcation) or a real number (in
regression).

In reinforcement learning the machine interacts with its environment by producing actions a1, a2, . . ..
These actions aﬀect the state of the environment, which in turn results in the machine receiving some scalar
rewards (or punishments) r1, r2, . . .. The goal of the machine is to learn to act in a way that maximises
the future rewards it receives (or minimises the punishments) over its lifetime. Reinforcement learning is
closely related to the ﬁelds of decision theory (in statistics and management science), and control theory
(in engineering). The fundamental problems studied in these ﬁelds are often formally equivalent, and the
solutions are the same, although diﬀerent aspects of problem and solution are usually emphasised.

A third kind of machine learning is closely related to game theory and generalises reinforcement learning.
Here again the machine gets inputs, produces actions, and receives rewards. However, the environment the
machine interacts with is not some static world, but rather it can contain other machines which can also
sense, act, receive rewards, and learn. Thus the goal of the machine is to act so as to maximise rewards in
light of the other machines’ current and future actions. Although there is a great deal of work in game theory
for simple systems, the dynamic case with multiple adapting machines remains an active and challenging
area of research.

Finally, in unsupervised learning the machine simply receives inputs x1, x2, . . ., but obtains neither super-
vised target outputs, nor rewards from its environment. It may seem somewhat mysterious to imagine what
the machine could possibly learn given that it doesn’t get any feedback from its environment. However, it
is possible to develop of formal framework for unsupervised learning based on the notion that the machine’s
goal is to build representations of the input that can be used for decision making, predicting future inputs,
eﬃciently communicating the inputs to another machine, etc.
In a sense, unsupervised learning can be
thought of as ﬁnding patterns in the data above and beyond what would be considered pure unstructured
noise. Two very simple classic examples of unsupervised learning are clustering and dimensionality reduction.
We discuss these in Section 2. The remainder of this chapter focuses on unsupervised learning, although
many of the concepts discussed can be applied to supervised learning as well. But ﬁrst, let us consider how
unsupervised learning relates to statistics and information theory.

1Henceforth, for succinctness I’ll use the term machine to refer both to machines and living organisms. Some people prefer to
call this a system or agent. The same mathematical theory of learning applies regardless of what we choose to call the learner,
whether it is artiﬁcial or biological.

3

1.2 Machine learning, statistics, and information theory
Almost all work in unsupervised learning can be viewed in terms of learning a probabilistic model of the
data. Even when the machine is given no supervision or reward, it may make sense for the machine to
estimate a model that represents the probability distribution for a new input xt given previous inputs
x1, . . . , xt−1 (consider the obviously useful examples of stock prices, or the weather). That is, the learner
models P (xt|x1, . . . , xt−1).
In simpler cases where the order in which the inputs arrive is irrelevant or
unknown, the machine can build a model of the data which assumes that the data points x1, x2, . . . are
independently and identically drawn from some distribution P (x)2.

Such a model can be used for outlier detection or monitoring. Let x represent patterns of sensor readings
from a nuclear power plant and assume that P (x) is learned from data collected from a normally functioning
plant. This model can be used to evaluate the probability of a new sensor reading; if this probability is
abnormally low, then either the model is poor or the plant is behaving abnormally, in which case one may
want to shut it down.

A probabilistic model can also be used for classiﬁcation. Assume P1(x) is a model of the attributes of
credit card holders who paid on time, and P2(x) is a model learned from credit card holders who defaulted
on their payments. By evaluating the relative probabilities P1(x0) and P2(x0) on a new applicant x0, the
machine can decide to classify her into one of these two categories.

With a probabilistic model one can also achieve eﬃcient communication and data compression. Imagine
that we want to transmit, over a digital communication line, symbols x randomly drawn from P (x). For
example, x may be letters of the alphabet, or images, and the communication line may be the internet.
Intuitively, we should encode our data so that symbols which occur more frequently have code words with
fewer bits in them, otherwise we are wasting bandwidth. Shannon’s source coding theorem quantiﬁes this by
telling us that the optimal number of bits to use to encode a symbol with probability P (x) is − log2 P (x).
Using these number of bits for each symbol, the expected coding cost is the entropy of the distribution P .

P (x) log2 P (x)

(1)

In general, the true distribution of the data is unknown, but we can learn a model of this distribution. Let’s
call this model Q(x). The optimal code with respect to this model would use − log2 Q(x) bits for each symbol
x. The expected coding cost, taking expectations with respect to the true distribution, is

H(P ) def= −X

x

−X

x

P (x) log2 Q(x)

(2)

(3)

The diﬀerence between these two coding costs is called the Kullback-Leibler (KL) divergence

KL(PkQ) def= X

P (x) log P (x)
Q(x)

x

The KL divergence is non-negative and zero if and only if P=Q. It measures the coding ineﬃciency in bits
from using a model Q to compress data when the true data distribution is P . Therefore, the better our
model of the data, the more eﬃciently we can compress and communicate new data. This is an important
link between machine learning, statistics, and information theory. An excellent text which elaborates on
these relationships and many of the topics in this chapter is [48].

1.3 Bayes rule
Bayes rule,

(4)
which follows from the equality P (x, y) = P (x)P (y|x) = P (y)P (x|y), can be used to motivate a coherent
statistical framework for machine learning. The basic idea is the following. Imagine we wish to design a

P (x)

P (y|x) = P (x|y)P (y)

2We will use both P and p to denote probability distributions and probability densities. The meaning should be clear

depending on whether the argument is discrete or continuous.

4

machine which has beliefs about the world, and updates these beliefs on the basis of observed data. The
machine must somehow represent the strengths of its beliefs numerically.
It has been shown that if you
accept certain axioms of coherent inference, known as the Cox axioms, then a remarkable result follows
[36]: If the machine is to represent the strength of its beliefs by real numbers, then the only reasonable and
coherent way of manipulating these beliefs is to have them satisfy the rules of probability, such as Bayes
rule. Therefore, P (X = x) can be used not only to represent the frequency with which the variable X takes
on the value x (as in so-called frequentist statistics) but it can also be used to represent the degree of belief
that X = x. Similarly, P (X = x|Y = y) can be used to represent the degree of belief that X = x given that
one knowns Y = y.3
From Bayes rule we derive the following simple framework for machine learning. Assume a universe of
models Ω; let Ω = {1, . . . , M} although it need not be ﬁnite or even countable. The machines starts with some
m=1 P (m) = 1.
A model is simply some probability distribution over data points, i.e. P (x|m). For simplicity, let us further
assume that in all the models the data is taken to be independently and identically distributed (iid). After
observing a data set D = {x1, . . . , xN}, the beliefs over models is given by:

prior beliefs over models m ∈ Ω (we will see many examples of models later), such that PM

P (m|D) = P (m)P (D|m)

P (D)

∝ P (m)

P (xn|m)

NY

n=1

which we read as the posterior over models is the prior multiplied by the likelihood, normalised.

The predictive distribution over new data, which would be used to encode new data eﬃciently, is

(5)

(6)

MX

m=1

Z

P (x|D) =

P (x|m)P (m|D)

Again this follows from the rules of probability theory, and the fact that the models are assumed to produce
iid data.

Often models are deﬁned by writing down a parametric probability distribution (again, we’ll see many
examples below). Thus, the model m might have parameters θ, which are assumed to be unknown (this
could in general be a vector of parameters). To be a well-deﬁned model from the perspective of Bayesian
learning, one has to deﬁne a prior over these model parameters P (θ|m) which naturally has to satisfy the
following equality

P (x|m) =

P (x|θ, m)P (θ|m)dθ

(7)
Given the model m it is also possible to infer the posterior over the parameters of the model, i.e. P (θ|D, m),
and to compute the predictive distribution, P (x|D, m). These quantities are derived in exact analogy to
equations (5) and (6), except that instead of summing over possible models, we integrate over parameters of
a particular model. All the key quantities in Bayesian machine learning follow directly from the basic rules
of probability theory.
Certain approximate forms of Bayesian learning are worth mentioning. Let’s focus on a particular model
m with parameters θ, and an observed data set D. The predictive distribution averages over all possible
parameters weighted by the posterior

Z

P (x|D, m) =

P (x|θ)P (θ|D, m)dθ.

(8)

In certain cases, it may be cumbersome to represent the entire posterior distribution over parameters, so
instead we will choose to ﬁnd a point-estimate of the parameters ˆθ. A natural choice is to pick the most

3Another way to motivate the use of the rules of probability to encode degrees of belief comes from game-theoretic arguments
in the form of the Dutch Book Theorem. This theorem states that if you are willing to accept bets with odds based on your
degrees of beliefs, then unless your beliefs are coherent in the sense that they satisfy the rules of probability theory, there exists
a set of simultaneous bets (called a “Dutch Book”) which you will accept and which is guaranteed to lose you money, no matter
what the outcome. The only way to ensure that Dutch Books don’t exist against you, is to have degrees of belief that satisfy
Bayes rule and the other rules of probability theory.

5

probable parameter value given the data, which is known as the maximum a posteriori or MAP parameter
estimate

ˆθMAP = arg max

θ

P (θ|D, m) = arg max

θ

Another natural choice is the maximum likelihood or ML parameter estimate

ˆθML = arg max

θ

P (D|θ, m) = arg max

θ

log P (xn|θ, m)

#

log P (xn|θ, m)

"

log P (θ|m) +X

n

X

n

(9)

(10)

Many learning algorithms can be seen as ﬁnding ML parameter estimates. The ML parameter estimate is
also acceptable from a frequentist statistical modelling perspective since it does not require deciding on a
prior over parameters. However, ML estimation does not protect against overﬁtting—more complex models
will generally have higher maxima of the likelihood. In order to avoid problems with overﬁtting, frequentist
procedures often maximise a penalised or regularised log likelihood (e.g. [26]). If the penalty or regularisation
term is interpreted as a log prior, then maximising penalised likelihood appears identical to maximising a
posterior. However, there are subtle issues that make a Bayesian MAP procedure and maximum penalised
likelihood diﬀerent [28]. One diﬀerence is that the MAP estimate is not invariant to reparameterisation,
while the maximum of the penalised likelihood is invariant. The penalised likelihood is a function, not a
density, and therefore does not increase or decrease depending on the Jacobian of the reparameterisation.

2 Latent variable models

The framework described above can be applied to a wide range of models. No singe model is appropriate
for all data sets. The art in machine learning is to develop models which are appropriate for the data set
being analysed, and which have certain desired properties. For example, for high dimensional data sets it
might be necessary to use models that perform dimensionality reduction. Of course, ultimately, the machine
should be able to decide on the appropriate model without any human intervention, but to achieve this in
full generality requires signiﬁcant advances in artiﬁcial intelligence.

In this section, we will consider probabilistic models that are deﬁned in terms of some latent or hidden
variables. These models can be used to do dimensionality reduction and clustering, the two cornerstones of
unsupervised learning.

2.1 Factor analysis
Let the data set D consist of D-dimensional real valued vectors, D = {y1, . . . , yN}. In factor analysis, the
data is assumed to be generated from the following model
y = Λx + 

(11)
where x is a K-dimensional zero-mean unit-variance multivariate Gaussian vector with elements correspond-
ing to hidden (or latent) factors, Λ is a D × K matrix of parameters, known as the factor loading matrix,
and  is a D-dimensional zero-mean multivariate Gaussian noise vector with diagonal covariance matrix Ψ.
Deﬁning the parameters of the model to be θ = (Ψ, Λ), by integrating out the factors, one can readily derive
that

(12)
where N (µ, Σ) refers to a multivariate Gaussian density with mean µ and covariance matrix Σ. For more
details refer to [68].

p(x|θ)p(y|x, θ)dx = N (0, ΛΛ> + Ψ)

p(y|θ) =

Z

Factor analysis is an interesting model for several reasons. If the data is very high dimensional (D is
large) then even a simple model like the full-covariance multivariate Gaussian will have too many parameters
to reliably estimate or infer from the data. By choosing K < D, factor analysis makes it possible to model
a Gaussian density for high dimensional data without requiring O(D2) parameters. Moreover, given a new
data point, one can compute the posterior over the hidden factors, p(x|y, θ); since x is lower dimensional
than y this provides a low-dimensional representation of the data (for example, one could pick the mean of
p(x|y, θ) as the representation for y).

6

2.2 Principal components analysis (PCA)
Principal components analysis (PCA) is an important limiting case of factor analysis (FA). One can derive
PCA by making two modiﬁcations to FA. First, the noise is assumed to be isotropic, in other words each
element of  has equal variance: Ψ = σ2I, where I is a D×D identity matrix. This model is called probabilistic
PCA [67, 78]. Second, if we take the limit of σ → 0 in probabilistic PCA, we obtain standard PCA (which
also goes by the names Karhunen-Lo`eve expansion, and singular value decomposition; SVD). Given a data
set with covariance matrix Σ, for maximum likelihood factor analysis the goal is to ﬁnd parameters Λ, and
Ψ for which the model ΛΛ> +Ψ has highest likelihood. In PCA, the goal is to ﬁnd Λ so that the likelihood is
highest for ΛΛ>. Note that this matrix is singular unless K = D, so the standard PCA model is not a sensible
model. However, taking the limiting case, and further constraining the columns of Λ to be orthogonal, it
can be derived that the principal components correspond to the K eigenvectors with largest eigenvalue of
Σ. PCA is thus attractive because the solution can be found immediately after eigendecomposition of the
covariance. Taking the limit σ → 0 of p(x|y, Λ, σ) we ﬁnd that it is a delta-function at x = Λ>y, which is
the projection of y onto the principal components.

2.3 Independent components analysis (ICA)
Independent components analysis (ICA) extends factor analysis to the case where the factors are non-
Gaussian. This is an interesting extension because many real-world data sets have structure which can be
modelled as linear combinations of sparse sources. This includes auditory data, images, biological signals
such as EEG, etc. Sparsity simply corresponds to the assumption that the factors have distributions with
2 exp{−λ|x|} has a higher peak at zero and heavier
higher kurtosis that the Gaussian. For example, p(x) = λ
tails than a Gaussian with corresponding mean and variance, so it would be considered sparse (strictly
speaking, one would like a distribution which had non-zero probability mass at 0 to get true sparsity).

Models like PCA, FA and ICA can all be implemented using neural networks (multilayer perceptrons)
trained using various cost functions. It is not clear what advantage this implementation/interpretation has
from a machine learning perspective, although it provides interesting ties to biological information processing.
Rather than ML estimation, one can also do Bayesian inference for the parameters of probabilistic PCA,

FA, and ICA.

2.4 Mixture of Gaussians
The densities modelled by PCA, FA and ICA are all relatively simple in that they are unimodal and have
fairly restricted parametric forms (Gaussian, in the case of PCA and FA). To model data with more complex
structure such as clusters, it is very useful to consider mixture models. Although it is straightforward to
consider mixtures of arbitrary densities, we will focus on Gaussians as a common special case. The density
of each data point in a mixture model can be written:

p(y|θ) =

πk p(y|θk)

(13)

covariances θk = (µk, Σk) and πk is the mixing proportion for component k, such that PK

where each of the K components of the mixture is, for example, a Gaussian with diﬀering means and
k=1 πk = 1 and
πk > 0, ∀k.

A diﬀerent way to think about mixture models is to consider them as latent variable models, where
associated with each data point is a K-ary discrete latent (i.e. hidden) variable s which has the interpretation
that s = k if the data point was generated by component k. This can be written

KX

k=1

KX

p(y|θ) =

P (s = k|π)p(y|s = k, θ)

(14)

where P (s = k|π) = πk is the prior for the latent variable taking on value k, and p(y|s = k, θ) = p(y|θk) is
the density under component k, recovering Equation (13).

k=1

7

2.5 K-means
The mixture of Gaussians model is closely related to an unsupervised clustering algorithm known as k-means
as follows: Consider the special case where all the Gaussians have common covariance matrix proportional
to the identity matrix: Σk = σ2I, ∀k, and let πk = 1/K, ∀k. We can estimate the maximum likelihood
parameters of this model using the iterative algorithm which we are about to describe, known as EM. The
resulting algorithm, as we take the limit σ2 → 0, becomes exactly the k-means algorithm. Clearly the model
underlying k-means has only singular Gaussians and is therefore an unreasonable model of the data; however,
k-means is usually justiﬁed from the point of view of clustering to minimise a distortion measure, rather
than ﬁtting a probabilistic models.

3 The EM algorithm

The EM algorithm is an algorithm for estimating ML parameters of a model with latent variables. Consider
a model with observed variables y, hidden/latent variables x, and parameters θ. We can lower bound the
log likelihood for any data point as follows

L(θ) = log p(y|θ) = log

Z
Z
p(x, y|θ) dx
q(x) p(x, y|θ)
q(x)
q(x) log p(x, y|θ)
q(x)

= log

Z

≥

dx

dx def= F (q, θ)

(15)

(16)

(17)

where q(x) is some arbitrary density over the hidden variables, and the lower bound holds due to the concavity
of the log function (this inequality is known as Jensen’s inequality). The lower bound F is a functional of
both the density q(x) and the model parameters θ. For a data set of N data points y(1), . . . , y(N ), this lower
bound is formed for the log likelihood term corresponding to each data point, thus there is a separate density

q(n)(x) for each point and F (q, θ) =P

The basic idea of the Expectation-Maximisation (EM) algorithm is to iterate between optimising this
lower bound as a function of q and as a function of θ. We can prove that this will never decrease the
log likelihood. After initialising the parameters somehow, the kth iteration of the algorithm consists of the
following two steps:

n F (n)(q(n), θ).

E step: optimise F with respect to the distribution q while holding the parameters ﬁxed

qk(x) = arg max
q(x)
qk(x) = p(x|y, θk−1)

q(x) log p(x, y|θk−1)

q(x)

M step: optimise F with respect to the parameters θ while holding the distribution over hidden variables

ﬁxed

θk = arg max

θ

θk = arg max

θ

qk(x) log p(x, y|θ)
qk(x)
qk(x) log p(x, y|θ) dx

dx

(20)

(21)

Let us be absolutely clear what happens for a data set of N data points: In the E step, for each data point,
k (x) = p(x|y(n), θk−1),
the distribution over the hidden variables is set to the posterior for that data point q(n)
∀n. In the M step the single set of parameters is re-estimated by maximising the sum of the expected log
likelihoods: θk = arg maxθ
crease the likelihood? The optimisation in (18) can be written as follows since p(x, y|θk−1) = p(y|θk−1)p(x|y, θk−1):

Two things are still unclear: how does (19) follow from (18), and how is this algorithm guaranteed to in-

R q(n)

P

n

k (x) log p(x, y(n)|θ) dx.
Z

log p(y|θk−1) +

h

qk(x) = arg max
q(x)

q(x) log p(x|y, θk−1)

dx

q(x)

i

(18)

(19)

(22)

Z

Z
Z

8

Now, the ﬁrst term is a constant w.r.t. q(x) and the second term is the negative of the Kullback-Leibler
divergence

Z

q(x)

KL(q(x)kp(x|y, θk−1)) =

q(x) log

p(x|y, θk−1) dx

(23)
which we have seen in Equation (3) in its discrete form. This is minimised at q(x) = p(x|y, θk−1), where the
KL divergence is zero. Intuitively, the interpretation of this is that in the E step of EM, the goal is to ﬁnd
the posterior distribution of the hidden variables given the observed variables and the current settings of the
parameters. We also see that since the KL divergence is zero, at the end of the E step, F (qk, θk−1) = L(θk−1).
In the M step, F is increased with respect to θ. Therefore, F (qk, θk) ≥ F (qk, θk−1). Moreover,
L(θk) = F (qk+1, θk) ≥ F (qk, θk) after the next E step. We can put these steps together to establish
that L(θk) ≥ L(θk−1), establishing that the algorithm is guaranteed to increase the likelihood or keep it
ﬁxed (at convergence).

The EM algorithm can be applied to all the latent variable models described above, i.e. FA, probabilistic
PCA, mixture models, and ICA. In the case of mixture models, the hidden variable is the discrete assign-
ment s of data points to clusters; consequently the integrals turn into sums where appropriate. EM has
wide applicability to latent variable models, although it is not always the fastest optimisation method [70].
Moreover, we should note that the likelihood often has many local optima and EM will converge some local
optimum which may not be the global one.

EM can also be used to estimate MAP parameters of a model, and as we will see in Section 11.4 there is

a Bayesian generalization of EM as well.

4 Modelling time series and other structured data

So far we have assumed that the data is unstructured, that is, the observations are assumed to be independent
and identically distributed. This assumption is unreasonable for many data sets in which the observations
arrive in a sequence and subsequent observations are correlated. Sequential data can occur in time series
modelling (as in ﬁnancial data or the weather) and also in situations where the sequential nature of the data
is not necessarily tied to time (as in protein data which consist of sequences of amino acids).
As the most basic level, time series modelling consists of building a probabilistic model of the present
observation given all past observations p(yt|yt−1, yt−2 . . .). Because the history of observations grows arbi-
trarily large it is necessary to limit the complexity of such a model. There are essentially two ways of doing
this.
The ﬁrst approach is to limit the window of past observations. Thus one can simply model p(yt|yt−1)
and assume that this relation holds for all t. This is known as a ﬁrst-order Markov model. A second-order
Markov model would be p(yt|yt−1, yt−2), and so on. Such Markov models have two limitations: First, the
inﬂuence of past observations on present observations vanishes outside this window, which can be unrealistic.
Second, it may be unnatural and unwieldy to model directly the relationship between raw observations at one
time step and raw observations at a subsequent time step. For example, if the observations are noisy images,
it would make more sense to de-noise them, extract some description of the objects, motions, illuminations,
and then try to predict from that.

The second approach is to make use of latent or hidden variables. Instead of modelling directly the eﬀect
of yt−1 on yt, we assume that the observations were generated from some underlying hidden variable xt
which captures the dynamics of the system. For example, y might be noisy sonar readings of objects in a
room, while x might be the actual locations and sizes of these objects. We usually call this hidden variable x
the state variable since it is meant to capture all the aspects of the system relevant to predicting the future
dynamical behaviour of the system.

In order to understand more complex time series models, it is essential that one be familiar with state-
space models (SSMs) and hidden Markov models (HMMs). These two classes of models have played a
historically important role in control engineering, visual tracking, speech recognition, protein sequence mod-
elling, and error decoding. They form the simplest building blocks from which other richer time-series models
can be developed, in a manner completely analogous to the role that FA and mixture models play in building
more complex models for iid data.

9

4.1 State-space models (SSMs)
In a state-space model, the sequence of observed data y1, y2, y3, . . . is assumed to have been generated from
some sequence of hidden state variables x1, x2, x3, . . .. Letting x1:T denote the sequence x1, . . . , xT , the
basic assumption in an SSM is that the joint probability of the hidden states and observations factors in the
following way:

p(x1:T , y1:T|θ) =

p(xt|xt−1, θ)p(yt|xt, θ)

(24)

TY

t=1

In order words, the observations are assumed to have been generated from the hidden states via p(yt|xt, θ),
and the hidden states are assumed to have ﬁrst-order Markov dynamics captured by p(xt|xt−1, θ). We can
consider the ﬁrst term p(x1|x0, θ) to be a prior on the initial state of the system x1.

The simplest kind of state-space model assumes that all variables are multivariate Gaussian distributed

and all the relationships are linear. In such linear-Gaussian state-space models, we can write

yt = Cxt + vt
xt = Axt−1 + wt

(25)
(26)

where the matrices C and A deﬁne the linear relationships and v and w are zero-mean Gaussian noise vectors
with covariance matrices R and Q respectively. If we assume that the prior on the initial state p(x1) is also
Gaussian, then all subsequent xs and ys are also Gaussian due the the fact that Gaussian densities are closed
under linear transformations. This model can be generalised in many ways, for example by augmenting it
to include a sequence of observed inputs u1, . . . , uT as well as the observed model outputs y1, . . . , yT , but
we will not discuss generalisations further.

By comparing equations (11) and (25) we see that linear-Gaussian SSMs can be thought of as a time-
series generalisation of factor analysis where the factors are assumed to have linear-Gaussian dynamics over
time.
The parameters of this model are θ = (A, C, Q, R). To learn ML settings of these parameters one can
make use of the EM algorithm [73]. The E step of the algorithm involves computing q(x1:T ) = p(x1:T|y1:T , θ)
which is the posterior over hidden state sequences. In fact, this whole posterior does not have to be computed
or represented, all that is required are the marginals q(xt) and pairwise marginals q(xt, xt+1). These can be
computed via the Kalman smoothing algorithm, which is an eﬃcient algorithm for inferring the distribution
over the hidden states of a linear-Gaussian SSM. Since the model is linear, the M step of the algorithm
requires solving a pair of weighted linear regression problems to re-estimate A and C, while Q and R are
estimated from the residuals of those regressions. This is analogous to the M step of factor analysis, which
also involves solving a linear regression problem.

TY

4.2 Hidden Markov models (HMMs)
Hidden Markov models are similar to state-space models in that the sequence of observations is assumed to
have been generated from a sequence of underlying hidden states. The key diﬀerence is that in HMMs the
state is assumed to be discrete rather than a continuous random vector. Let st denote the hidden state of an
HMM at time t. We assume that st can take discrete values in {1, . . . , K}. The model can again be written
as in (24):

P (s1:T , y1:T|θ) =

P (st|st−1, θ)P (yt|st, θ)

(27)

t=1

where P (s1|s0, θ) is simply some initial distribution over the K settings of the ﬁrst hidden state; we can call
this discrete distribition π, represented by a K × 1 vector. The state-transition probabilities P (st|st−1, θ)
are captured by a K × K transition matrix A, with elements Aij = P (st = i|st−1 = j, θ). The observations
in an HMM can be either continuous or discrete. For continuous observations yt one can for example choose
a Gaussian density; thus p(yt|st = i, θ) would be a diﬀerent Gaussian for each choice of i ∈ {1, . . . , K}. This
model is the dynamical generalisation of a mixture of Gaussians. The marginal probability at each point in
time is exactly a mixture of K Gaussians—the diﬀerence is that which component generates data point yt

10

and which component generated yt−1 are not independent random variables, but certain combinations are
more and less probable depending on the entries in A. For yt a discrete observation, let us assume that it
can take on values {1, . . . , L}. In that case the output probabilities P (yt|st, θ) can be captured by an L× K
emission matrix, E.

The model parameters for a discrete-observation HMM are θ = (π, A, E). Maximum likelihood learning
of the model parameters can be approached using the EM algorithm, which in the case of HMMs is known
as the Baum-Welch algorithm. The E step involves computing Q(st) and Q(st, st+1) which are marginals of
Q(s1:T ) = P (s1:T|y1:T , θ). These marginals are computed as part of the forward–backward algorithm which
as the name suggests sweeps forward and backward through the time series, and applies Bayes rule eﬃciently
using the Markov conditional independence properties of the HMM, to compute the required marginals. The
M step of HMM learning involves re-estimating π, A, and E by adding up and normalising expected counts
for transitions and emissions that were computed in the E step.

4.3 Modelling other structured data
We have considered the case of iid data and time series data. The observations in real world data sets can
have many other possible structures as well. Let us mention a few examples, although it is not possible to
strive for completeness.

In spatial data, the points are assumed to live in some metric, often Euclidean, space. Three examples
of spatial data include epidemiological data which can be modelled as a function of the spatial location
of the measurement; data from computer vision where the observations are measurements of features on a
2D input to the camera; and functional neuroimaging where the data can be physiological measurements
related to neural activity located in 3D voxels deﬁning coordinates in the brain. Generalising HMMs, one
can deﬁne Markov random ﬁeld models where there are a set of hidden variables correlated to neighbours in
some lattice, and related to the observed variables.

Hierarchical or tree-structured data contains known or unknown tree-like correlation structure between
the data points or measured features. For example, the data points may be features of animals related
through an evolutionary tree. A very diﬀerent form of structured data is if each data point itself is tree-
structured, for example if each point is a parse tree of a sentence in the English language.

Finally, one can take the structured dependencies between variables and consider the structure itself as
an unknown part of the model. Such models are known as probabilistic relational models and are closely
related to graphical models which we will discuss in Section 7.

5 Nonlinear, Factorial, and Hierarchical Models

The models we have described so far are attractive because they are relatively simple to understand and
learn. However, their simplicity is also a limitation, since the intricacies of real-world data are unlikely to
be well-captured by a simple statistical model. This motivates us to seek to describe and study learning in
much more ﬂexible models.

A simple combination of two of the ideas we have described for iid data is the mixture of factor analysers
[23, 34, 77]. This model performs simultaneous clustering and dimensionality reduction on the data, by
assuming that the covariance in each Gaussian cluster can be modelled by an FA model. Thus, it becomes
possible to apply a mixture model to very high dimensional data while allowing each cluster to span a
diﬀerent sub-space of the data.

As their name implies linear-Gaussian SSMs are limited by assumptions of linearity and Gaussian noise.
In many realistic dynamical systems there are signiﬁcant nonlinear eﬀects, which make it necessary to
consider learning in nonlinear state-space models. Such models can also be learned using the EM algorithm,
but the E step must deal with inference in non-Gaussian and potentially very complicated densities (since
non-linearities will turn Gaussians into non-Gaussians), and the M step is nonlinear regression, rather than
linear regression [25]. There are many methods of dealing with inference in non-linear SSMs, including
methods such as particle ﬁltering [29, 27, 40, 43, 35, 15], linearisation [2], the unscented ﬁlter [39, 80], the
EP algorithm [52], and embedded HMMs [62].

11

Non-linear models are also important if we are to consider generalising simple dimensionality reduction
models such as PCA and FA. These models are limited in that they can only ﬁnd a linear subspace of the
data to capture the correlations between the observed variables. There are many interesting and impor-
tant nonlinear dimensionality reduction models, including generative topographic mappings (GTM) [11] (a
probabilistic alternative to Kohonen maps), multi-dimensional scaling (MDS) [72, 45], principal curves [30],
Isomap [76], and locally linear embedding (LLE) [69].

Hidden Markov models also have their limitations. Even though they can model nonlinear dynamics by
discretising the hidden state space, an HMM with K hidden states can only capture log2 K bits of information
in its state variable about the past of the sequence. HMMs can be extended by allowing a vector of discrete
state variables, in an architecture known as a factorial HMM [24]. Thus a vector of M variables, each of
which can take K states, can capture KM possible states in total, and M log2 K bits of information about
the past of the sequence. The problem is that such a model, if dealt with naively as an HMM would have
exponentially many parameters and would take exponentially long to do inference in. Both the complexity in
time and number of parameters can be alleviated by restricting the interactions between the hidden variables
at one time step and at the next time step. A generalisation of these ideas is the notion of a dynamical
Bayesian network (DBN) [56].

A relatively old but still quite powerful class of models for binary data is the Boltzmann machine (BM)
[1]. This is a simple model inspired from Ising models in statistical physics. A BM is a multivariate model
for capturing correlations and higher order statistics in vectors of binary data. Consider data consisting of
vectors of M binary variables (the elements of the vector may, for example, be pixels in a black-and-white
image). Clearly, each data point can be an instance of one of 2M possible patterns. An arbitrary distribution
over such patterns would require a table with 2M − 1 entries, again intractable in number of parameters,
storage, and computation time. A BM allows one to deﬁne ﬂexible distributions over the 2M entries of this
table by using O(M 2) parameters deﬁning a symmetric matrix of weights connecting the variables. This
can be augmented with hidden variables in order to enrich the model class, without adding exponentially
many parameters. These hidden variables can be organised into layers of a hierarchy as in the Helmholtz
machine [33]. Other hierarchical models include recent generalisations of ICA designed to capture higher
order statistics in images [41].

6 Intractability

Let us consider a simple example.

the variable Y =PN

The problem with the models described in the previous section is that learning their parameters is in general
computationally intractable. In a model with exponentially many settings for the hidden states, doing the E
step of an EM algorithm would require computing appropriate marginals of a distribution over exponentially
many possibilities.
Imagine we have a vector of N binary random variables s =
(s1, . . . , sN ), where si ∈ {0, 1} and a vector of N known integers (r1, . . . , rN ) where ri ∈ {1, 2, 3, . . . , 10}. Let
i=1 risi. Assume that the binary variables are all independent and identically distributed
with P (si = 1) = 1/2, ∀i. Let N be 100. Now imagine that we are told Y = 430. How do we compute
P (si = 1|Y = 430)? The problem is that even though the si were independent before we observed the value
of Y , now that we know the value of Y , not all settings of s are possible anymore. To ﬁgure out for some si
the probability of P (si = 1|Y = 430) requires that we enumerate all potentially exponentially many ways of
achieving Y = 430 and counting how many of those had si = 1 vs si = 0.

This example illustrates the following ideas: Even if the prior is simple, the posterior can be very
complicated. Whether two random variables are independent or not is a function of one’s state of knowledge.
Thus si and sj may be independent if we are not told the value of Y but are certainly dependent given the
value of Y . These type of phenomena are related to “explaining-away” which refers to the fact that if there
are multiple potential causes for some eﬀect, observing one, explains away the need for the others [64].

Intractability can thus occur if we have a model with discrete hidden variables which can take on expo-
nentially many combinations. Intractability can also occur with continuous hidden variables if their density
is not simply described, or if they interact with discrete hidden variables. Moreover, even for simple models,
such as a mixture of Gaussians, intractability occurs when we consider the parameters to be unknown as

12

Figure 1: Three kinds of probabilistic graphical model: undirected graphs, factor graphs and directed graphs.

well, and we attempt to do Bayesian inference on them. To deal with intractability it is essential to have
good tools for representing multivariate distributions, such as graphical models.

7 Graphical models

Graphical models are an important tool for representing the dependencies between random variables in a
probabilistic model. They are important for two reasons. First, graphs are an intuitive way of visualising
dependencies. We are used to graphical depictions of dependency, for example in circuit diagrams and in
phylogenetic trees. Second, by exploiting the structure of the graph it is possible to devise eﬃcient message
passing algorithms for computing marginal and conditional probabilities in a complicated model. We discuss
message passing algorithms for inference in Section 8.
The main statistical property represented explicitly by the graph is conditional independence between
variables. We say that X and Y are conditionally independent given Z, if P (X, Y |Z) = P (X|Z)P (Y |Z) for
all values of the variables X,Y , and Z where these quantities are deﬁned (i.e. excepting settings z where
P (Z = z) = 0). We use the notation X⊥⊥Y |Z to denote the above conditional independence relation.
Conditional independence generalises to sets of variables in the obvious way, and it is diﬀerent from marginal
independence which states that P (X, Y ) = P (X)P (Y ), and is denoted X⊥⊥Y .

There are several diﬀerent graphical formalisms for depicting conditional independence relationships. We

focus on three of the main ones: undirected, factor, and directed graphs.

7.1 Undirected graphs
In an undirected graphical model each random variable is represented by a node, and the edges of the graph
indicate conditional independence relationships. Speciﬁcally, let X ,Y, and Z be sets of random variables.
Then X⊥⊥Y|Z if every path on the graph from a node in X to a node in Y has to go through a node in Z.
Thus a variable X is conditionally independent of all other variables given the neighbours of X, and we say
that the neighbours separate X from the rest of the graph. An example of an undirected graph is shown in
Figure 1. In this graph A⊥⊥B|C and B⊥⊥E|{C, D}, for example, and the neighbours of D are B, C, E.

A clique is a fully connected subgraph of a graph. A maximal clique is not contained in any other clique
It turns out that the set of conditional independence relations implied by the separation
of the graph.
properties in the graph are satisﬁed by probability distributions which can be written as a normalised
product of non-negative functions over the variables in the maximal cliques of the graph (this is known
as the Hammersley-Cliﬀord Theorem [10]). In the example in Figure 1, this implies that the probability
distribution over (A, B, C, D, E) can be written as:

P (A, B, C, D, E) = c g1(A, C)g2(B, C, D)g3(C, D, E)

(28)

Here, c is the constant that ensures that the probability distribution sums to 1, and g1, g2 and g3 are
non-negative functions of their arguments. For example, if all the variables are binary the function g2 is a
table with a non-negative number for each of the 8 = 2 × 2 × 2 possible settings of the variables B, C, D.
These non-negative functions are supposed to represent how compatible these settings are with each other,

13

ACBDEACBDEACBDEwith a 0 encoding logical incompatibility. For this reason, the g’s are sometimes referred to as compatibility
functions, other times as potential functions. Undirected graphical models are also sometimes referred to as
Markov networks.

7.2 Factor graphs
In a factor graph there are two kinds of nodes, variable nodes and factor nodes, usually denoted as open
circles and ﬁlled dots (Figure 1). Like an undirected model, the factor graph represents a factorisation of
the joint probability distribution: each factor is a non-negative function of the variables connected to the
corresponding factor node. Thus for the factor graph in Figure 1 we have:

P (A, B, C, D, E) = cg1(A, C)g2(B, C)g3(B, D), g4(C, D)g5(C, E)g6(D, E)

(29)

Factor nodes are also sometimes called function nodes. Again, as in an undirected graphical model, the
variables in a set X are conditionally independent of the variables in a set Y given Z if all paths from X
to Y go through variables in Z. Note that the factor graph is Figure 1 has exactly the same conditional
independence relations as the undirected graph, even though the factors in the former are contained in the
factors in the latter. Factor graphs are particularly elegant and simple when it comes to implementing
message passing algorithms for inference (Section 8).

7.3 Directed graphs
In directed graphical models, also known as probabilistic directed acyclic graphs (DAGs), belief networks,
and Bayesian networks, the nodes represent random variables and the directed edges represent statistical
dependencies. If there exists an edge from A to B we say that A is a parent of B, and conversely B is a
child of A. A directed graph corresponds to the factorisation of the joint probability into a product of the
conditional probabilities of each node given its parents. For the example in Figure 1 we write:

P (A, B, C, D, E) = P (A)P (B)P (C|A, B)P (D|B, C)P (E|C, D)

(30)

(31)

In general we would write:

P (X1, . . . , XN ) =

NY

P (Xi|Xpai)

i=1

where Xpai denotes the variables that are parents of Xi in the graph.

Assessing the conditional independence relations in a directed graph is slightly less trivial than in undi-
rected and factor graphs. Rather than simply looking at separation between sets of variables, one has to
consider the directions of the edges. The graphical test for two sets of variables being conditionally inde-
pendent given a third is called d-separation [64]. D-separation takes into account the following fact about
v-structures of the graph, which consist of two (or more) parents of a child, as in the A → C ← B sub-
graph in Figure 1. In such a v-structure A⊥⊥B, but it is not true that A⊥⊥B|C. That is, A and B are
marginally independent, but conditionally dependent given C. This can be easily checked by writing out
P (A, B, C) = P (A)P (B)P (C|A, B). Summing out C leads to P (A, B) = P (A)P (B). However, given the
value of C, P (A, B|C) = P (A)P (B)P (C|A, B)/P (C) which does not factor into separate functions of A and
B. As a consequence of this property of v-structures, in a directed graph a variable X is independent of all
other variables given the parents of X, the children of X, and the parents of the children of X. This is the
minimal set that d-separates X from the rest of the graph and is known as the Markov boundary for X.

It is possible, though not always appropriate, to interpret a directed graphical model as a causal generative
model of the data. The following procedure would generate data from the probability distribution deﬁned by
a directed graph: draw a random value from the marginal distribution of all variables which do not have any
parents (e.g. a ∼ P (A), b ∼ P (B)), then sample from the conditional distribution of the children of these
variables (e.g. c ∼ P (C|A = a, B = a)), and continue this procedure until all variables are assigned values. In
the model, P (C|A, B) can capture the causal relationship between the causes A and B and the eﬀect C. Such
causal interpretations are much less natural for undirected and factor graphs, since even generating a sample
from such models cannot easily be done in a hierarchical manner starting from “parents” to “children” except

14

Figure 2: No directed graph over 4 variables can represent the set of conditional independence relationships
represented by this undirected graph.

in special cases. Moreover, the potential functions capture mutual compatibilities, rather than cause-eﬀect
relations.

graphs, each term is a conditional probability and is therefore already normalisedP

A useful property of directed graphical models is that there is no global normalisation constant c. This
global constant can be computationally intractable to compute in undirected and factor graphs. In directed
x P (Xi = x|Xpai) = 1.

7.4 Expressive power
Directed, undirected and factor graphs are complementary in their ability to express conditional independence
relationships. Consider the directed graph consisting of a single v-structure A → C ← B. This graph encodes
A⊥⊥B but not A⊥⊥B|C. There exists no undirected graph or factor graph over these three variables which
captures exactly these independencies. For example, in A − C − B it is not true that A⊥⊥B but it is true
that A⊥⊥B|C. Conversely, if we consider the undirected graph in Figure 2, we see that some independence
relationships are better captured by undirected models (and factor graphs).

8 Exact inference in graphs

Probabilistic inference in a graph usually refers to the problem of computing the conditional probability of
some variable Xi given the observed values of some other variables Xobs = xobs while marginalising out all
other variables. Starting from a joint distribution P (X1, . . . , XN ), we can divide the set of all variables into
three exhaustive and mutually exclusive sets {X1, . . . XN} = {Xi} ∪ Xobs ∪ Xother. We wish to compute

P
P
x0P

P (Xi|Xobs = xobs) =

x P (Xi, Xother = x, Xobs = xobs)
x P (Xi = x0, Xother = x, Xobs = xobs)

(32)

The problem is that the sum over x is exponential in the number of variables in Xother. For example.
if
there are M variables in Xother and each is binary, then there are 2M possible values for x. If the variables
are continuous, then the desired conditional probability is the ratio of two high-dimensional integrals, which
could be intractable to compute. Probabilistic inference is essentially a problem of computing large sums
and integrals.

There are several algorithms for computing these sums and integrals which exploit the structure of the
graph to get the solution eﬃciently for certain graph structures (namely trees and related graphs). For
general graphs the problem is fundamentally hard [13].

15

8.1 Elimination
The simplest algorithm conceptually is variable elimination. It is easiest to explain with an example. Con-
sider computing P (A = a|D = d) in the directed graph in Figure 1. This can be written

c

P (A = a|D = d) ∝ X
= X
= X
= X

c

c

b

b

e

X
X

X
X
X
P (D = d|C = c, B = b)X
X

e

b

P (A = a, B = b, C = c, D = d, E = e)

e

P (A = a)P (B = b)P (C = c|A = a, B = b)
P (D = d|C = c, B = b)P (E = e|C = c, D = d)
P (A = a)P (B = b)P (C = c|A = a, B = b)

P (A = a)P (B = b)P (C = c|A = a, B = b)
P (D = d|C = c, B = b)

c

b

P (E = e|C = c, D = d)

What we did was (1) exploit the factorisation, (2) rearrange the sums, and (3) eliminate a variable, E. We
could repeat this procedure and eliminate the variable C. When we do this we will need to compute a new

c P (C = c|A = a, B = b)P (D = d|C = c, B = b), resulting in:

function φ(A = a, B = b, D = d) def= P
Finally, we eliminate B by computing φ0(A = a, D = d) def= P

P (A = a|D = d) ∝X

b

ﬁnal answer which can be written

b P (B = b)φ(A = a, B = b, D = d) to get our

P (A = a)P (B = b)φ(A = a, B = b, D = d)

P (A = a|D = d) ∝ P (A = a)φ0(A = a, D = d) = P (A = a)φ0(A = a, D = d)
a P (A = a)φ0(A = a, D = d)

P

The functions we get when we eliminate variables can be thought of as messages sent by that variable to its
neighbours. Eliminating transforms the graph by removing the eliminated node and drawing (undirected)
edges between all the nodes in the Markov boundary of the eliminated node.

The same answer is obtained no matter what order we eliminate variables in; however, the computational

complexity can depend dramatically on the ordering used.

8.2 Belief propagation
The belief propagation (BP) algorithm is a message passing algorithm for computing conditional probabilities
of any variable given the values of some set of other variables in a singly-connected directed acyclic graph
[64]. The algorithm itself follows from the rules of probability and the conditional independence properties
of the graph. Whereas variable elimination focuses on ﬁnding the conditional probability of a single variable
Xi given Xobs = xobs, belief propagation can compute at once all the conditionals p(Xi|Xobs = xobs) for all
i not observed.

We ﬁrst need to deﬁne singly-connected directed graphs. A directed graph is singly connected if between
every pair of nodes there is only one undirected path. An undirected path is a path along the edges of the
graph ignoring the direction of the edges:
in other words the path can traverse edges both upstream and
downstream. If there is more than one undirected path between any pair of nodes then the graph is said to
be multiply connected, or loopy (since it has loops).

Singly connected graphs have an important property which BP exploits. Let us call the set of observed
X and
variables the evidence, e = Xobs. Every node in the graph divides the evidence into upstream e+
downstream e−
X parts. For example, in Figure 3 the variables U1 . . . Un their parents, ancestors, and children
and descendents (not including X, its children and descendents) and anything else connected to X via an

16

Figure 3: Belief propagation in a directed graph.

edge directed toward X are all considered to be upstream of X; anything connected to X via an edge away
from X is considered downstream of X (e.g. Y1, its children, the parents of its children, etc). Similarly,
every edge X → Y in a singly connected graph divides the evidence into upstream and downstream parts.
This separation of the evidence into upstream and downstream components does not generally occur in
multiply-connected graphs.
Belief propagation uses three key ideas to compute the probability of some variable given the evidence
p(X|e), which we can call the “belief” about X.4 First, the belief about X can be found by combining
upstream and downstream evidence:

P (X|e) = P (X, e)
P (e)

∝ P (X, e+

X , e−

X) ∝ P (X|e+

X)P (e−

X|X)

(33)

The last proportionality results from the fact that given X the downstream and upstream evidence are
X|X). Second, the eﬀect of the upstream and downstream
conditionally independent: P (e−
evidence on X can be computed via a local message passing algorithm between the nodes in the graph.
Third, the message from X to Y has to be constructed carefully so that node X doesn’t send back to Y
any information that Y sent to X, otherwise the message passing algorithm would reverberate information
between nodes amplifying and distorting the ﬁnal beliefs.

X) = P (e−

X|X, e+

Using these ideas and the basic rules of probability we can arrive at the following equations, where ch(X)

and pa(X) are children and parents of X, respectively:

λ(X) def= P (e−

π(X) def= P (X|e+

X|X) = Y
X) = X

j∈ch(X)

U1...Un

|X)

P (e−

XYj

P (X|U1, . . . , Un) Y

i∈pa(X)

P (Ui|e+

UiX)

(34)

(35)

Finally, the messages from parents to children (e.g. X to Yj) and the messages from children to parents (e.g.
X to Ui) can be computed as follows:

πYj (X)

λX(Ui)

XYj

)
P (e−

def= P (X|e+

∝ hY
= X

k6=j
UiX|Ui)
def= P (e−
P (e−

|X)

XYk

X|X)X

P (X|U1 . . . Un)Y

i X
P (X|U1 . . . Un)Y

U1,...,Un

i

P (Uk|e+

UkX)

X

Uk:k6=i

k6=i

P (Ui|e+

UiX)

(36)

(37)

4There is considerably variety in the ﬁeld regarding the naming of algorithms. Belief propagation is also known as the

sum-product algorithm, a name which some people prefer since beliefs seem subjective.

17

XYUUY11n............mIt is important to notice that in the computation of both the top-down message (36) and the bottom-up
message (37) the recipient of the message is explicitly excluded. Pearl’s [64] mnemonic of calling these
messages λ and π messages is meant to reﬂect their role in computing “likelihood” and “prior” terms.

BP includes as special cases two important algorithms: Kalman smoothing for linear-Gaussian state-space
models, and the forward–backward algorithm for hidden Markov models. Although BP is only valid on singly
connected graphs there is a large body of research on its application to multiply connected graphs—the use
of BP on such graphs is called loopy belief propagation and has been analysed by several researchers [81, 82].
Interest in loopy belief propagation arose out of its impressive performance in decoding error correcting
codes [21, 9, 50, 49]. Although the beliefs are not guaranteed to be correct on loopy graphs, interesting
connections can be made to approximate inference procedures inspired by statistical physics known as the
Bethe and Kikuchi free energies [84].

8.3 Factor graph propagation
In belief propagation, there is an asymmetry between the messages a child sends its parents and the messages
a parent sends its children. Propagation in singly-connected factor graphs is conceptually much simpler and
easier to implement. In a factor graph, the joint probability distribution is written as a product of factors.
Consider a vector of variables x = (x1, . . . , xn)

p(x) = p(x1, . . . , xn) =

1
Z

fj(xSj )

(38)

Y

j

where Z is the normalisation constant, Sj denotes the subset of {1, . . . , n} which participate in factor fj and
xSj = {xi : i ∈ Sj}.

Let n(x) denote the set of factor nodes that are neighbours of x and let n(f) denote the set of variable
nodes that are neighbours of f. We can compute probabilities in a factor graph by propagating messages
from variable nodes to factor nodes and vice-versa. The message from variable x to function f is:

while the message from function f to variable x is:

Once a variable has received all messages from its neighbouring factor nodes we can compute the probability
of that variable by multiplying all the messages and renormalising:

Again, these equations can be derived by using Bayes rule and the conditional independence relations in
a singly-connected factor graph. For multiply-connected factor graphs (where there is more than one path
between at least one pair of variable nodes) one can apply a loopy version of factor graph propagation. Since
the algorithms for directed graphs and factor graphs are essentially based on the same ideas, we also call the
loopy version of factor graph propagation “loopy belief propagation”.

8.4 Junction tree algorithm
For multiply-connected graphs, the standard exact inference algorithms are based on the notion of a junction
tree [46]. The basic idea of the junction tree algorithm is to group variables so as to convert the multiply-
connected graph into a singly-connected undirected graph (tree) over sets of variables, and do inference in
this tree.

18

µh→x(x)



µy→f (y)

µf→x(x) =X

h∈n(x)\{f}

µx→f (x) = Y
f(x) Y
p(x) ∝ Y

x\x

y∈n(f )\{x}

µh→x(x)

h∈n(x)

(39)

(40)

(41)

We will not explain the algorithm in detail here, but rather give an overview of the steps involved.
Starting from a directed graph, undirected edges are introduced between every pair of variables that share a
child. This step is called “moralisation” in a tongue-in-cheek reference to the fact that it involves marrying
the unmarried parents of every node. All the remaining edges are then changed from directed to undirected.
We now have an undirected graph which does not imply any additional conditional or marginal independence
relations which were not present in the original directed graph (although the undirected graph may easily
have many fewer conditional or marginal independence relations than the directed graph). The next step
of the algorithm is “triangulation” which introduces an edge cutting across every cycle of length 4. For
example, the cycle A− B − C − D− A which would look like Figure 2 would be triangulated either by adding
an edge A − C or an edge B − D. Once the graph has been triangulated, the maximal cliques of the graph
are organised into a tree, where the nodes of the tree are cliques, by placing edges in the tree between some
of the cliques with an overlap in variables (placing edges between all overlaps may not result in a tree). In
general it may be possible to build several trees in this way, and triangulating the graph means than there
exists a tree with the “running intersection property”. This property ensures that none of the variable is
represented in disjoint parts of the tree, as this would cause the algorithm to come up with multiple possibly
inconsistent beliefs about the variable. Finally, once the tree with the running intersection property is built
(the junction tree) it is possible to introduce the evidence into the tree and apply what is essentially a variant
of belief propagation to this junction tree. This BP algorithm is operating on sets of variables contained
in the cliques of the junction tree, rather than on individual variables in the original graph. As such, the
complexity of the algorithm scales exponentially with the size of the largest clique in the junction tree. For
example, if moralisation and triangulation results in a clique containing K binary variables, the junction tree
algorithm would have to store and manipulate tables of size 2K. Moreover, ﬁnding the optimal triangulation
to get the most eﬃcient junction tree for a particular graph is NP-complete [4, 44].

8.5 Cutest conditioning
In certain graphs the simplest inference algorithm is cutset conditioning which is related to the idea of
“reasoning by assumptions”. The basic idea is very straightforward: ﬁnd some small set of variables such
that if they were given (i.e. you knew their values) it would make the remainder of the graph singly connected.
For example, in the undirected graph in Figure 1, given C or D, the rest of the graph is singly connected.
This set of variables is called the cutset. For each possible value of the variables in the cutset, run BP on
the remainder of the graph to obtain the beliefs on the node of interest. These beliefs can be averaged with
appropriate weights to obtain the true belief on the variable of interest. To make this more concrete, assume
you want to ﬁnd P (X|e) and you discover a cutset consisting of a single variable C. Then

P (X|C = c, e)P (C = c|e)

(42)

P (X|e) =X

where the beliefs P (X|C = c, e) and corresponding weights P (C = c|e) are computed as part of BP, run
once for each value of c.

c

9 Learning in graphical models

In Section 8 we described exact algorithms for inferring the value of variables in a graph with known
parameters and structure. If the parameters and structure are unknown they can be learned from the data
[31]. The learning problem can be divided into learning the graph parameters for a known structure, and
learning the model structure (i.e. which edges should be present or absent).5

We focus here on directed graphs with discrete variables, although some of these issues become much
more subtle for undirected and factor graphs [57]. The parameters of a directed graph with discrete variables
parameterise the conditional probability tables P (Xi|Xpai). For each setting of Xpai this table contains a

5It should be noted that in Bayesian statistics there is no fundamental diﬀerence between parameters and variables, and
therefore the learning and inference problems are really the same. All unknown quantities are treated as random variables, and
learning is just inference about parameters and structure. It is however often useful to distinguish between parameters, which
we assume to be fairly constant over the data, and variables, which we can assume to vary over each data point.

19

probability distribution over Xi. For example, if all variables are binary and Xi has K parents, then this
conditional probability table has 2K+1 entries; however, since the probability over Xi has to sum to 1 for
each setting of its parents there are only 2K independent entries. The most general parameterisation would
have a distinct parameter for each entry in this table, but this is often not a natural way to parameterise the
dependency between variables. Alternatives (for binary data) are the noisy-or or sigmoid parameterisation
of the dependencies [58]. Whatever the speciﬁc parameterisation, let θi denote the parameters relating
Xi to its parents, and let θ denote all the parameters in the model. Let m denote the model structure,
which corresponds to the set of edges in the graph. More generally the model structure can also contain the
presence of additional hidden variables [16].

9.1 Learning graph parameters
We ﬁrst consider the problem of learning graph parameters when the model structure is known and there
are no missing or hidden variables. The presence of missing/hidden variables complicates the situation.

9.1.1 The complete data case.

Assume that the parameters controlling each family (a child and its parents) are distinct and that we
observe N iid instances of all K variables in our graph. The data set is therefore D = {X (1) . . . X (N )} and
the likelihood can be written

P (D|θ) =

P (X (n)|θ) =

P (X (n)

i

|X (n)

pai

, θi)

(43)

Similarly, if the prior factors over the θi, then the Bayesian posterior is also factored: P (θ|D) =Q

Clearly, maximising the log likelihood with respect to the parameters results in K decoupled optimisation
problems, one for each family, since the log likelihood can be written as a sum of K independent terms.
i P (θi|D).

n=1

n=1

i=1

9.1.2 The incomplete data case.

When there is missing/hidden data, the likelihood no longer factors over the variables. Divide the variables in
obs }
X (n) into observed and missing components, X (n)
obs . . . X (N )
and the likelihood is:

mis. The observed data is now D = {X (1)

obs and X (n)

NY

NY

KY

n=1

NY
NY
NY

n=1

P (X (n)

obs|θ)

X
X

(n)
mis

x

KY

P (D|θ) =

=

=

P (X (n)

mis = x(n)

mis, X (n)

obs|θ)

P (X (n)

i

|X (n)

pai

, θi)

(44)

(45)

(46)

n=1

x

(n)
mis

i=1

where in the last expression the missing variables are assumed to be set to the values x(n)
mis. Because of the
missing data, the cost function can no longer be written as a sum of K independent terms and the parameters
are all coupled. Similarly, even if the prior factors over the θi, the Bayesian posterior will couple all the θi.
One can still optimise the likelihood by making use of the EM algorithm (Section 3). The E step of EM
infers the distribution over the hidden variables given the current setting of the parameters. This can be
done with BP for singly connected graphs or with the junction tree algorithm for multiply-connected graphs.
In the M step, the objective function being optimised conveniently factors in exactly the same way as in the
complete data case (c.f. Equation (21)). Whereas for the complete data case, the optimal ML parameters
can often be computed in closed form, in the incomplete data case an iterative algorithm such as EM is
usually required.

20

Bayesian parameter inference in the incomplete data case is also substantially more complicated. The
parameters and missing data are coupled in the posterior distribution, as can be seen by multiplying (45)
by the parameter prior and normalising. Inference can be achieved via approximate inference methods such
as Markov chain Monte Carlo methods (Section 11.3, [59]) like Gibbs sampling, and variational approxima-
tions (Section 11.4, [6]).

9.2 Learning graph structure
There are two basic components to learning the structure of a graph from data: scoring and search. Scoring
refers to computing a measure which can be used to compare diﬀerent structures m and m0 given a data set
D. Search refers to searching over the space of possible model structures, usually by proposing changes to the
current model, so as to ﬁnd the model with the highest score. This view of structure learning presupposes
that the goal is to ﬁnd a single structure with the highest score, although of course in the Bayesian inference
framework it is desirable to infer the probability distribution over model structures given the data.

9.2.1 Scoring metrics.

Assume that you have a prior P (m) over model structures, which is ideally based on some domain knowledge.
The natural score to use is the probability of the model given the data (although see [32]) or some monotonic
function of this:

s(m,D) = P (m|D) ∝ P (D|m)P (m).

(47)

This score requires computing the marginal likelihood

Z

P (D|m) =

P (D|θ, m)P (θ|m)dθ.

(48)

We discuss the intuitions behind the marginal likelihood as a natural score for model comparison in Section 10.
For directed graphical models with fully-observed discrete variables and factored Dirichlet priors over the
parameters of the conditional probability tables, the integral in (48) is analytically tractable. For models
with missing/hidden data, alternative choices of priors and types of variables, the integral in (48) is often
intractable and approximation methods are required. Some of the standard approximations that can be
applied in this context and many other Bayesian inference problems are brieﬂy reviewed in Section 11.

9.2.2 Search algorithms.

Given a way of scoring models, one can search over the space of all possible valid graphical models for the
one with the highest score [19]. The space of all possible graphs is very large (exponential in the number of
variables) and for directed graphs it can be expensive to check whether a particular change to the graph will
result in a cycle being formed. Thus intelligent heuristics are needed to search the space eﬃciently [55]. An
alternative to trying to ﬁnd the most probable graph are methods that sample over the posterior distribution
of graphs [20]. This has the advantage that it avoids the problem of overﬁtting which can occur for algorithms
that select a single structure with highest score out of exponentially many.

10 Bayesian model comparison and Occam’s Razor

So far in this chapter we have seen many diﬀerent kinds of models. One of the most important problems
in unsupervised learning is automatically determining which models are appropriate for a given data set.
Model selection and comparison questions include all of the following:

• Are there clusters in the data and if so, how many? What are their shapes (e.g. Gaussian, t-distributed)?
• Does the data live on a low dimensional manifold? What dimensionality? Is this manifold ﬂat or

curved?

• Is the data discretised? If so, to what precision?

21

• Is the data a time series? If so, is it better modelled by an HMM, a state-space model? Linear or
nonlinear? Gaussian or non-Gaussian noise? How many states should the HMM have? How many
state variables should the SSM have?

• Can the data be modelled well by a directed graph? What is the structure of this graph? Does it have

hidden variables? Are these continuous or discrete?

Clearly, this list could go on. A human may be able to answer these questions via careful use of visualisation,
hypothesis testing, and guesswork. But ultimately, an intelligent unsupervised learning system should be
able to answer all these questions automatically.

Fortunately, the framework of Bayesian inference can be used to provide a rational, coherent and auto-
matic way of answering all of the above questions. This means that, given a complete speciﬁcation of the
prior assumptions there is an automatic procedure (based on Bayes rule) which provides a unique answer. Of
course, as always, if the prior assumptions are very poor, the answers obtained could be useless. Therefore,
it is essential to think carefully about the prior assumptions before turning the automatic Bayesian handle.
Let us go over this automatic procedure. Consider a model mi coming from a set of possible models
{m1, m2, m3, . . .}. For instance, the model mi might correspond to a Gaussian mixture model with i com-
ponents. The models need not be nested, nor does the space of models need to be discrete (although we’ll
focus on that case). Given data D, the natural way to compare models is via their probability:

P (mi|D) = P (D|mi)P (mi)

P (D)

(49)

Z

P (D|mi) =

P (D|θi, mi)P (θ|mi) dθi

P (D) =P

To compare models, the denominator, which sums over the potentially huge space of all possible models,
j P (D|mj)P (mj) is not required. Prior preference for models can be included in P (mi). However,
it is interesting to look closely at the marginal likelihood term (sometimes called the evidence for model mi).
Assume that model mi has parameters θi (e.g. the means and covariance matrices of the i Gaussians, along
with the mixing proportions, c.f. Section 2.4). The marginal likelihood integrates over all possible parameter
values

(50)
where P (θ|mi) is the prior over parameters, which is required for a complete speciﬁcation of the model mi.
The marginal likelihood has a very interesting interpretation. It is the probability of generating data
set D from parameters that are randomly sampled from under the prior for mi. This should be contrasted
with the maximum likelihood for mi which is the probability of the data under the single setting of the
parameters ˆθi that maximises P (D|θi, mi). Clearly a more complicated model will have a higher maximum
likelihood, which is the reason why maximising the likelihood results in overﬁtting — i.e. a preference for
more complicated models than necessary. In contrast, the marginal likelihood can decrease as the model
becomes more complicated. In a more complicated model sampling random parameter values can generate
a wider range of possible data sets, but since the probability over data sets has to integrate to 1 (assuming
a ﬁxed number of data points) spreading the density to allow for more complicated data sets necessarily
results in some simpler data sets having lower density under the model. This situation is diagrammed in
Figure 4. The decrease in the marginal likelihood as additional parameters are added has been called the
automatic Occam’s Razor [37, 47, 66].

In theory all the questions posed at the beginning of this section could be addressed by deﬁning appro-
priate priors and carefully computing marginal likelihoods of competing hypotheses. However, in practice
the integral in (50) is usually very high dimensional and intractable. It is therefore necessary to approximate
it.

11 Approximating posteriors and marginal likelihoods

There are many ways of approximating the marginal likelihood of a model, and the corresponding parameter
posterior. In this section, we review some of the most frequently used methods.

22

Figure 4: The marginal likelihood (evidence) as a function of an abstract one dimensional representation
of “all possible” data sets of some size N. Because the evidence is a probability over data sets, it must
normalise to one. Therefore very complex models which can account for many datasets only achieve modest
evidence; simple models can reach high evidences, but only for a limited set of data. When a dataset D is
observed, the evidence can be used to select between model complexities.

11.1 Laplace approximation
It can be shown that under some regularity conditions, for large amounts of data N relative to the number of
parameters in the model, d, the parameter posterior is approximately Gaussian around the MAP estimate, ˆθ:

p(θ|D, m) ≈ (2π)− d

2 |A| 1

2 exp

(θ − ˆθ)>A (θ − ˆθ)

(cid:26)
−1
2

(cid:27)

(51)

(52)

Here A is the d × d negative of the Hessian matrix which measures the curvature of the log posterior at the
MAP estimate:

Aij = − d2
dθidθj

log p(θ|D, m)

(cid:12)(cid:12)(cid:12)(cid:12)θ=ˆθ

The matrix A is also referred to as the observed information matrix. Equation (51) is the Laplace approxi-
mation to the parameter posterior.

By Bayes rule, the marginal likelihood satisﬁes the following equality at any θ:

p(D|m) = p(θ,D|m)
p(θ|D, m)

(53)

The Laplace approximation to the marginal likelihood can be derived by evaluating the log of this expression
at ˆθ, using the Gaussian approximation to the posterior from equation (51) in the denominator:

log p(D|m) ≈ log p(ˆθ|m) + log p(D|ˆθ, m) + d
2

log 2π − 1
2

log |A|

(54)

11.2 The Bayesian information criterion (BIC)
One of the disadvantages of the Laplace approximation is that it requires computing the determinant of the
Hessian matrix. For models with many parameters, the Hessian matrix can be very large, and computing
its determinant can be prohibitive.

The Bayesian Information Criterion (BIC) is a quick and easy way to compute an approximation to the
marginal likelihood. BIC can be derived from the Laplace approximation by dropping all terms that do not
depend on N, the number of data points. Starting from equation (54), we note that the ﬁrst and third terms
are constant with respect to the number of data points. Referring to the deﬁnition of the Hessian, we can
see that its elements grow linearly with N. In the limit of large N we can therefore write A = N ˜A, where

23

too simpletoo complex"just right"All possible data setsP(D|mi)D˜A is a matrix independent of N. We use the fact that for any scalar c and d × d matrix P , the determinant
|cP| = cd|P|, to get

1
2

log |A| ≈ d
2

log N +

log | ˜A|

1
2

(55)

The last term does not grow with N, so by dropping it and substituting into Eq. (54) we get the BIC
approximation:

log p(D|m) ≈ log p(D|ˆθ, m) − d
2

log N

(56)

This expression is extremely easy to compute. Since the expression does not involve the prior it can be used
either when ˆθ is the MAP or the ML parameter estimate, the latter choice making the entire procedure
independent of a prior. The likelihood is penalised by a term that depends linearly on the number of
parameters in the model; this term is referred to as the BIC penalty. This is how BIC approximates the
Bayesian Occam’s Razor eﬀect which penalises overcomplex models. The BIC criterion can also be derived
from within the Minimum Description Length (MDL) framework.

The BIC penalty is clearly attractive since it does not require any costly integrals or matrix inversions.
However this simplicity comes at a cost in accuracy which can sometimes be catastrophic. One of the dangers
of BIC is that it relies on the number of parameters. The basic assumption underlying BIC, that the Hessian
converges to N times a full-rank matrix, only holds for models in which all parameters are identiﬁable and
well-determined. This is often not true.

11.3 Markov chain Monte Carlo (MCMC)
Monte Carlo methods are a standard and often extremely eﬀective way of computing complicated high
dimensional integrals and sums. Many Bayesian inference problems can be seen as computing the integral
(or sum) of some function f(θ) under some probability density p(θ):

f(θ)p(θ) dθ.

(57)

Z

¯f def=

MX

i=1

¯f ≈ 1
M

For example, the marginal likelihood is the integral of the likelihood function under the prior. Simple Monte
Carlo approximates (57) by sampling M independent draws θi ∼ p(θ) and computing the sample average
of f:

f(θi)

(58)

There are many limitations of simple Monte Carlo, for example it is often not possible to draw directly from
p. Generalisations of simple Monte Carlo such as rejection sampling and importance sampling attempt to
overcome some of these limitations.

An important family of generalisations of Monte Carlo methods are Markov chain Monte Carlo (MCMC)
methods. These are commonly used and powerful methods for approximating the posterior over parameters
and the marginal likelihood. Unlike simple Monte Carlo methods, the samples are not drawn independently
but rather dependently in the form of a Markov chain . . . θi → θi+1 → θt+2 . . . where each sample depends
on the value of the previous sample. MCMC estimates have the property that the asymptotic distribution
of θi is the desired distribution. That is, limt→∞ pt(θt) = p(θ). Creating MCMC methods is somewhat of
an art, and there are many MCMC methods available, some of which are reviewed in [59]. Some notable
examples are Gibbs sampling, the Metropolis algorithm, and Hybrid Monte Carlo.

11.4 Variational approximations
Variational methods can be used to derive a family of lower bounds on the marginal likelihood and to perform
approximate Bayesian inference over the parameters of a probabilistic models [38, 83, 79]. Variational
methods provide an alternative to the asymptotic and sampling-based approximations described above;
they tend to be more accurate than the asymptotic approximations like BIC and faster than the MCMC
approaches.

24

Z

Z

Let y denote the observed variables, x denote the latent variables, and θ denote the parameters. The log
marginal likelihood of data y can be lower bounded by introducing any distribution over both latent variables
and parameters which has support where p(x, θ|y, m) does, and then appealing to Jensen’s inequality (due
to the concavity of the logarithm function):

ln p(y|m) = ln

p(y, x, θ|m) dx dθ = ln

dx dθ

(59)

Z
q(x, θ) p(y, x, θ|m)
q(x, θ)
q(x, θ) ln p(y, x, θ|m)
q(x, θ)

Z

≥

(60)
Maximising this lower bound with respect to the free distribution q(x, θ) results in q(x, θ) = p(x, θ|y, m)
which when substituted above turns the inequality into an equality (c.f. Section 3). This does not simplify
the problem since evaluating the true posterior distribution p(x, θ|y, m) requires knowing its normalising
constant, the marginal likelihood. Instead we use a simpler, factorised approximation q(x, θ) = qx(x)qθ(θ):

dx dθ.

ln p(y|m) ≥

qx(x)qθ(θ) ln p(y, x, θ|m)

qx(x)qθ(θ) dx dθ def= Fm(qx(x), qθ(θ), y).

(61)

The quantity Fm is a functional of the free distributions, qx(x) and qθ(θ).

The variational Bayesian algorithm iteratively maximises Fm in equation (61) with respect to the free
distributions, qx(x) and qθ(θ). We use elementary calculus of variations to take functional derivatives of
the lower bound with respect to qx(x) and qθ(θ), each while holding the other ﬁxed. This results in the
following update equations where the superscript (t) denotes the iteration number:

(cid:20)Z

(cid:20)Z

(cid:21)

q(t+1)
x

(x) ∝ exp

ln p(x,y|θ, m) q(t)

θ (θ) dθ

q(t+1)
θ

(θ) ∝ p(θ|m) exp

ln p(x,y|θ, m) q(t+1)

x

(cid:21)

(x) dx

(62)

(63)

When there is more than one data point then there are diﬀerent hidden variables xi associated with each
data point yi and the step in (62) has to be carried out for each i, where the distributions are q(t)

Clearly qθ(θ) and qxi(xi) are coupled, so we iterate these equations until convergence. Recalling the EM
algorithm (Section 3 and [14, 63]) we note the similarity between EM and the iterative algorithm in (62)
and (63). This procedure is called the Variational Bayesian EM Algorithm and generalises the usual EM
algorithm; see also [5] and [22].
between qx(x) qθ(θ) and the joint posterior p(x, θ|y, m):

Re-writing (61), it is easy to see that maximising Fm is equivalent to minimising the KL divergence

xi (xi).

ln p(y|m)−Fm(qx(x), qθ(θ), y) =

qx(x) qθ(θ) ln qx(x) qθ(θ)

p(θ, x|y, m) dx dθ = KL(qkp)

(64)

Z

Note that while this factorisation of the posterior distribution over latent variables and parameters may
seem drastic, one can think of it as replacing stochastic dependencies between x and θ with deterministic
dependencies between relevant moments of the two sets of variables. To compare between models m and
m0 one can evaluate Fm and Fm0. This approach can, for example, be used to score graphical model
structures [6].

Summarising, the variational Bayesian EM algorithm simultaneously computes an approximation to the

marginal likelihood and to the parameter posterior by maximising a lower bound.

11.5 Expectation propagation (EP)
Expectation propagation (EP; [52, 53]) is another powerful method for approximate Bayesian inference.
Consider a Bayesian inference problem in which you are given iid data D = {x(1) . . . , x(N )} assumed to have
come from a model p(x|θ) parameterised by θ with prior p(θ). The parameter posterior is:

p(x(i)|θ).

(65)

NY

i=1

p(θ|D) =

1
p(D) p(θ)

25

To make the notation more general we can write the quantity we wish to approximate as a product of factors
over θ,

p(x(i)|θ)

(66)

where f0(θ) def= p(θ) and fi(θ) def= p(x(i)|θ) and we will ignore the normalising constants. We wish to
approximate this by a product of simpler terms

NY

fi(θ) = p(θ)

i=0

i=1

NY

NY

i=0

q(θ) def=

˜fi(θ).

(67)

For example, consider a binary linear classiﬁcation problem where θ are the parameters of the classiﬁcation
hyperplane and p(θ) is a Gaussian prior ([53], Chapter 5). The true posterior is the product of this Gaussian
and N likelihood terms, each of which deﬁnes a half-plane consistent with the class label observed. This
posterior has a complicated shape, but we can approximate it using EP by assuming that each of the
approximate likelihood terms ˜fi is Gaussian in θ. Since the product of Gaussians is Gaussian, q(θ) will be
a Gaussian approximation to the posterior. In general, one makes the approximate terms ˜fi belong to some
exponential family distribution so the overall approximation is in the same exponential family.

Having decided on the form of the approximation (67), let us consider how to tune this approximation
so as to make it as accurate as possible. Ideally we would like to minimise the KL divergence between the
true and the approximate distributions:

  NY

i=0

(cid:13)(cid:13)(cid:13)(cid:13)(cid:13) NY

i=0

KL

min
q(θ)

!

fi(θ)

˜fi(θ)

.

(68)

For example, if q(θ) is a Gaussian density, minimising this KL divergence will result in ﬁnding the exact mean
and covariance of the true posterior distribution over parameters. Unfortunately, this KL divergence involves
averaging with respect to the true posterior distribution, which will generally be intractable. Note that the
KL divergence in Equation (68) is diﬀerent from the KL minimised by variational Bayesian methods (64);
the former averages with respect to the true distribution and is therefore usually intractable, while the latter
averages with respect to the approximate distribution and is often tractable. Moreover, for exponential
family approximations the former KL has a unique global optimum, while the latter usually has multiple
local optima.

Since we cannot minimise (68) we can instead consider minimising the KL divergence between each true

term and the corresponding approximate term. That is, for each i:

(cid:16)

(cid:17)

KL

min
˜fi(θ)

fi(θ)k ˜fi(θ)

.

(69)

This will usually be much easier to do, but each such approximate term will result in some error. Multiplying
all the approximate terms together will probably result in an unacceptably inaccurate approximation. On the
plus side, this approach is non-iterative in that once each term is approximated they are simply multiplied
to get a ﬁnal answer.

The Expectation Propagation (EP) algorithm is an iterative procedure which is as easy as the naive
approach in (69) but which results in a much more accurate approximation. At each step of EP, one of the
terms is optimised in the context of all the other approximate terms, i.e. for each i:

fi(θ)Y
KL divergence the ith exact term is incorporated intoQ
is done by matching the appropriate moments (expectations) of fi(θ)Q

Since the approximate terms depend on each other, this procedure is iterated. On the left hand side of the
˜fj(θ), which is assumed to be in the exponential
family. The right hand side is an exponential-family approximation to this whole product. The minimisation
˜fj(θ). The name “Expectation

(cid:13)(cid:13)(cid:13) ˜fi(θ)Y

.

(70)

min
˜fi(θ)

˜fj(θ)

˜fj(θ)

(cid:16)

(cid:17)

j6=i

j6=i

KL

j6=i

j6=i

26

Propagation” comes from the fact that each step corresponds to computing certain expectations, and the
eﬀect of these expectations is propagated to subsequent terms in the approximation. In fact, the messages
in belief propagation can be derived as a particular form of EP where the approximating distribution is

assumed to be a fully factored product of marginals over the variables in θ, i.e. q(θ) =Q

In its simplest form, the EP algorithm can be summarised as in Figure 5. Although the algorithm as
described here often converges, each step of the algorithm is not in fact decreasing any objective function
so there is no guarantee of convergence. Convergent forms of EP can be derived by making use of the EP
energy function [51] although these may not be as fast and simple to implement as the algorithm in Figure 5.

k qk(θk) [53].

Initialise ˜f0(θ) = f0(θ), ˜fi(θ) = 1 for i > 0, q(θ) =Q

Input f0(θ) . . . fN (θ)

˜fi(θ)

i

repeat

for i = 0 . . . N do

˜fj(θ)
KL(fi(θ)q\i(θ)kf(θ)q\i(θ))

=Y

Deletion: q\i(θ) ← q(θ)
˜fi(θ)
Projection: ˜f new
Inclusion: q(θ) ← ˜f new

j6=i
(θ) ← arg min
f (θ)
(θ) q\i(θ)

i

i

end for

until convergence

Figure 5: The EP algorithm. Some variations are possible: this assumes that f0 is in the exponential
family, and updates sequentially over i rather than randomly. The names for the steps (deletion, projection,
inclusion) are not the same as in [53]

12 Conclusion

In this chapter, we have seen that unsupervised learning can be viewed from the perspective of statistical
modelling. Statistics provides a coherent framework for learning from data and for reasoning under uncer-
tainty. Many interesting statistical models used for unsupervised learning can be cast as latent variable
models and graphical models. These types of models have played an important role in deﬁning unsupervised
learning systems for a variety of diﬀerent kinds of data. Graphical models have also played an important
unifying framework for thinking about the role of conditional independence in inference in models with many
variables. While for certain models exact inference is computationally tractable, for most of the models in
this chapter we have seen that exact inference involves intractable sums and integrals. Thus, the study
of unsupervised learning has lead us into focusing on ways of approximating high dimensional sums and
integrals. We have reviewed many of the principal approximations, although of course in the limited space
of this chapter one cannot hope to have a comprehensive review of approximation methods.

There are many interesting and relevant topics we did not get a chance to cover in this review of un-
supervised learning. One of these is the interplay of unsupervised and supervised learning, in the form of
semi-supervised learning. Semi-supervised learning refers to learning problems in which there is a small
amount of labelled data and a large amount of unlabelled data. These problems are very natural, especially
in domains where collecting data can be cheap (i.e. the internet) but labelling it can be expensive or time
consuming. The key question in semi-supervised learning is how the data distribution from the unlabelled
data should inﬂuence the supervised learning problem [71]. Many of the approaches to this problem at-
tempt to infer a manifold, graph structure, or tree-structure from the unlabelled data and use spread in this
structure to determine how labels will generalise to new unlabelled points [74, 85, 8, 42].

Another area of great interest which we did not have the space to cover are nonparametric models.
The basic assumption of parametric statistical models is that the model is deﬁned using a ﬁnite number of

27

parameters. The number of parameters is assumed ﬁxed regardless of the number of data points. Thus the
parameters provide a ﬁnite summary of the data. In nonparametric models, the number of “parameters”
in the model is allowed to grow with the size of the data set. With more data, the model becomes more
complex, with no a-priori limit on the complexity of the model. For this reason nonparametric models
are also sometimes called inﬁnite models. An important example of this are inﬁnite mixture models, more
formally known as Dirichlet Process mixtures [3, 18]. These correspond to mixture models (Section 2.4)
where the number of components is assumed to be inﬁnite. Inference can be done in these models using
MCMC methods [17, 60, 65], variational methods [12], or the EP algorithm [54]. Just as hidden Markov
models can be seen as an extension of ﬁnite mixture models to model time series data, it is possible to extend
inﬁnite mixture models to hidden Markov models with inﬁnitely many states [7]. Inﬁnite models based on
Dirichlet processes have also been generalised to be hierarchical in several diﬀerent ways [61, 75]. Bayesian
inference in nonparametric models is one of the most active areas of research in unsupervised learning, and
there still remain many open problems.

As we have seen, the ﬁeld of unsupervised learning can be understood formally within the framework of
information theory and statistics. However, it is important not to lose sight of the tremendous inﬂuence ideas
from neuroscience and psychology have had on the ﬁeld. Many of the models we have reviewed here started life
as models of brain function. These models were inspired by the brain’s ability to extract statistical patterns
from sensory data and to recognise complex visual scenes, sounds, and odours. Unsupervised learning theory
and algorithms still have a long way to go to mimic some of the learning abilities of biological brains. As
the boundaries of unsupervised learning get pushed forward, we will hopefully not only beneﬁt from better
learning machines and also improve our understanding of how the brain learns.

References

[1] D. H. Ackley, G. E. Hinton, and T. J. Sejnowski. A learning algorithm for Boltzmann machines.

Cognitive Science, 9:147–169, 1985.

[2] B. D. O. Anderson and J. B. Moore. Optimal Filtering. Prentice-Hall, Englewood Cliﬀs, NJ, 1979.

[3] C. E. Antoniak. Mixtures of Dirichlet processes with applications to Bayesian nonparametric problems.

Annals of Statistics, 2(6):1152–1174, 1974.

[4] S. Arnborg, D. G. Corneil, and A. Proskurowski. Complexity of ﬁnding embeddings in a k-tree. SIAM

Journal of Algebraic and Discrete Methods, 8:277–284, 1987.

[5] H. Attias. Inferring parameters and structure of latent variable models by variational Bayes. In Proc.

15th Conf. on Uncertainty in Artiﬁcial Intelligence, 1999.

[6] M. J. Beal and Z. Ghahramani. The variational Bayesian EM algorithm for incomplete data: With
In J. M. Bernardo, A. P. Dawid, J. O. Berger,
application to scoring graphical model structures.
M. West, D. Heckerman, and M. J. Bayarri, editors, Bayesian Statistics 7. Oxford University Press,
2003.

[7] M.J. Beal, Z. Ghahramani, and C.E. Rasmussen. The inﬁnite hidden Markov model. In Advances in

Neural Information Processing Systems, volume 14. MIT Press, 2001.

[8] M. Belkin and P. Niyogi. Semi-supervised learning on Riemannian manifolds. Machine Learning, 56(1–

3):209–239, 2004.

[9] C. Berrou, A. Glavieux, and P. Thitimajshima. Near shannon limit error-correcting coding and decoding:

Turbo-codes (1). In Proc. ICC ’93, pages 1064–1070, 1993.

[10] J. Besag. Spatial interaction and the statistical analysis of lattice systems. Journal of the Royal

Statistical Society. Ser. B, 6:192–236, 1974.

[11] C. M. Bishop, M. Svensen, and C. K. I. Williams. GTM: The generative topographic mapping. Neural

Computation, 10(1):215–234, 1998.

28

[12] D. Blei and M. I. Jordan. Variational methods for the Dirichlet process. In Proceedings of the 21st

International Conference on Machine Learning, 2004.

[13] G. F. Cooper. The computational complexity of probabilistic inference using Bayesian belief networks.

Artiﬁcial Intelligence, 42(2-3):393–405, 1990.

[14] A.P. Dempster, N.M. Laird, and D.B. Rubin. Maximum likelihood from incomplete data via the EM

algorithm. J. Royal Statistical Society Series B, 39:1–38, 1977.

[15] A. Doucet, J. F. G. de Freitas, and N.J. Gordon. Sequential Monte Carlo Methods in Practice. Springer-

Verlag, New York, 2000.

[16] G. Elidan, N. Lotner, N. Friedman, and D. Koller. Discovering hidden variables: A structure-based

approach. In Advances in Neural Information Processing Systems (NIPS), 2001.

[17] M. D. Escobar and M. West. Bayesian density estimation and inference using mixtures. Journal of the

American Statistical Association, 90(430):577–588, 1995.

[18] T. S. Ferguson. Bayesian density estimation by mixtures of normal distributions. In Recent Advances

in Statistics, pages 287–302, New York, 1983. Academic Press.

[19] N. Friedman. The Bayesian structural EM algorithm. In Proc. Fourteenth Conference on Uncertainty

in Artiﬁcial Intelligence (UAI ’98), San Francisco, CA, 1998. Morgan Kaufmann.

[20] N. Friedman and D. Koller. Being Bayesian about network structure: A Bayesian approach to structure

discovery in Bayesian networks. Machine Learning, 50:95–126, 2003.

[21] R. G. Gallager. Low-Density Parity-Check Codes. MIT Press, Cambridge, MA, 1963.

[22] Z. Ghahramani and M. J. Beal. Propagation algorithms for variational Bayesian learning. In Advances

in Neural Information Processing Systems 13, Cambridge, MA, 2001. MIT Press.

[23] Z. Ghahramani and G. E. Hinton. The EM algorithm for mixtures of factor analyzers. University of

Toronto, Technical Report CRG-TR-96-1, 1996.

[24] Z. Ghahramani and M. I. Jordan. Factorial hidden Markov models. Machine Learning, 29:245–273,

1997.

[25] Z. Ghahramani and S. T. Roweis. Learning nonlinear dynamical systems using an EM algorithm. In

NIPS 11, pages 431–437, 1999.

[26] F. Girosi, M. Jones, and T. Poggio. Regularization theory and neural networks architectures. Neural

Computation, 7(2):219–269, 1995.

[27] N. J. Gordon, D. J. Salmond, and A. F. M. Smith. A novel approach to nonlinear/non-Gaussian
Bayesian state space estimation. IEE Proceedings F: Radar and Signal Processing, 140:107–113, 1993.

[28] P. J. Green. Penalized likelihood. In Encyclopedia of Statistical Sciences, Update Volume 2, 1998.

[29] J. E. Handschin and D. Q. Mayne. Monte Carlo techniques to estimate the conditional expectation in

multi-stage non-linear ﬁltering. International Journal of Control, 9(5):547–559, 1969.

[30] T. Hastie and W. Stuetzle. Principle curves.

84(406):502–516, 1989.

Journal of the American Statistical Association,

[31] D. Heckerman. A tutorial on learning with Bayesian networks. Technical Report MSR-TR-95-06,

Microsoft Research, 1996.

[32] D. Heckerman and D. M. Chickering. A comparison of scientiﬁc and engineering criteria for Bayesian

model selection, 1996.

29

[33] G. E. Hinton, P. Dayan, B. J. Frey, and R. M. Neal. The wake-sleep algorithm for unsupervised neural

networks. Science, 268:1158–1161, 1995.

[34] G. E. Hinton, P. Dayan, and M. Revow. Modeling the manifolds of images of handwritten digits. IEEE

Trans. Neural Networks, 8(1):65–74, 1997.

[35] M. Isard and A. Blake. Condensation – conditional density propagation for visual tracking, 1998.

[36] E. T. Jaynes. Probability Theory: The Logic of Science (Edited by G. Larry Bretthorst). Cambridge

University Press, 2003.

[37] W.H. Jeﬀerys and J.O. Berger. Ockham’s razor and Bayesian analysis. American Scientist, 80:64–72,

1992.

[38] M. I. Jordan, Z. Ghahramani, T. S. Jaakkola, and L. K. Saul. An introduction to variational methods

in graphical models. Machine Learning, 37:183–233, 1999.

[39] S. J. Julier and J. K. Uhlmann. A new extension of the Kalman ﬁlter to nonlinear systems. In Int.

Symp. Aerospace/Defense Sensing, Simulation and Controls, 1997.

[40] K. Kanazawa, D. Koller, and S. J. Russell. Stochastic simulation algorithms for dynamic probabilistic
networks. In P. Besnard and S. Hanks, editors, Uncertainty in Artiﬁcial Intelligence. Proceedings of the
Eleventh Conference., pages 346–351. Morgan Kaufmann Publishers, San Francisco, CA, 1995.

[41] Y. Karklin and M. S. Lewicki. Learning higher-order structures in natural images. Network: Computa-

tion in Neural Systems, 14:483–499, 2003.

[42] C. Kemp, T. L. Griﬃths, S. Stromsten, and J. B. Tenenbaum. Semi-supervised learning with trees. In

NIPS 16, 2004.

[43] G. Kitagawa. Monte Carlo ﬁlter and smoother for non-Gaussian nonlinear state space models. J. of

Computational and Graphical Statistics, 5:1–25, 1996.

[44] U. Kjaerulﬀ. Triangulation of graphs—algorithms giving small total state space, 1990.

[45] J. B. Kruskal. Multidimensional scaling by optimizing goodness of ﬁt to a nonmetric hypothesis. Psy-

chometrika, 29:1–27 and 115–129, 1964.

[46] S. L. Lauritzen and D. J. Spiegelhalter. Local computations with probabilities on graphical structures

and their application to expert systems. J. Royal Statistical Society B, pages 157–224, 1988.

[47] D. J. C. MacKay. Probable networks and plausible predictions—a review of practical Bayesian methods

for supervised neural networks. Network: Computation in Neural Systems, 6:469–505, 1995.

[48] D. J. C. MacKay.

Press, 2003.

Information Theory, Inference, and Learning Algorithms. Cambridge University

[49] D. J. C. MacKay and R. M. Neal. Good error-correcting codes based on very sparse matrices. IEEE

Transactions on Information Theory, 45(2):399–431, 1999.

[50] R. J. McEliece, D. J. C. MacKay, and J.-F. Cheng. Turbo decoding as an instance of Pearl’s ‘Belief
Propagation’ algorithm. IEEE Journal on Selected Areas in Communications, 16(2):140–152, February
1998.

[51] T. P. Minka. The EP energy function and minimization schemes. Technical report, 2001.

[52] T. P. Minka. Expectation propagation for approximate Bayesian inference. In Uncertainty in Artiﬁcial
Intelligence: Proceedings of the Seventeenth Conference (UAI-2001), pages 362–369, San Francisco, CA,
2001. Morgan Kaufmann Publishers.

[53] T. P. Minka. A family of algorithms for approximate Bayesian inference. PhD thesis, MIT, 2001.

30

[54] T. P. Minka and Z. Ghahramani. Expectation propagation for inﬁnite mixtures. Technical report,

Presented at NIPS’03 Workshop on Nonparametric Bayesian Methods and Inﬁnite Models, 2003.

[55] A. Moore and W-K. Wong. Optimal reinsertion: A new search operator for accelerated and more
accurate Bayesian network structure learning. In T. Fawcett and N. Mishra, editors, Proceedings of the
20th International Conference on Machine Learning (ICML ’03), pages 552–559, Menlo Park, California,
August 2003. AAAI Press.

[56] K. P. Murphy. Dynamic Bayesian Networks: Representation, Inference and Learning. PhD thesis, UC

Berkeley, Computer Science Division, 2002.

[57] I. Murray and Z. Ghahramani. Bayesian learning in undirected graphical models: Approximate MCMC

algorithms. In Proceedings of UAI, 2004.

[58] R. M. Neal. Connectionist learning of belief networks. Artiﬁcial Intelligence, 56:71–113, 1992.

[59] R. M. Neal. Probabilistic inference using Markov chain Monte Carlo methods. Technical report, De-

partment of Computer Science, University of Toronto, September 1993.

[60] R. M. Neal. Markov chain sampling methods for Dirichlet process mixture models. Journal of Compu-

tational and Graphical Statistics, 9:249–265, 2000.

[61] R. M. Neal. Density modeling and clustering using Dirichlet diﬀusion trees. In J. M. Bernardo et al.,

editor, Bayesian Statistics 7, pages 619–629, 2003.

[62] R. M. Neal, M. J. Beal, and S. T. Roweis. Inferring state sequences for non-linear systems with embedded
hidden Markov models. In S. Thrun, L. Saul, and B. Sch¨olkopf, editors, Advances in Neural Information
Processing Systems 16, Cambridge, MA, 2004. MIT Press.

[63] R. M. Neal and G. E. Hinton. A new view of the EM algorithm that justiﬁes incremental, sparse, and

other variants. In M. I. Jordan, editor, Learning in Graphical Models. Kluwer Academic Press, 1998.

[64] J. Pearl. Probabilistic Reasoning in Intelligent Systems: Networks of Plausible Inference. Morgan

Kaufmann, San Mateo, CA, 1988.

[65] C. E. Rasmussen. The inﬁnite Gaussian mixture model. In Adv. Neur. Inf. Proc. Sys. 12, pages 554–560,

2000.

[66] C. E. Rasmussen and Z. Ghahramani. Occam’s razor. In Advances in Neural Information Processing

Systems 13, Cambridge, MA, 2001. MIT Press.

[67] S. T. Roweis. EM algorithms for PCA and SPCA. In M. I. Jordan, M. J. Kearns, and S. A. Solla,

editors, Advances in Neural Information Processing Systems, volume 10. The MIT Press, 1998.

[68] S. T. Roweis and Z. Ghahramani. A unifying review of linear Gaussian models. Neural Computation,

11(2):305–345, 1999.

[69] S. T. Roweis and L. K. Saul. Nonlinear dimensionality reduction by locally linear embedding. Science,

290:2323–2326, 2000.

[70] R. Salakhutdinov, S. T. Roweis, and Z. Ghahramani. Optimization with EM and Expectation-
Conjugate-Gradient. In International Conference on Machine Learning (ICML-2003), pages 672–679,
2003.

[71] M. Seeger. Learning with labeled and unlabeled data. Technical report, University of Edinburgh, 2001.

[72] R. N. Shepard. The analysis of proximities: multidimensional scaling with an unknown distance function

i and ii. Psychometrika, 27:125–139 and 219–246, 1962.

[73] R. H. Shumway and D. S. Stoﬀer. An approach to time series smoothing and forecasting using the EM

algorithm. J. Time Series Analysis, 3(4):253–264, 1982.

31

[74] M. Szummer and T. S. Jaakkola. Partially labeled classiﬁcation with Markov random walks. In NIPS,

2001.

[75] Y. W. Teh, M. I. Jordan, M. J. Beal, and D. M. Blei. Hierarchical Dirichlet processes. Technical Report

653, Department of Statistics, University of California at Berkeley, 2004.

[76] J. B. Tenenbaum, V. de Silva, and J. C. Langford. A global geometric framework for nonlinear dimen-

sionality reduction. Science, 290(5500):2319–2323, 2000.

[77] M. E. Tipping and C. M. Bishop. Mixtures of probabilistic principal component analyzers. Neural

Computation, 11(2):443–482, 1999.

[78] M. E. Tipping and C. M. Bishop. Probabilistic principal component analysis. Journal of the Royal

Statistical Society, Series B, 61(3):611–622, 1999.

[79] M. J. Wainwright and M. I. Jordan. Graphical models, exponential families, and variational inference.

Technical Report 649, UC Berkeley, Dept. of Statistics, 2003.

[80] E. A. Wan, R. van der Merwe, and A. T. Nelson. Dual estimation and the unscented transformation.

In NIPS 12, pages 666–672, 2000.

[81] Y. Weiss. Correctness of local probability propagation in graphical models with loops. Neural Compu-

tation, 12(1):1–41, 2000.

[82] Y. Weiss and W. T. Freeman. On the optimality of solutions of the max-product belief-propagation
algorithm in arbitrary graphs. IEEE Transactions on Information Theory, Special Issue on Codes on
Graphs and Iterative Algorithms, 47, 2001.

[83] J. Winn. Variational Message Passing and its Applications. PhD thesis, Department of Physics, Uni-

versity of Cambridge, 2003.

[84] J. S. Yedidia, W. T. Freeman, and Y. Weiss. Generalized belief propagation. In NIPS 13, Cambridge,

MA, 2001. MIT Press.

[85] X. Zhu, Z. Ghahramani, and J. Laﬀerty. Semi-supervised learning using Gaussian ﬁelds and harmonic

functions. In The Twentieth International Conference on Machine Learning (ICML-2003), 2003.

32

