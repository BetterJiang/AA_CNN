The Annals of Applied Statistics
2007, Vol. 1, No. 2, 302–332
DOI: 10.1214/07-AOAS131
© Institute of Mathematical Statistics, 2007

PATHWISE COORDINATE OPTIMIZATION

BY JEROME FRIEDMAN,1 TREVOR HASTIE,2 HOLGER HÖFLING3

AND ROBERT TIBSHIRANI4

Stanford University

We consider “one-at-a-time” coordinate-wise descent algorithms for a
class of convex optimization problems. An algorithm of this kind has been
proposed for the L1-penalized regression (lasso) in the literature, but it seems
to have been largely ignored. Indeed, it seems that coordinate-wise algorithms
are not often used in convex optimization. We show that this algorithm is
very competitive with the well-known LARS (or homotopy) procedure in
large lasso problems, and that it can be applied to related methods such as the
garotte and elastic net. It turns out that coordinate-wise descent does not work
in the “fused lasso,” however, so we derive a generalized algorithm that yields
the solution in much less time that a standard convex optimizer. Finally, we
generalize the procedure to the two-dimensional fused lasso, and demonstrate
its performance on some image smoothing problems.

1. Introduction.

In this paper we consider statistical models that lead to con-
vex optimization problems with inequality constraints. Typically, the optimization
for these problems is carried out using a standard quadratic programming algo-
rithm. The purpose of this paper is to explore “one-at-a-time” coordinate-wise
descent algorithms for these problems. The equivalent of a coordinate descent al-
gorithm has been proposed for the L1-penalized regression (lasso) in the literature,
but it is not commonly used. Moreover, coordinate-wise algorithms seem too sim-
ple, and they are not often used in convex optimization, perhaps because they only
work in specialized problems. We ourselves never appreciated the value of coordi-
nate descent methods for convex statistical problems before working on this paper.
In this paper we show that coordinate descent is very competitive with the well-
known LARS (or homotopy) procedure in large lasso problems, can deliver a
path of solutions efﬁciently, and can be applied to many other convex statistical
problems such as the garotte and elastic net. We then go on to explore a non-
separable problem in which coordinate-wise descent does not work—the “fused
lasso.” We derive a generalized algorithm that yields the solution in much less
time that a standard convex optimizer. Finally, we generalize the procedure to

Received May 2007; revised August 2007.
1Supported in part by NSF Grant DMS-97-64431.
2Supported in part by NSF Grant DMS-05-50676 and NIH Grant 2R01 CA 72028-07.
3Supported by an Albion Walter Hewlett Stanford Graduate Fellowship.
4Supported in part by NSF Grant DMS-99-71405 and NIH Contract N01-HV-28183.
Key words and phrases. Coordinate descent, lasso, convex optimization.

302

PATHWISE COORDINATE OPTIMIZATION

303

the two-dimensional fused lasso, and demonstrate its performance on some im-
age smoothing problems.

A key point here: coordinate descent works so well in the class of problems that
we consider because each coordinate minimization can be done quickly, and the
relevant equations can be updated as we cycle through the variables. Furthermore,
often the minimizers for many of the parameters don’t change as we cycle through
the variables, and hence, the iterations are very fast.
Consider, for example, the lasso for regularized regression [Tibshirani (1996)].
We have predictors xij , j = 1, 2, . . . , p, and outcome values yi for the ith
(cid:1)
observation, for i = 1, 2, . . . , n. Assume that the xij are standardized so that
i xij /n = 0,

(cid:1)
i x2

ij

(cid:4)2

xij βj

(cid:3)
n(cid:2)
i=1

= 1. The lasso solves
yi − p(cid:2)
j=1
p(cid:2)
j=1

subject to

min
β

1
2

|βj| ≤ s.

(1)

(cid:3)

The bound s is a user-speciﬁed parameter, often chosen by a model selection pro-
cedure such as cross-validation. Equivalently, the solution to (1) also minimizes
the “Lagrange” version of the problem

(cid:4)2 + γ
p(cid:2)
(2)
j=1
if ˆβ(γ ) minimizes (2), then it also solves (1) with s =(cid:1)p
where γ ≥ 0. There is a one-to-one correspondence between γ and the bound s—
| ˆβj (γ )|. In the signal
processing literature, the lasso and L1 penalization is known as “basis pursuit”
[Chen et al. (1998)].

yi − p(cid:2)

f (β) = 1

n(cid:2)
i=1

|βj|,

j=1

j=1

xij βj

2

There are efﬁcient algorithms for solving this problem for all values of s or γ ;
see Efron et al. (2004), and the homotopy algorithm of [Osborne et al. (2000)].
There is another, simpler algorithm for solving this problem for a ﬁxed value γ . It
relies on solving a sequence of single-parameter problems, which are assumed to
be simple to solve.

With a single predictor, the lasso solution is very simple, and is a soft-
thresholded version [Donoho and Johnstone (1995)] of the least squares esti-

mate ˆβ:

(3)

(4)

ˆβlasso(γ ) = S( ˆβ, γ ) ≡ sign( ˆβ)(| ˆβ| − γ )+




=

ˆβ − γ ,
ˆβ + γ ,

0,

if ˆβ > 0 and γ < | ˆβ|,
if ˆβ < 0 and γ < | ˆβ|,
if γ ≥ | ˆβ|.

304

J. FRIEDMAN, T. HASTIE, H. HÖFLING AND R. TIBSHIRANI

FIG. 1. The lasso problem with a single standardized predictor leads to soft thresholding. In each
case the solid vertical line indicates the lasso estimate, and the broken line the least-squares estimate.

This simple expression arises because the convex-optimization problem (2) re-
duces to a few special cases when there is a single predictor. Minimizing the crite-
rion (2) with a single standardized x and β simpliﬁes to the equivalent problem

i xi yi is the simple least-squares coefﬁcient. If β > 0, we can differ-

(5)

where ˆβ =(cid:1)

entiate (5) to get

(6)

2 (β − ˆβ)2 + γ|β|,

1

min
β

= β − ˆβ + γ = 0.

df

dβ

This leads to the solution β = ˆβ − γ (left panel of Figure 1) as long as ˆβ > 0 and
γ < ˆβ, otherwise 0 is the minimizing solution (right panel). Similarly, if ˆβ < 0, if
γ < − ˆβ, then the solution is β = ˆβ + γ , else 0.

With multiple predictors that are uncorrelated, it is easily seen that once again
the lasso solutions are soft-thresholded versions of the individual least squares
estimates. This is not the case for general (correlated) predictors. Consider instead
a simple iterative algorithm that applies soft-thresholding with a “partial residual”
as a response variable. We write (2) as

(7)

f ( ˜β) = 1

2

˜βk − xij βj

xik

| ˜βj| + γ|βj|,

where all the values of βk for k (cid:4)= j are held ﬁxed at values ˜βk(γ ). Minimizing
w.r.t. βj , we get

(8)

˜βj (γ ) ← S

yi − ˜y

(j )
i

xij

, γ

,

(cid:3)
n(cid:2)
i=1

yi −(cid:2)

k(cid:4)=j

(cid:4)2 + γ

(cid:2)
k(cid:4)=j

(cid:4)

(cid:9)

(cid:8)

(cid:3)
n(cid:2)
i=1

PATHWISE COORDINATE OPTIMIZATION

305

=(cid:1)

FIG. 2. Diabetes data: iterates for each coefﬁcient from algorithm (9). The algorithm converges to
the lasso estimates shown on the right side of the plot.

(j )
i

k(cid:4)=j xik

˜βk(γ ). This is simply the univariate regression coefﬁcient
where ˜y
of the partial residual yi − ˜y
on the (unit L2-norm) j th variable; hence, this has
the same form as the univariate version (3) above. The update (7) is repeated for
j = 1, 2, . . . , p, 1, 2, . . . until convergence.

(j )
i

An equivalent form of this update is

˜βj (γ ) ← S

(9)

(cid:3)
˜βj (γ ) + n(cid:2)

i=1

(cid:4)

xij (yi − ˜yi ), γ

,

j = 1, 2, . . . p, 1, 2, . . . .

Starting with any values for βj , for example, the univariate regression coefﬁ-
cients, it can be shown that the ˜βj (γ ) values converge to ˆβlasso.

Figure 2 shows an example, using the diabetes data from Efron et al. (2004).
This data has 442 observations and 10 predictors. We applied algorithm (9) with
γ = 88. It produces the iterates shown in the ﬁgure and converged after 14 steps to
the lasso solution ˆβlasso(88).

This approach provides a simple but fast algorithm for solving the lasso, espe-
cially useful for large p. It was proposed in the “shooting” procedure of Fu (1998)
and re-discovered by [Daubechies, Defrise and De Mol (2004)]. Application of the
same idea to the elastic net procedure [Zhou and Hastie (2005)] was proposed by
[Van der Kooij (2007)].

(cid:1)

2. Pathwise coordinatewise optimization algorithms. The procedure de-
scribed in Section 1 is a successive coordinate-wise descent algorithm for mini-
mizing the function f (β) = 1
|βj|. The idea is to
apply a coordinate-wise descent procedure for each value of the regularization pa-
rameter, varying the regularization parameter along a path. Each solution is used
as a warm start for the next problem.

j xij βj )2 + λ

i (yi −(cid:1)

(cid:1)p
j=1

2

306

J. FRIEDMAN, T. HASTIE, H. HÖFLING AND R. TIBSHIRANI

This approach is attractive whenever the single-parameter problem is easy to
solve. Some of these algorithms have already been proposed in the literature, and
we give appropriate references. Here are some other examples:
• The nonnegative garotte. This method, a precursor to the lasso, was proposed
by Breiman (1995) and solves

(cid:3)
n(cid:2)
i=1

yi − p(cid:2)

j=1

(cid:4)2 + λ

p(cid:2)
j=1

ˆβj

xij cj

(10)

min

c

1
2

cj

subject to

cj ≥ 0.

Here ˆβj are the usual least squares estimates (we assume that p ≤ n). Using

partial residuals as in (7), one can show that the the coordinate-wise update has
the form

(11)

where ˜βj =(cid:1)
• Least absolute deviation regression and LAD-lasso. Here the problem is

i=1 xij (yi − ˜y

k(cid:4)=j xikck

ˆβk.

(j )
i

n

j

(j )
i

(cid:11)
ˆβj − λ
ˆβ2
=(cid:1)
(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)yi − β0 − p(cid:2)
(cid:12)(cid:12)(cid:12)(cid:12) (yi − ˜y
|xij|

(cid:10) ˜βj
cj ←
), and ˜y
n(cid:2)
i=1
n(cid:2)
i=1

j=1

(j )
i

xij

)

min
β

+,

(cid:12)(cid:12)(cid:12)(cid:12)(cid:12).
(cid:12)(cid:12)(cid:12)(cid:12),

xij βj

− βj

(12)

We can write this as

(13)

holding all but βj ﬁxed. This quantity is minimized over βj by a weighted me-
dian of the values (yi − ˜y
)/xij . Hence, coordinate-wise minimization is just
a repeated computation of medians. This approach is studied and reﬁned by Li
and Arce (2004).

(j )
i

The same approach may be used in the LAD-lasso [Wang et al. (2006)]. Here

we add an L1 penalty to the least absolute deviation loss:

(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)yi − β0 − p(cid:2)

j=1

n(cid:2)
i=1

(cid:12)(cid:12)(cid:12)(cid:12)(cid:12) + λ

p(cid:2)
j=1

|βj|.

xij βj

(14)

min
β

This can be converted into an LAD problem (12) by augmenting the dataset
with p artiﬁcial observations. In detail, let X denote n × (p + 1) model ma-
trix (with the column of 1s for the intercept). The extra p observations have
response yi equal to zero, and predictor matrix equal to λ · (0 : Ip). Then the
above coordinate-wise algorithm for the LAD problem can be applied.

PATHWISE COORDINATE OPTIMIZATION

307

• The elastic net. This method [due to Zhou and Hastie (2005)] adds a second
constraint

j

1
2

min
β

(cid:4)2 + λ1

(cid:1)p
≤ s2 to the lasso (1). In Lagrange form, we solve
j=1 β2
(cid:3)
yi − n(cid:2)
n(cid:2)
i=1
j=1
(cid:1)
i=1 xij (yi − ˜y
˜βj ← S(
1 + λ2

|βj| + λ2

p(cid:2)
j=1

p(cid:2)
j=1

), λ1)+

β2
j /2.

xij βj

(j )
i

n

.

The coordinate-wise update has the form

(15)

(16)

Thus, we compute the simple least squares coefﬁcient on the partial residual, ap-
ply soft-thresholding to take care of the lasso penalty, and then apply a propor-
tional shrinkage for the ridge penalty. This algorithm was suggested by Van der
Kooij (2007).
• Grouped lasso [Yuan and Lin (2006)]. This is like the lasso, except variables
occur in groups (such as dummy variables for multi-level factors). Suppose Xj
is an N × pj orthonormal matrix that represents the j th group of pj variables,
j = 1, . . . , m, and βj the corresponding coefﬁcient vector. The grouped lasso
solves

(cid:13)(cid:13)(cid:13)(cid:13)(cid:13)y − m(cid:2)

(cid:13)(cid:13)(cid:13)(cid:13)(cid:13)2

+ m(cid:2)

λj(cid:6)βj(cid:6)2,

min
β

(19)

2

Xj βj

j=1

j=1

min
β

(17)
√
pj . Other choices of λj ≥ 0 are possible; this one penalizes large
where λj = λ
groups more heavily. Notice that the penalty is a weighted sum of L2 norms (not
squared); this has the effect of selecting the variables in groups. Yuan and Lin
(2006) argue for a coordinate-descent algorithm for solving this problem, and
show through the Karush–Kuhn–Tucker conditions that the coordinate updates
are given by

(18)
where Sj = XT
• The “Berhu” penalty. This method is due to Owen (2006), and is another com-
promise between an L1 and L2 penalty. In Lagrange form, we solve

˜βj ← ((cid:6)Sj(cid:6)2 − λj )+ Sj(cid:6)Sj(cid:6)2
˜βk.
k(cid:4)=j Xk

,

j (y − ˜y(j )), and here ˜y(j ) =(cid:1)
(cid:3)
n(cid:2)
1
i=1
2
+ λ

yi − n(cid:2)
j=1
(cid:14)
p(cid:2)
|βj| · I (|βj| < δ) + (β2
j=1

(cid:4)2

xij βj

j

(cid:15)
· I (|βj| ≥ δ)

.

+ δ2)
2δ

308

J. FRIEDMAN, T. HASTIE, H. HÖFLING AND R. TIBSHIRANI

This penalty is the reverse of a “Huber” function—initially absolute value, but
then blending into quadratic beyond δ from zero. The coordinate-wise update
has the form

(20)

˜βj ←

(cid:8)




S

(cid:3)
n(cid:2)
n(cid:2)
i=1
i=1

xij

(cid:4)

(cid:9)

, λ

,

yi − ˜y(j )
(cid:9)

xij

(cid:8)

yi − ˜y(j )

/(1 + λ/δ),

if |βj| < δ,
if |βj| ≥ δ.

This is a lasso-style soft-thresholding for values less than δ, and ridge-style be-
yond δ.

Tseng (1988) [see also Tseng (2001)] has established that coordinate descent
works in problems like the above. He considers minimizing functions of the form

f (β1, . . . , βp) = g(β1, . . . , βp) + p(cid:2)

i=j

hj (βj ),

(21)
where g(·) is differentiable and convex, and the hj (·) are convex. Here each βj
(cid:1)p
can be a vector, but the different vectors cannot have any overlapping members.
He shows that coordinate descent converges to the minimizer of f . The key to
j=1 hj (βj ), a sum of func-
this result is the separability of the penalty function
tions of each individual parameter. This result implies that the coordinate-wise
algorithms for the lasso, the grouped lasso and elastic net, etc. converge to their
optimal solutions.

Next we examine coordinate-wise descent in a more complicated problem, the
“fused lasso” [Tibshirani, Saunders, Rosset, Zhu and Knight (2005)], which we
represent in Lagrange form:

(22)

f (β) = 1

2

(cid:3)
n(cid:2)
i=1

yi − p(cid:2)

j=1

(cid:4)2 + λ1

p(cid:2)
j=1

xij βj

|βj| + λ2

|βj − βj−1|.

p(cid:2)
j=2

The ﬁrst penalty encourages sparsity in the coefﬁcients; the second penalty en-
courages sparsity in their differences; that is, ﬂatness of the coefﬁcient proﬁles βj
as a function of the index set j . Note that f (β) is strictly convex, and hence has a
unique minimum.
The left panel of Figure 3 shows an example of an application of the fused lasso,
in a special case where the feature matrix {xij} is the identity matrix—this is called
fused lasso signal approximation, discussed in the next section. The data represents
Comparative Genomic Hybridization (CGH) measurements from two Glioblas-
toma Multiforme (GBM) tumors. The measurements are “copy numbers”—log-
ratios of the number of copies of each gene in the tumor versus normal tissue. The
data are displayed in the left panel, and the red line in the right panel represents the

PATHWISE COORDINATE OPTIMIZATION

309

FIG. 3. Fused lasso applied to some Glioblastoma Multiforme data. The data are shown in the left
panel, and the jagged line in the right panel represents the inferred copy number ˆβ from the fused
lasso. The horizontal line is for y = 0.
smoothed signal ˆβ from the fused lasso. The regions of the nonzero estimated sig-

nal can be used to call “gains” and “losses” of genes. Tibshirani and Wang (2007)
report excellent results in the application of the fused lasso, ﬁnding that the method
outperforms other popular techniques for this problem.

Somewhat surprisingly, coordinate-wise descent does not work for the fused
lasso. Proposition 2.7.1 of Bertsekas (1999), for example, shows that every limit
point of successive coordinate-wise minimization of a continuously differentiable
function is a stationary point for the overall minimization, provided that the min-
imum is uniquely obtained along each coordinate. However, f (β) is not contin-
uously differentiable, which means that coordinate-wise descent can get stuck.
Looking at Tseng’s result, the penalty function for the fused lasso is not separable,
and hence, Tseng’s theorem cannot be applied in that case.

Figure 4 illustrates the difﬁculty. We created a fused lasso problem with 100
parameters, with the solutions for two of the parameters, β63 and β64, being equal
to about −1. The top panels shows slices of the function f (β) varying β63 and β64,
with the other parameters set to the global minimizers. We see that the coordinate-
wise descent algorithm has got stuck in a corner of the response surface, and is
stationary under single-coordinate moves. In order to advance to the minimum, we
have to move both β63 and β64 together.

Despite this, it turns out that the coordinate-wise descent procedure can be mod-
iﬁed to work for the fused lasso, yielding an algorithm that is much faster than a
general quadratic-program solver for this problem.

3. The fused lasso signal approximator. Here we consider a variant of the
fused lasso (22) for approximating one- and higher-dimensional signals, which we
call the fused-lasso signal approximator (FLSA). For one-dimensional signals we

310

J. FRIEDMAN, T. HASTIE, H. HÖFLING AND R. TIBSHIRANI

FIG. 4. Failure of coordinate-wise descent in a fused lasso problem with 100 parameters. The

optimal values for two of the parameters, β63 and β64, are both −1.05, as shown by the dot in the

right panel. The left and middle panels shows slices of the objective function f (β) as a function of
β63 and β64, with the other parameters set to the global minimizers. The coordinate-wise minimizer
over both β63 and β64 (separately) is −0.69, rather than −1.05. The right panel shows contours of
the two-dimensional surface. The coordinate-descent algorithm is stuck at (−0.69, −0.69). Despite
being strictly convex, the surface has corners, in which the coordinate-wise procedure can get stuck.
In order to travel to the minimum we have to move both β63 and β64 together.

solve

(23)

f (β) = 1

2

min
β

n(cid:2)
(yi − βi )2 + λ1
i=1

n(cid:2)
i=1

|βi| + λ2

n(cid:2)
i=2

|βi − βi−1|.

The measurements yi are made along a one-dimensional index i, and there is one
parameter per observation. Later we consider images as well. In the special case
of λ1 = 0, the fused-lasso signal approximator is equivalent to a discrete version
of the “total variation denoising” procedure [Rudin et al. (1992)] used in signal
processing. We make this connection clear in Section 6. Thus, the algorithm that
we present here also provides a fast implementation for total variation denoising.
Figure 5 illustrates an example of FLSA with 1000 simulated data points, and
the ﬁt is shown for s1 = 269.2, s2 = 10.9.

We now describe a modiﬁed coordinate-wise algorithm for the diagonal fused
lasso (FLSA) using the Lagrange form (23). The algorithm can also be extended to
the general fused lasso problem; details are given in the Appendix. However, it is
not guaranteed to give the exact solution for that problem, as we later make clear.
Our algorithm, for a ﬁxed value λ1, delivers a sequence of solutions correspond-
ing to an increasing sequence of values for λ2. First we make an observation that
makes it easy to obtain the solution over a grid of λ1 and λ2 values:

(cid:8)
PROPOSITION 1. The solutions to (23) for all (λ
1 > λ1, λ2) can be obtained

by soft-thresholding the solution for (λ1, λ2).

This is proven in the Appendix for the FLSA, two-dimensional penalty fused
lasso and even more general penalty functionals. Thus, our overall strategy for

PATHWISE COORDINATE OPTIMIZATION

311

FIG. 5. Fused lasso solution in a constructed example.

obtaining the solution over a grid is to solve the problem for λ1 = 0 over a grid
of values of λ2, and then use this result to obtain the solution for all values of λ1.
However, for a single (especially large) value of λ1, we demonstrate that it is faster
to obtain the solution directly for that value of λ1 (Table 2). Hence, we present our
algorithm for ﬁxed but arbitrary values of λ1.

Two keys for the algorithm are assumptions (A1) and (A2) below, stating that
for ﬁxed λ1, small increments in the value of λ2 can only cause pairs of parameters
to fuse and they do not become unfused for the larger of λ2. This allows us to
efﬁciently solve the problem for a path of λ2 values, keeping λ1 ﬁxed.

The algorithm has three nested cycles:

Descent cycle: Here we run coordinate-wise descent for each parameter βj , hold-

ing all the others ﬁxed.

Fusion cycle: Here we consider the fusion of a neighboring pair of parameters,

followed by coordinate-wise descent.

Smoothing cycle: Here we increase the penalty λ2 a small amount, and rerun the

two previous cycles.

We now describe each in more detail.

Descent cycle. Consider the derivative of (23), holding all βk = ˜βk, k (cid:4)= i ﬁxed

at their current values:

∂f (β)

∂βi

(24)

= −(yi − βi ) + λ1 · sign(βi )

− λ2 · sign( ˜βi+1 − βi ) + λ2 · sign(βi − ˜βi−1),

assuming that βi /∈ {0, ˜βi−1, ˜βi+1}.
expression in (24) is piecewise linear in βi with breaks at 0, ˜βi−1 and ˜βi+1. Sup-
pose, for example, at a given iteration we have 0 ≤ ˜βi−1 ≤ ˜βi+1. We check for

The algorithm for coordinate-wise minimization of f (β) works as follows. The

312

J. FRIEDMAN, T. HASTIE, H. HÖFLING AND R. TIBSHIRANI

FIG. 6. Example of the one-dimensional search in the coordinate descent cycle for a FLSA prob-
lem with 5 parameters. Shown is the gradient for β3, with the other 4 parameters set at the global
minimizing values. There are discontinuities at ˜β2, ˜β4 and zero. We look for a zero-crossing in each
of the intervals (−∞, ˜β4), ( ˜β4, 0), (0, ˜β2), ( ˜β2,∞), and if none is found, take the minimum of f (β)
over the set of discontinuities. In this case, the minimum is at a discontinuity, with ˜β3 = ˜β4.
a zero of (24) in each of the four intervals (−∞, 0], (0, ˜βi−1], ( ˜βi−1, ˜βi+1] and
( ˜βi+1,∞). Since the function is piecewise linear, there is an explicit solution,
values for βi: 0, ˜βi−1 and ˜βi+1, and ﬁnd the one giving the smallest value of the
objective function f (β). Figure 6 illustrates the procedure on a simulated example.
Other orderings among 0, ˜βi−1 and ˜βi+1 are handled similarly, and at the end-
points i = 1 and i = p, there are only three intervals to check, rather than four.

when one exists. If no solution is found, we examine the three active-constraint

Fusion cycle. The descent cycle moves parameters one at a time. Inspection
of Figure 4 shows that this approach can get stuck. One way to get around this is
to consider a potential fusion of parameters, when a move of a single βi fails to
improve the loss criterion. This amounts to enforcing |βi − βi−1| = 0 by setting
βi = βi−1 = γ . With this constraint, we try a descent move in γ . Equation (24)
now becomes

∂f (β)

∂γ

(25)

= −(yi−1 − γ ) − (yi − γ )

+ 2λ1 · sign(γ ) − λ2 · sign( ˜βi+1 − γ )
+ λ2 · sign(γ − ˜βi−2).

If the optimal value for γ decreases the criterion, we accept the move setting βi =
βi−1 = γ .
Notice that the fusion step is equivalent to temporarily collapsing the problem
to one with p − 1 parameters:
• we replace the pair yi−1 and yi with the average response ¯y = (yi−1+ yi )/2 and
an observation weight of 2;

PATHWISE COORDINATE OPTIMIZATION

313

• the pair of parameters βi−1 and βi are replaced by a single γ , with a penalty
weight of 2 for the ﬁrst penalty.

At the end of the entire process of descent and fusion cycles for a given λ2, we
identify adjacent nonzero solution values that are equal and collapse the data ac-
cordingly, maintaining a weight vector to assign weights to the observations aver-
ages and the contributions to the ﬁrst penalty.

Smoothing cycle. Although the fusion step often leads to a decrease in f ( ˜β),
it is possible to construct examples where, for a particular value of λ2, no fusion
of two neighbors causes a decrease, but a fusion of three or more can. Our ﬁnal
strategy is to solve a series of fused lasso problems sequentially, ﬁxing λ1, but
varying λ2 through a range of values increasing in small increments δ from 0.
1. Start with λ2 = 0, hence, with the lasso solution with penalty parameter λ1.
2. Increment λ2 ← λ2 + δ, and run the descent and fusion cycles repeatedly until
no further changes occur. After convergence of the process for a given value λ2,
identify neighboring solution values that are equal and nonzero and collapse the
problem as described above, updating the weights.

The smoothing cycle is then as follows:

3. Repeat step 2 until a target value of λ2 is reached (or a target bound s2).

Our strategy relies on the following assumptions:

(A1) If the increments δ are sufﬁciently small, fusions will occur between no more

than two neighboring points at a time.

(A2) Two parameters that are fused in the solution for (λ1, λ2) will be fused for

(cid:8)
all (λ1, λ
2 > λ2).

By collapsing the data after each solution, we can achieve long fusions by a
sequence of pairwise fusions. Note that each of the fused parameters can represent
more than one parameter in the original problem. For example, if βj has a weight
of 3, and βi+1 a weight of 2, then the merged parameter has a weight of 5, and
represents 5 neighboring parameters in the original problem.

n−m(cid:2)
i=1

n−m(cid:2)
i=1

After m fusions, the problem has the form
wi (yi − βi )2 + λ1

Cm + min

wi|βi| + n−m(cid:2)

|βi − βi−1|.

1
2

β

(26)
Initially, m = 0, wi = 1, and C0 = 0. If the (m+1)st fusion is between βi−1 and βi,
then the following updates occur:
• ¯y ← (wi−1yi−1 + wi yi )/(wi−1 + wi ).
• w
+ ← wi−1 + wi.
• Cm+1 = Cm + 1
• yi−1 ← ¯y, wi−1 ← w

[wi−1 · (yi−1 − ¯y)2 + wi · (yi − ¯y)2].

i=2

2

+

.

314

J. FRIEDMAN, T. HASTIE, H. HÖFLING AND R. TIBSHIRANI

FIG. 7.
parameters increases.

Small example of the fused lasso. λ1 is ﬁxed at 0.01; as λ2 increases, the number of fused

• Discard observation i, and reduce all indices greater than i by 1.
Note that we don’t actually need to carry out the update for Cm, because no para-
meters are involved.
Figure 7 shows an example with just 9 data points. We have ﬁxed λ1 = 0.01
and show the solutions for four values of λ2. As λ2 increases, the number of fused
parameters increases.

Assumption (A1) requires that the data have some randomness (i.e., no pre-
existing ﬂat plateaus exist). Assumption (A2) holds in general. We prove that both
assumptions hold for the FLSA procedure in the next section.

Numerical experiments show that (A2) does not always hold for the general
fused lasso. Hence, the extension of this algorithm to the general fused lasso (de-
tailed in the Appendix) is not guaranteed to yield the exact solution. Note that each
descent and fusion cycle can only decrease the convex objective and, hence, must
converge. We terminate this pair of cycles when the change in parameter estimates
is less than some threshold. The smoothing cycle is done over a discrete grid of λ2
values.

4. Optimality conditions.

In this section we derive the optimality conditions
for the FLSA problem, and use them to show that our algorithms’ assumptions
(A1) and (A2) are satisﬁed.

PATHWISE COORDINATE OPTIMIZATION

315

We consider the Lagrangian form (23) for the fused lasso. The standard Karush–
Kuhn–Tucker conditions for this problem are fairly complicated, since we need
to express each parameter in terms of its positive and negative parts in order to
make the penalty differentiable. A more convenient formulation is through the sub-
gradient approach [see, e.g., Bertsekas (1999), Proposition B.24]. The equations
for the subgradient have the form

−(y1 − β1) + λ1s1 − λ2t2 = 0,
−(yj − βj ) + λ1sj + λ2(tj − tj+1) = 0,

(27)
with sj = sign(βj ) if βj (cid:4)= 0 and sj ∈ [−1, 1] if βj = 0. Similarly, tj = sign(βj −
βj−1) if βj (cid:4)= βj−1 and tj ∈ [−1, 1] if βj = βj−1. These n equations are neces-
sary and sufﬁcient for the solution. We restate assumptions (A1) and (A2) more
precisely, and then prove they hold.

j = 2, . . . , n,

PROPOSITION 2. For the fused-lasso signal approximation algorithm detailed

in Section 3:

(cid:8)

(A1

(cid:8)

(A2

) If the sequence yi are in general position—speciﬁcally, no two consecutive
yj values are equal—and the increments δ are sufﬁciently small, fusions will
occur between no more than two neighboring points at a time.

) Two parameters that are fused in the solution for (λ1, λ2) will be fused for

(cid:8)
all (λ1, λ
2 > λ2).

(cid:8)

PROOF. We ﬁrst prove (A2

). Suppose we have a stretch of nonzero solutions
ˆβj−k, ˆβj−k+1, . . . , ˆβj that are equal for some value λ2, and ˆβj−k−1 and ˆβj+1 are
not equal to this common value. Then tj−k and tj+1 each take a value in {−1, 1};
we denote these boundary values by Tj−k and Tj+1. Although the parameters
tj−k+1, . . . , tj can vary in [−1, 1] as λ2 changes (while the fused group remains
intact), the values depend on only the (j − k + 1)st through j th equations in the
system (27), because the boundary values are ﬁxed. Taking pairwise differences,
and using the fact that ˆβj−k = ˆβj−k+1 = ··· = ˆβj , this subgroup of equations sim-

pliﬁes to

(28)





2 −1
−1
...
0
0

= 1
λ2







···
0
0
0
···
2 −1
0
0
...
...
...
...
. . .
2 −1
··· −1
0
0 −1
···

2
0
yj−k+1 − yj+k
yj−k+2 − yj−k+1
yj−1 − yj−2
yj − yj−1




 +





...




 .

tj−k+1
tj−k+2

...
tj−1

tj
Tj−k
0
...
0
Tj+1

316

J. FRIEDMAN, T. HASTIE, H. HÖFLING AND R. TIBSHIRANI

λ2

y + T , and let C = M

Write this system symbolically as Mt = 1
−1. The ex-
plicit form for C given in Schlegel (1970) gives C(cid:7)1 = (n− (cid:7)+ 1)/(n+ 1), C(cid:7)n =
(cid:7)/(n+ 1). It is easy to check for all three possibilities for T that CT ∈ [−1, 1] ele-
Cy + CT ) ∈ [−1, 1] elementwise as well, since
mentwise. We know that t = ( 1
(cid:8)
λ2
t is a solution to (23) at λ2. For λ
2 > λ2, the elements of the ﬁrst terms shrink, and
2) remain in [−1, 1]. This implies that the fused set remains
(cid:8)
hence the values t (λ
fused as we increase λ2. These equations describe the path t (λ2) for λ2 increasing,
and only change when one of the boundary points (fused sets) is fused with the
current set, and the argument is repeated. This proves (A2

).

(cid:8)

(cid:8)

We now address (A1

). Suppose the data are in general position (e.g., have a

random noise component), and we have the lasso-solution ˆβj for λ1. Because of
the randomness, no neighboring nonzero parameters ˆβj will be exactly the same.
This means for each nonzero value ˆβj , we can write an equation of the form (27)
where we know exactly the values for sj , tj and tj+1 (each will be one of the values
{−1,+1}). This means that we can calculate exactly the path of each such βj as
we increase λ2 from zero, until an event occurs that changes the sj , tj . By looking
at all pairs, we can identify the time of the ﬁrst fusion of such pairs. The data are
then fused together and reduced, and the problem is repeated. Fusions occur one-
at-a-time in this fashion, at a distinct sequence of values for λ2. Hence, for δ small
enough in our smoothing step, we can ensure that we encounter these fusions one
at a time. (cid:1)

5. Comparison of run times.

In this section we compare the run times of the
coordinate-wise algorithm to standard algorithms, for both the lasso and diagonal
fused lasso (FLSA) problems. All timings were carried out on a Intel Xeon 2.80GH
processor.

5.1. Lasso speed trials. We generated Gaussian data with n observations and
(cid:8) having the same population cor-
p predictors, with each pair of predictors Xj , Xj
relation ρ. We tried a number of combinations of n and p, with ρ varying from
zero to 0.95. The outcome values were generated by
βj Xj + k · Z,

(29)
where βj = (−1)j exp(−2(j − 1)/20), Z ∼ N (0, 1) and k is chosen so that the
signal-to-noise ratio is 3.0. The coefﬁcients are constructed to have alternating
signs and to be exponentially decreasing.

Y = p(cid:2)

j=1

Table 1 shows the average CPU timings for the coordinatewise algorithm, two
versions of the LARS procedure and lasso2, an implementation of the homotopy
algorithm of Osborne et al. (2000). All algorithms are implemented as R language
functions. The coordinate-wise algorithm does all of its numerical work in Fortran,

PATHWISE COORDINATE OPTIMIZATION

317

Run times (CPU seconds) for lasso problems of various sizes n, p and different correlation between

the features. Methods are the coordinate-wise optimization (Fortran), LARS (R and Fortran

versions) and lasso2 (C language)—the homotopy procedure of Osborne et al. (2000)

TABLE 1

Method

Population correlation between features

0

0.31
2.18
2.01
2.42

0

4.66
28.40

0.1

0.33
2.46
2.09
2.16

0.1

4.51
27.34

n = 100, p = 1000
0.5
0.2

0.40
0.57
2.14
2.45
2.12
1.947
2.39
2.18
n = 100, p = 5000
0.5
0.2

3.14
24.40

5.77
22.32

n = 100, p = 20, 000

0.9

1.20
2.37
2.50
2.01

0.9

4.44
22.16

0.95

1.45
2.10
2.22
2.71

0.95

5.43
22.75

0
7.03
116.26

0.1
9.34
122.39

0.2
8.83
121.48

0.5
10.62
104.17

0.9
27.46
100.30

0.95
40.37
107.29

n = 1000, p = 100
0.5
0.2
0.04
0.04
0.40
0.40
0.22
0.23
0.69
0.68
n = 5000, p = 100
0.5
0.2
0.16
0.14
1.02
1.04
1.10
1.10
3.00
2.95

0.1
0.04
0.41
0.24
0.66

0.1
0.15
1.03
1.09
2.90

0
0.03
0.42
0.30
0.73

0
0.16
1.02
1.07
2.91

0.9
0.06
0.40
0.23
0.69

0.9
0.15
1.02
1.10
2.95

0.95
0.08
0.40
0.28
0.70

0.95
0.16
1.03
1.08
2.92

coord-Fort
LARS-R
LARS-Fort
lasso2-C

coord-Fort
LARS-R
LARS-Fort would not run
lasso2 would not run

coord-Fort
LARS-R
LARS-Fort would not run
lasso2 would not run

coord-Fort
LARS-R
LARS-Fort
lasso2-C

coord-Fort
LARS-R
LARS-Fort
lasso2-C

while lasso2 does its numerical work in C. LARS-R is the “production version” of
LARS (written by Efron and Hastie), doing much of its work in R, calling Fortran
routines for some matrix operations. LARS-Fort (due to Ji Zhu) is a version of
LARS that does all of its numerical work in Fortran. Comparisons between differ-

318

J. FRIEDMAN, T. HASTIE, H. HÖFLING AND R. TIBSHIRANI

FIG. 8. CPU times for coordinate descent, for the same problem as in Table 1, for different values
of n and p. In each case the times are averaged over ﬁve runs and averaged over the set of values of
the other parameter (n or p).

ent programs are always tricky: in particular, the LARS procedure computes the
entire path of solutions, while the coordinate-wise procedure and lasso2 solve the
problems for a set of pre-deﬁned points along the solution path. In the orthogonal
case, LARS takes min(n, p) steps: hence, to make things roughly comparable, we
called the latter two algorithms to solve a total of min(n, p) problems along the
path.

Not surprisingly, the coordinate-wise algorithm is fastest when the correlations
are small, and gets slower when they are large. It seems to be very competitive with
the other two algorithms in general, and offers some potential speedup, especially
when n > p.

Figure 8 shows the CPU times for coordinate descent, for the same problem as
in Table 1. We varied n and p, and averaged the times over ﬁve runs. We see that
the times are roughly linear in n and in p.

A key to the success of the coordinate-wise algorithm for lasso is the fact that,
for squared error loss, the ingredients needed for each coordinate step can be easily
updated as the algorithm proceeds. We can write the second term in (9) as

xij (yi − ˜yi ) = (cid:12)xj , y(cid:13) − (cid:2)

n(cid:2)
where (cid:12)xj , y(cid:13) =(cid:1)
i=1
i=1 xij yi, and so on. Hence, we need to compute inner products
of each feature with y initially, and then each time a feature xk enters the model,
we need to compute its inner product with all the rest. But importantly, O(n) cal-
culations do not have to be made at every step. This is the case for all penalized
procedures with squared error loss.

(cid:12)xj , xk(cid:13) ˜βk,

(30)

n

k: ˜βk >0

Friedlander and Saunders (2007) do a thorough comparison of the LARS (ho-
motopy) procedure to a number of interior point QP procedures for the lasso prob-
lem, and ﬁnd that LARS is generally much faster. Our ﬁnding that coordinate de-

PATHWISE COORDINATE OPTIMIZATION

319

scent is very competitive with LARS therefore suggests that also will outperform
interior point methods.
Finally, note that there is another approach to solving the FLSA problem for
λ1 = 0. We can transform to parameters θj = βj − βj−1, and we get a new lasso
problem in these new parameters. One can use coordinate descent to solve this
lasso problem, and then Proposition 1 gives the FLSA solution for other values
of λ1. However, this new lasso problem has a dense data matrix, and hence, the
coordinate descent procedure is many times slower than the procedure described
in this section. The procedure developed here exploits the near-diagonal structure
of the problem in the original parametrization.

5.2. Fused lasso speed trials. For the example of Figure 5, we compared the
pathwise coordinate algorithm to the two-phase active set algorithm sqopt of
Gill, Murray and Saunders (1999). Both algorithms are implemented as R func-
tions, but do all but the setup and wrapup computations in Fortran. Table 2 shows

TABLE 2

Run times (CPU seconds) for fused lasso (FLSA) problems of various sizes n for different values of

the regularization parameters λ1, λ2. The methods compared are the pathwise coordinate

optimization, and “standard”-two-phase active set algorithm sqopt of
Gill, Murray and Saunders (1999). The number of active constraints in

the solution is shown in each case

λ1

0.00
0.00
0.00
1.00
1.00
1.00
2.00
2.00
2.00

0.000
0.000
0.000
0.200
0.200
0.200
0.400
0.400
0.400

λ2

0.01
1.00
2.00
0.01
1.00
2.00
0.01
1.00
2.00

0.002
0.200
0.400
0.002
0.200
0.400
0.002
0.200
0.400

# Active

Coord

Standard

n = 1000
456
934
958
824
975
981
861
983
991
n = 5000
4063
3787
4121
4305
4449
4701
4301
4540
4722

0.040
0.024
0.019
0.022
0.024
0.023
0.023
0.023
0.018

0.217
0.170
0.135
0.150
0.141
0.129
0.108
0.123
0.119

2.100
0.931
0.987
1.519
1.561
1.404
1.499
1.418
1.407

20.689
26.195
29.192
41.105
48.998
45.136
41.062
41.755
38.896

320

J. FRIEDMAN, T. HASTIE, H. HÖFLING AND R. TIBSHIRANI

TABLE 3

Run times (CPU seconds) for pathwise coordinate optimization applied
to fused lasso (FLSA) problems with a large number of parameters n
averaged over different values of the regularization parameters λ1, λ2

n

100,000
500,000
1,000,000

Average CPU sec

3.54
14.93
29.81

the timings for the two algorithms for a range of values of λ1 and λ2. The result-
ing number of active constraints (i.e., βj = 0 or βj − βj−1 = 0) is also shown.
In the second part of the table, we increased the sample size to 5000. We see that
the coordinate algorithm offers substantial speedups, by factors of 50 up to 300 or
more.

In these tables, each entry for the pathwise coordinate procedure is the com-
putation time for the entire path of solutions leading to the given values λ1, λ2.
In practice, one could obtain all of the solutions for a given λ1 from a single run
of the algorithm, and hence, the numbers in the table are very conservative. But
we reported the results in this way to make a fair comparison with the standard
procedure since it can also exploit warm starts.

In Table 3 we show the run times for pathwise coordinate optimization for larger
values of n. As in the previous table, these are the averages of run times for the
entire path of solutions for a given λ1, and hence, are conservative. We were unable
to run the standard algorithm for these cases.

6. The two-dimensional fused lasso. Suppose we have a total of n2 cells,
laid out in a n × n grid (the square grid is not essential). We can generalize the
diagonal fused lasso (FLSA) to two-dimensions as follows:

n(cid:2)
i=1

n(cid:2)
(cid:8)=1

i

min
β

1
2

(yii

subject to

(31)

i

(cid:8) − βii
(cid:8) )2
n(cid:2)
n(cid:2)
i=1
(cid:8)=1
n(cid:2)
n(cid:2)
i=1
(cid:8)=2
n(cid:2)
n(cid:2)
i=2
(cid:8)=1

i

i

|βii

(cid:8)| ≤ s1,

|βi,i

(cid:8) − βi,i

(cid:8)−1| ≤ s2,

|βi,i

(cid:8)| ≤ s3.

(cid:8) − βi−1,i
(cid:8) to be both sparse and spatially

The penalties encourage the parameter map βii
smooth.

PATHWISE COORDINATE OPTIMIZATION

321

The fused lasso is related to signal processing methods such as “total varia-
tion denoising” [Rudin et al. (1992)], which uses a continuous smoothness penalty
analogous to the second penalty in the fused lasso. The TV criterion is written in
the form

(cid:23)

(32)

min

u



|∇u| du subject to (cid:6)u − y(cid:6)2 = σ 2,

where y is the data, u is the approximation with allowable error σ 2,  is a bounded
convex region in Rd, |·| denotes Euclidean norm in Rd and (cid:6)·(cid:6) denotes the norm
on L2(). Thus, in d = 1 dimension, this is a continuous analogue of the fused
lasso, but without the (ﬁrst) L1 penalty on the coefﬁcients. In d = 2 dimensions,
the TV approach is different: the discretized version uses the Euclidean norm of
the ﬁrst differences in u, rather than the sum of the absolute values of the ﬁrst
differences.
This problem (32) can be solved by a general purpose quadratic-programming
algorithm; we give details in the Appendix. However, for a p × p grid, there are
7p2 variables and 3p2 + 3 constraints, in addition to nonnegativity constraints on
the variables. For p = 256, for example, this is 458, 752 variables and 196, 611
constraints, so that ﬁnding the exact solution is impractical.

Hence, we focus on the pathwise coordinate algorithm. The algorithm has the
same form as in the one-dimensional case, except that rather than checking the
three active constraint values 0, βj−1 and βj+1, we check 0 and the four values to
the right, left, above and below (its four-neighborhood). The number of constraint
values reduces to 4 at the edges and 3 at the corners. The algorithm starts with in-
dividual pixels as the groups, and the four-neighborhood pixels are its “distance-1
neighbors.” In each fusion cycle we try to fuse a group with its distance-1 neigh-
bors. If the fusion is accepted, then the distance-1 neighbors of the fused group
are the union of the distance-1 neighbors of the two groups being joined (with the
groups themselves removed). Now one pixel might be the distance-1 neighbor to
each of the two groups being fused, and some careful bookkeeping is required to
keep track of this through appropriate weights. Full details are given in the Appen-
dix.

We do not provide a proof of the correctness of this procedure. However, in
our (limited) experiments we have found that it gives the exact solution to the
two-dimensional fused lasso. We guess that a proof along the lines of that in the
one-dimensional case can be constructed, although some additional assumptions
may be required.

As in the one-dimensional FLSA (Proposition 1), if we write the problem in
(cid:8)
1 > λ1, λ2, λ3) can

terms of Lagrange multipliers (λ1, λ2, λ3), the solution for (λ
be obtained by soft-thresholding the solutions for (λ1, λ2, λ3).

6.1. Example 1. Figure 9 shows a toy example. The data are in the top left,
representing a “+”-shaped image with N (0, 1) noise added. The reconstruction by

322

J. FRIEDMAN, T. HASTIE, H. HÖFLING AND R. TIBSHIRANI

FIG. 9. A toy example: the data are in the top left, representing a “+”-shaped image with added
noise. The reconstructions by the lasso and fused lasso are shown in the other panels. In each case
we did a grid search over the tuning parameters using a kind of two-fold validation.

the lasso and fused lasso are shown in the other panels. In each case we did a grid
search over the tuning parameters using a kind of two-fold validation. We created
a training set of the odd pixels (1, 3, 5 . . . in each direction) and tested it on the
even pixels. For illustration only, we chose the values that minimized the squared
reconstruction error over the test set. We see that the fused lasso has successfully
exploited the spatial smoothness and provided a much better reconstruction than
the lasso.

Table 4 shows the number of CPU seconds required for the standard and path-
wise coordinate descent algorithms, as n increases. We were unable to apply the
standard algorithm for n = 256 (due to memory requirements), and have instead
estimated the time by crude quadratic extrapolation.

PATHWISE COORDINATE OPTIMIZATION

323

TABLE 4

2D fused lasso applied to the toy problem. The table shows the number of
CPU seconds required for the standard and pathwise coordinate descent

algorithms, as n increases. The regularization parameters were set at
the values that yielded the solution in the bottom left panel of Figure 9

n

8
16
32
256

Standard

2.0 s
3.4 s
20.8 s
38 min

Coord

0.07 s
0.13 s
0.38 s
7.1 s

6.2. Example 2. Figure 10 shows another example. The noiseless image (top
panel) was randomly generated with 512 × 512 pixels. The background pixels are
zero, while the signal blocks have constant values randomly chosen between 1 and
4. The top right panel shows the reconstruction by the fused lasso: as expected, it is
perfect. In the bottom left we have added Gaussian noise with standard deviation
1.5. The reconstruction by the fused lasso is shown in the bottom right panel,
using two-fold validation to estimate λ1, λ2. The reconstruction is still quite good,
capturing most of the important features. In this example we did a search over
10 λ1 values. The entire computation for the bottom right panel of Figure 10,
including the two-fold validation to estimate the optimal values for λ1 and λ2,
took 11.3 CPU minutes.

6.3. Example 3. The top left panel of Figure 11 shows a 256× 256 gray scale
image of statistician Sir Ronald Fisher. In the top right we have added Gaussian
noise with a standard deviation 2.5. We explore the use of the two-dimensional
fused lasso for denoising this image. However, the ﬁrst (lasso) penalty doesn’t
make sense here, as zero does not represent a natural baseline. So instead, we
tried a pure fusion model, with λ1 = 0. We found the best value of λ2, in terms
of reconstruction error from the original noiseless image. The solution shown in
the bottom right panel gives a reasonable approximation to the original image and
reduces the reconstruction error from 6.18 to 1.15. In the bottom left panel we
have set λ2 = 0, and optimized over λ1. As expected, this pure lasso solution does
poorly, and the optimal value of λ1 turned out to be 0.

6.4. Applications to higher dimensions and other problems. The general strat-
egy for the two-dimensional fused lasso can be directly applied in higher di-
mensional problems, the difference being that each cell would have more poten-
tial distance-1 neighbors. In fact, the same strategy might be applicable to non-
Euclidean problems. All one needs is a notion of distance-1 neighbors and the

324

J. FRIEDMAN, T. HASTIE, H. HÖFLING AND R. TIBSHIRANI

FIG. 10. A second toy example. The 100 × 100 noiseless and noisy images are shown on the left,
while the corresponding fused lasso reconstructions are shown on the right. In each case we did a
grid search over the tuning parameters λ1, λ2 using a kind of two-fold validation.

property that the distance-1 neighbors of a fusion of two groups are the union of
the distance-1 neighbors of the two groups, less the fused group members them-
selves.

7. Discussion. Coordinate-wise descent algorithms deserve more attention
in convex optimization. They are simple and well-suited to large problems. We
have found that for the lasso, coordinate-wise descent is very competitive with
the LARS algorithm, probably the fastest procedure for that problem to-date.
Coordinate-wise descent algorithms can be applied to problems in which the con-
straints decouple, and a generalized version of coordinate-wise descent like the one
presented here can handle problems in which each parameter is involved in only a
limited number of constraints. This procedure is ideally suited for a special case of

PATHWISE COORDINATE OPTIMIZATION

325

FIG. 11. Top-left panel: 256 × 256 gray scale image of statistician Sir Ronald Fisher. Top-right
panel: Gaussian noise with standard deviation 2.5 has been added. Bottom-left panel: best solu-
tion with λ2 set to zero (pure lasso penalty); this gives no improvement in reconstruction error.
Bottom-right panel: best solution with λ1 set to zero (pure fusion penalty). This reduces the recon-
struction error from 6.18 to 1.15.

the fused lasso—the fused lasso signal approximator, and runs many times faster
than a standard convex optimizer. On the other hand, it is not guaranteed to work
for the general fused lasso problem, as it can get stuck away from the solution.

7.1. Software. Both Fortran and R language routines for the lasso, and the

one- and two-dimensional fused lasso will be made freely available.

326

J. FRIEDMAN, T. HASTIE, H. HÖFLING AND R. TIBSHIRANI

APPENDIX

A.1. Proof of Proposition 1. Suppose that we are optimizing a function of

the form

f (β) = 1

2

n(cid:2)
(yi − βi )2 + λ1
i=1

n(cid:2)
i=1

|βi| + (cid:2)

(i,j )∈C

λi,j|βi − βj|,

where (i, j ) ∈ C if the difference |βi − βj| is L1 penalized with penalty parameter
λi,j . This general form for the penalty includes the following models discussed
earlier:
Fused lasso signal approximator: Here, (i, j ) ∈ C if i = j −1. Furthermore, λi,j =
λ2.
Two-dimensional fused lasso: Here i itself is a two-dimensional coordinate i =
(i1, i2). Let (i, j ) ∈ C if |i1 − j1|+|i2 − j2| = 1. If |i1 − j1| = 1, then λi,j = λ2,
otherwise λi,j = λ3.
Now we prove a soft thresholding result.
LEMMA A.1. Assume that the solution for λ1 = 0 and λ2 ≥ 0 is known and
denote it by ˆβ(0, λ2). Then, the solution for λ1 > 0 is

ˆβi (λ1, λ2) = sign( ˆβi (0, λ2))
gi = −(yi − βi ) + λ1si + (cid:2)

PROOF. First ﬁnd the subgradient equations for β1, . . . , βn, which are
λ2tj,i = 0,

(cid:9)+

.

(cid:8)| ˆβi (0, λ2)| − λ1
λ2ti,j − (cid:2)

j:(j,i)∈C

where si = sign(βi ) if βi (cid:4)= 0 and si ∈ [−1, 1] if βi = 0. Also, ti,j = sign(βi −
βj ) for βi (cid:4)= βj and ti,j ∈ [−1, 1] if βi = βj . These equations are necessary and
sufﬁcient for the solution.
As it is assumed that a solution for λ1 = 0 is known, let s(0) and t (0) denote
the values of the parameters for this solution. Speciﬁcally, si (0) = sign( ˆβi (0)) for
ˆβi (0) (cid:4)= 0 and for ˆβi (0) = 0, it can be chosen arbitrarily, so set si (0) = 0. Note that
as λ2 is constant throughout the whole proof, the dependence of β, s and t on λ2
is suppressed for notational convenience.
In order to ﬁnd t (λ1), observe that soft thresholding of β(0) does not change
the ordering of pairs ˆβi (λ1) and ˆβj (λ1) for those pairs for which at least one
of the two is not 0 and, therefore, it is possible to deﬁne ti,j (λ1) = ti,j (0). If
ˆβi (λ1) = ˆβj (λ1) = 0, then ti,j can be chosen arbitrarily in [−1, 1] and, therefore,
let ti,j (λ1) = ti,j (0). Thus, without violating restrictions on ti,j , t (λ1) = t (0) for
all λ1 > 0. s(λ1) will be chosen appropriately below so that the subgradient equa-
tions hold.
Now insert ˆβi (λ1) = sign( ˆβi (0))(| ˆβi (0)|− λ1)
+
For λ1 > 0, look at 2 cases:

into the subgradient equations.

j:(i,j )∈C

PATHWISE COORDINATE OPTIMIZATION

CASE 1.

gi (λ1) = −yi + ˆβi (0) − λ1si (0) + λ1si (λ1)
λ2ti,j (λ1) − (cid:2)
j : (j,i)∈C

| ˆβi (0)| ≥ λ1
+ (cid:2)
= −yi + ˆβi (0) + (cid:2)

j : (i,j )∈C

λj,i tj,i (λ1)

λ2ti,j (0) − (cid:2)

j : (j,i)∈C

j : (i,j )∈C

327

λj,i tj,i (0) = 0

by setting si (λ1) = si (0), using the deﬁnition of t (λ1) and noting that ˆβ(0) was

assumed to be a solution.

CASE 2.

| ˆβi (0)| < λ1. Here, ˆβ(λ1) = 0 and, therefore,
gi (λ1) = −yi + λ1si (λ1) + (cid:2)
λ2ti,j (λ1) − (cid:2)
λ2ti,j (0) − (cid:2)
= −yi + ˆβi (0) + (cid:2)

j : (i,j )∈C

j : (j,i)∈C

j : (i,j )∈C

j : (j,i)∈C

λj,i tj,i (λ1)

λj,i tj,i (0) = 0

by choosing si (λ1) = ˆβi (0)/λ1 ∈ [−1, 1] and again using that ˆβ(0) is optimal.
As the subgradient equations hold for every λ1 > 0, soft thresholding gives the
solution. Note that we have assumed that λi,j = λ2, but this proof works for any
ﬁxed values λi,j .

Using this theorem, it is possible to make a more general statement.

(cid:8)
1

the solution for the parameters (λ

(cid:8) ˆβ(λ1, λ2) − (λ

1, λ2) = sign( ˆβ(λ1, λ2))
(cid:8)

PROOF. As a solution for minimizing f (β) exists and is unique for all
(cid:8)
1, λ2) are soft-

PROPOSITION A.1. Let ˆβ(λ1, λ2) be a minimum of f (β) for (λ1, λ2). Then
(cid:8)
(cid:8)
1 > λ1 is a soft thresholding of
1, λ2) with λ
ˆβ(λ1, λ2), that is,ˆβ(λ
(cid:9)+
− λ2)
λ1, λ2 ≥ 0, the solution ˆβ(0, λ2) exists and ˆβ(λ1, λ2) as well as ˆβ(λ
(cid:9)+

(cid:8)| ˆβi (0, λ2)| − λ1
1, λ2) = sign( ˆβi (0, λ2))(| ˆβi (0, λ2)| − λ
(cid:8)
(cid:8)
+
1)
for i = 1, . . . , n. If ˆβi (λ1, λ2) = 0, then also ˆβi (λ
1, λ2) = 0. For ˆβi (λ1, λ2) > 0, the
(cid:8)
soft-thresholding implies that the sign did not change and, thus, sign( ˆβi (λ1, λ2)) =
sign( ˆβi (0, λ2)). It then follows

ˆβi (λ1, λ2) = sign( ˆβi (0, λ2))
ˆβi (λ

thresholded versions of it using the previous theorem. Therefore,

,

,

.

ˆβi (λ

1, λ2) = sign( ˆβi (0, λ2))
(cid:8)
= sign( ˆβi (λ1, λ2))

(cid:9)+
(cid:8)| ˆβi (0, λ2)| − λ
(cid:8)| ˆβi (λ1, λ2)| − (λ

(cid:8)
1

(cid:8)
1

(cid:9)+
− λ1)

.

328

J. FRIEDMAN, T. HASTIE, H. HÖFLING AND R. TIBSHIRANI
Therefore, ˆβ(λ
1, λ2) is a soft-thresholded version of ˆβ(λ1, λ2). (cid:1)
(cid:8)

ii

i

i

I

ii

ii

ii

ii

ii

+
(cid:8) , β
ii

(cid:8) −θ h−

(cid:8) ≥ 0. Deﬁne θ h
−

Quadratic programming solution for the two-dimensional fused lasso. Here
we outline the solution to the two-dimensional fused lasso using the general pur-
pose sqopt package of Gill, Murray and Saunders (1999).
(cid:8) = βi,i
(cid:8) = β
(cid:8) − β
(cid:8) − βi−1,i
+
−
(cid:8) for i > 1,
(cid:8) with β
Let βii
(cid:8) = θ h+
(cid:8) = βi,i
(cid:8)−βi,i
> 1, and θ11 = β11. Let θ h
(cid:8) ≥
(cid:8) with θ h+
, θ h−
(cid:8)
ii
(cid:8)−1 for i
(cid:8)
θ v
ii
(cid:8). We string out each set of parameters into one long vector,
0, and similarly for θ v
ii
starting with the 11 entry in the top left, and going across each row.
Let L1 and L2 be the n × n matrices that compute horizontal and vertical dif-
ferences. Let e be a column n-vector of ones, and I be the n × n identity matrix.
Then the constraints can be written as
0 −I
0
0 −I
0
0
0
0
0
I
0
0
0
eT
0
0
eT
eT
0
0
0
eT
0
(cid:8), setting its bounds at ±∞ avoids a
(cid:8) = θ1i
(cid:8). Similarly, e0 equals e, with the

Here a0 = (∞, 0, 0 . . . 0). Since β1i
“double” penalty for |β1i
ﬁrst component set to zero.

0
0
I −I
0
eT
0
0
0
0

(cid:8)| and similarly for β1i

β
+
β
−
β
θ h+
θ h−
θ v+
θ v−

−a0
0
0
0


 ≤

 .

0
I
0
0
0
eT
0

a0
0
0
s1
s2
s3














L1
L2













(33)

≤

Pathwise coordinate optimization for the general one-dimensional fused lasso.
This algorithm has exactly the same form as that for the fused lasso signal approx-
imator given earlier. The form of the basic equations is all that changes.

(cid:4)(cid:25)

(cid:24)

(cid:3)

xij

xik

∂βj

(34)

k(cid:4)=j

∂f (β)

˜βk − xij βj

Equation (24) becomes

yi − p(cid:2)

= − n(cid:2)
i=1
+ λ1 · sign(βj ) − λ2 · sign( ˜βj+1 − βj )
+ λ2 · sign(βj − ˜βj−1),
assuming that βj /∈ {0, ˜βj−1, ˜βj+1}.
= − n(cid:2)
i=1
+ 2λ1 · sign(γ ) − λ2 · sign( ˜βj+2 − γ )
+ λ2 · sign(γ − ˜βj−1),

p(cid:2)
k /∈{j,j+1} xik

Similarly, expression (25) becomes

(cid:24)
yi −

˜βk − zi γ

∂f (β)

(35)

(cid:25)

∂γ

zi

|βij − βi,j−1|.
(cid:8) = (i

, j

(cid:8)

(cid:8)

) as d(p, p

(cid:8)

) =

(36)

min{βij} 1

2

n1(cid:2)
i=1
+ λ2

n2(cid:2)
n1(cid:2)
j=1
i=1
|βij − βi−1,j| + n1(cid:2)

|βij|
n2(cid:2)
j=1
Deﬁning the distance between two pixels p = (i, j ) and p
|i − i

n2(cid:2)
(yij − βij )2 + λ1
j=1
n2(cid:2)
n1(cid:2)
i=2
j=2
(cid:2)
p∈G
+ λ1

(yp − βp)2
(cid:2)
p∈G

(cid:8)|, (36) can be expressed as
min{βp} 1

(cid:2)
)=1

(cid:8)| + |j − j

i=1

(37)

2

|βp| + (λ2/2)

|βp − βp
(cid:8)|.
Consider a partition of G into K contiguous groups {Gk}, G =(cid:26)
(cid:8) = 0, k (cid:4)= k

Gk and Gk ∩
. A group Gk is contiguous if any p ∈ Gk can be reached from any
(cid:8) ∈ Gk by a sequence of distance-one steps within Gk. Deﬁne the distance

d(p,p

(cid:8)

(cid:8)

Gk
other p
between two groups Gk and Gk

(cid:8) as
(cid:8)

D(k, k

) = min
p∈Gk
(cid:8)∈Gk

p

(cid:8)

).

d(p, p

(cid:8)

Suppose one seeks the solution to (37) under the constraints that all pixels in the
same group have the same parameter value. That is, for each Gk, {βp = γk}p∈Gk .
The corresponding optimal group parameter values ˆγk are the solution to the un-
constrained problem

PATHWISE COORDINATE OPTIMIZATION

329

where zi = xij + xi,j+1. If the optimal value for γ decreases the criterion, we
accept the move setting βj = βj−1 = γ .

Pathwise coordinate optimization for two-dimensional fused lasso signal ap-
proximator. Consider a set (grid) G of pixels p = (i, j ), with 1 ≤ i ≤ n1,
1 ≤ j ≤ n2. Associated with each pixel is a data value yp = yij . The goal is to
obtain smoothed values ˆβp = ˆβij for the pixels that jointly solve

min{γk} 1

2

(38)

K(cid:2)
k=1
+ λ1

Nk(¯yk − γk)2
K(cid:2)
k=1

Nk|γk| + (λ2/2)
(cid:8) = (cid:2)

(cid:2)
(cid:8)∈Gk

(cid:8)

p∈Gk

p

wkk

where Nk is the number of pixels in Gk, ¯yk is the mean of the pixel data values
in Gk, and

D(k,k

I[d(p, p

(cid:8)

) = 1].

(cid:2)
)=1

(cid:8)

(cid:8)|γk − γk

(cid:8)|,

wkk

330

J. FRIEDMAN, T. HASTIE, H. HÖFLING AND R. TIBSHIRANI

Note that (38) is equivalent to (37) when all groups contain only one pixel.

Further, suppose that for a given partition one wishes to obtain the solution to
) = 1,
(38) with the additional constrain that two adjacent groups Gl and Gl
(cid:8) = γm, or equivalently, {βp =
have the same parameter value γm; that is, γl = γl
γm}p∈Gl∪Gl
(cid:8)
(cid:8) . This can be accomplished by deleting groups l and l
from the sum
in (38) and adding the corresponding “fused” group Gm = Gl ∪ Gl
(cid:8), with Nm =
Nl + Nl

(cid:8), D(l, l

(cid:8)

)=1 ∪ {Gk

(cid:8)}D(l

(cid:8)

)=1 − Gl − Gl

(cid:8)

(cid:8) ,

,k

{Gk

(cid:8), ¯ym = (Nlyl + Nl
(cid:8) yl
(cid:8) )/Nm,
(cid:8)}D(m,k
)=1
(cid:8)
(cid:8)}D(l,k
= {Gk
(cid:8).
(cid:8)

(cid:8) = wlk

(cid:8) + wl

k

(cid:8)

(39)

and wmk

(cid:8)}k

(cid:8)}D(k,k

The strategy for solving (36) is based on (38). As with FLSA (Section 3), there
are three basic operations: descent, fusion and smoothing. For a ﬁxed value of λ1,
we start at λ2 = 0 and n1 · n2 groups each consisting of a single pixel. The initial
λ2 = 0 solution of each γk is obtained by soft-thresholding γk = S(¯yk, λ1) as in (3).
Starting at this solution, the value of λ2 is incremented by a small amount λ2 ←
λ2+ δ. Beginning with γ1, the descent operation solves (38) for each γk holding all
other {γk
(cid:8)(cid:4)=k at their current values. The derivative of the criterion in (38) with
respect to γk is piecewise linear with breaks at 0, {γk
)=1. The solution for
γk is thus obtained in the same manner as that for the one–dimensional problem
described in Section 3. If this solution fails to change the current value of γk,
) = 1 are
successive provisional fusions of Gk with each Gk
considered, and the solution for the corresponding fused parameter γm is obtained.
The derivative of the criterion in (38) with respect to γm is piecewise linear with
breaks at 0, {γk
)=1 (39). If any of these fused solutions for γm improves
(cid:8) = γm. If not, the current value of γk
the criterion, one provisionally sets γk = γk
remains unchanged.
One then applies the descent/fusion strategy to the next parameter, k ← k + 1,
and so on until a complete pass over all parameters {γk} has been made. These
passes (cycles) are then repeated until one complete pass fails to change any pa-
rameter value, at which point the solution for the current value of λ2 has been
reached.

(cid:8) for which D(k, k

(cid:8)}D(m,k

(cid:8)

(cid:8)

(cid:8)

(cid:8) for which γk = γk

At this point each current group Gk is permanently fused (merged) with all
) = 1, producing a new crite-
groups Gk
rion (38) with potentially fewer groups. The value of λ2 is then further incremented
λ2 ← λ2 + δ and the above process is repeated starting at the solution for the pre-
vious λ2 value. This continues until a speciﬁed maximum value of λ2 has been
reached or until only one group remains.

(cid:8) (cid:4)= 0, and D(k, k

(cid:8), γk

(cid:8)

Acknowledgments. We thank Anita van der Kooij for informing us about her
work on the elastic net, Michael Saunders and Guenther Walther for helpful dis-
cussions, and Balasubramanian Narasimhan for valuable help with our software.

PATHWISE COORDINATE OPTIMIZATION

331

A special thanks to Stephen Boyd for telling us about the subgradient form (28).
While writing this paper, we learned of concurrent, independent work on coor-
dinate optimization for the lasso and other convex problems by Ken Lange and
Tongtong Wu. We thank the Editors and two referees for comments led to substan-
tial improvements in the manuscript.

REFERENCES

BERTSEKAS, D. (1999). Nonlinear Programming. Athena Scientiﬁc.
BREIMAN, L. (1995). Better subset selection using the nonnegative garrote. Technometrics 37 738–

754. MR1365720

CHEN, S. S., DONOHO, D. L. and SAUNDERS, M. A. (1998). Atomic decomposition by basis

pursuit. SIAM J. Sci. Comput. 33–61. MR1639094

DAUBECHIES, I., DEFRISE, M. and DE MOL, C. (2004). An iterative thresholding algorithm for
linear inverse problems with a sparsity constraint. Comm. Pure Appl. Math. 57 1413–1457.
MR2077704

DONOHO, D. and JOHNSTONE, I. (1995). Adapting to unknown smoothness via wavelet shrinkage.

J. Amer. Statist. Assoc. 90 1200–1224. MR1379464

EFRON, B., HASTIE, T., JOHNSTONE, I. and TIBSHIRANI, R. (2004). Least angle regression (with

discussion). Ann. Statist. 32 407–499. MR2060166

FRIEDLANDER, M. and SAUNDERS, M. (2007). Discussion of “Dantzig selector” by E. Candes and

T. Tao. Ann. Statist. 35 2385–2391.

FU, W. J. (1998). Penalized regressions: The bridge versus the lasso. J. Comput. Graph. Statist. 7

397–416. MR1646710

GILL, P., MURRAY, W. and SAUNDERS, M. (1999). Users guide for sqopt 5.3: A fortran package

for large-scale linear and quadratic programming. Technical report, Stanford Univ.

LI, Y. and ARCE, G. (2004). A maximum likelihood approach to least absolute deviation regression.

URASIP J. Appl. Signal Processing 2004 1762–1769. MR2131987

OSBORNE, M., PRESNELL, B. and TURLACH, B. (2000). A new approach to variable selection in

least squares problems. IMA J. Numer. Anal. 20 389–404. MR1773265

OWEN, A. (2006). A robust hybrid of lasso and ridge regression. Technical report, Stanford Univ.
RUDIN, L. I., OSHER, S. and FATEMI, E. (1992). Nonlinear total variation based noise removal

algorithms. Phys. D 60 259–268.

SCHLEGEL, P. (1970). The explicit inverse of a tridiagonal matrix. Math. Comput. 24 665–665.

MR0273798

TIBSHIRANI, R. (1996). Regression shrinkage and selection via the lasso. J. Roy. Statist. Soc. Ser.

B 58 267–288. MR1379242

TIBSHIRANI, R., SAUNDERS, M., ROSSET, S., ZHU, J. and KNIGHT, K. (2005). Sparsity and

smoothness via the fused lasso. J. Roy. Statist. Soc. Ser. B 67 91–108. MR2136641

TIBSHIRANI, R. and WANG, P.

(2007). Spatial smoothing and hot spot detection for CGH data

using the fused lasso. Biostatistics. Advance Access published May 18, 2007.

TSENG, P. (1988). Coordinate ascent for maximizing nondifferentiable concave functions. Technical
Report LIDS-P, 1840, Massachusetts Institute of Technology, Laboratory for Information and
Decision Systems.

TSENG, P. (2001). Convergence of block coordinate descent method for nondifferentiable maxima-

tion. J. Opt. Theory Appl. 109 474–494. MR1835069

VAN DER KOOIJ, A. (2007). Prediction accuracy and stability of regresssion with optimal scaling

transformations. Technical report, Dept. Data Theory, Leiden Univ.

WANG, H., LI, G. and JIANG, G.

(2006). Robust regression shrinkage and consistent variable

selection via the lad-lasso. J. Business Econom. Statist. 11 1–6.

332

J. FRIEDMAN, T. HASTIE, H. HÖFLING AND R. TIBSHIRANI

YUAN, M. and LIN, Y. (2006). Model selection and estimation in regression with grouped variables.

J. Roy. Statist. Soc. Ser. B 68 49–67. MR2212574

ZHOU, H. and HASTIE, T. (2005). Regularization and variable selection via the elastic net. J. Roy.

Statist. Soc. Ser. B 67 301–320. MR2137327

J. FRIEDMAN
DEPARTMENT OF STATISTICS
STANFORD UNIVERSITY
STANFORD, CALIFORNIA 94305
USA
E-MAIL: jhf@stanford.edu

H. HÖFLING
DEPARTMENT OF STATISTICS
STANFORD UNIVERSITY
STANFORD, CALIFORNIA 94305
USA
E-MAIL: hhoeﬂin@gmail.com

T. HASTIE
DEPARTMENTS OF STATISTICS, AND HEALTH

RESEARCH & POLICY
STANFORD UNIVERSITY
STANFORD, CALIFORNIA 94305
USA
E-MAIL: hastie@stanford.edu

R. TIBSHIRANI
DEPARTMENTS OF HEALTH,

RESEARCH & POLICY AND STATISTICS

STANFORD UNIVERSITY
STANFORD, CALIFORNIA 94305
USA
E-MAIL: tibs@stanford.edu

